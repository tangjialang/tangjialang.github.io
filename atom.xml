<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TJL的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tjl-myblog.cn/"/>
  <updated>2020-12-26T05:04:44.182Z</updated>
  <id>http://www.tjl-myblog.cn/</id>
  
  <author>
    <name>游戏人生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逻辑英语</title>
    <link href="http://www.tjl-myblog.cn/%E9%80%BB%E8%BE%91%E8%8B%B1%E8%AF%AD.html"/>
    <id>http://www.tjl-myblog.cn/逻辑英语.html</id>
    <published>2020-01-04T01:58:28.000Z</published>
    <updated>2020-12-26T05:04:44.182Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><ul><li><p>句子：主语 + 谓语 + (宾语 可省略)</p><blockquote><p><strong>什么什么的后面一般是主语或宾语</strong><br>句子的最小单位：主语 + 谓语（让名词有动作，静物变得有动作）<br>状语（时间，地点）<br>祈使句 面对面对话(可省略一些应诉)</p></blockquote></li><li><p>主系(系)表(表现)</p><blockquote><p>静态</p></blockquote></li></ul><p>英文必须有主语(主谓 宾(可省略)、主系表) 关联词打死不会省略</p><blockquote></blockquote><p>中文可省略主语</p><blockquote><p>翻译的时候要先自动补全找到主干(主(常省略) 谓(常省略) 宾、主 系(常省略) 表)然后再来翻译 关联词会省略(气质来表示)</p></blockquote><blockquote><p>坐</p><ul><li>sit</li><li>sead(被动坐 正式场合 被安排)<br>被动语态</li></ul></blockquote><hr><p><img src="逻辑英语/Noun_1.png" alt="图片还没有哦"></p><h1 id="名词-Noun-简写为-n"><a href="#名词-Noun-简写为-n" class="headerlink" title="名词 Noun 简写为 n."></a>名词 Noun 简写为 n.</h1><blockquote><p>名词是表示人、事物、地点或抽象概念的词</p></blockquote><h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><blockquote><p>专有名词指世界上特定的或独一无二的人或事物</p></blockquote><p><strong>包括：</strong></p><ul><li><p>人名：Tom 汤姆，Mary 玛丽</p></li><li><p>组织名称：联合国</p></li><li><p>国家名：China 中国，Russia 俄罗斯</p></li><li><p>江河湖海名：黄河黄河 </p></li><li><p>地名：Shanghai 上海，Hong Kong 香港</p></li><li><p>月份节日：五月May，圣诞节</p></li></ul><h2 id="普通名词"><a href="#普通名词" class="headerlink" title="普通名词"></a>普通名词</h2><h2 id="实词-notional-words"><a href="#实词-notional-words" class="headerlink" title="实词 notional words"></a>实词 notional words</h2><blockquote><p>指有实实在在意思的词</p></blockquote><ul><li>名词</li><li>代词</li><li>数词</li><li>形容词</li><li>动词</li><li>副词</li></ul><h2 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h2><blockquote><p>指没有完整意义，但有语法意义或功能的词</p><ul><li>冠词</li><li>介词</li><li>连词</li><li>感叹词</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      逻辑英语
    
    </summary>
    
      <category term="逻辑英语" scheme="http://www.tjl-myblog.cn/categories/%E9%80%BB%E8%BE%91%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="逻辑英语" scheme="http://www.tjl-myblog.cn/tags/%E9%80%BB%E8%BE%91%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>unity学习笔记</title>
    <link href="http://www.tjl-myblog.cn/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.tjl-myblog.cn/unity学习笔记.html</id>
    <published>2019-12-23T08:53:30.000Z</published>
    <updated>2020-03-08T08:01:13.588Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h1 id="unity-第一课（初识unity）"><a href="#unity-第一课（初识unity）" class="headerlink" title="unity 第一课（初识unity）"></a>unity 第一课（初识unity）</h1><h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><ul><li><code>.net</code>跨平台开源框架（只限于windows）</li><li><code>mono</code>跨平台开源框架 跨平台的.net标准框架（不限于windows）<h2 id="基于mono的两大项目："><a href="#基于mono的两大项目：" class="headerlink" title="基于mono的两大项目："></a>基于<code>mono</code>的两大项目：</h2></li><li>unity（游戏开发引擎）</li><li><a href="https://www.xamarin.com" rel="external nofollow noopener noreferrer" target="_blank">Xamarin（跨平台的移动App的开发工具）</a></li></ul><blockquote><p>unity就是基于mono的基础上，进行游戏引擎开发而实现的跨平台</p></blockquote><h1 id="unity-第二课（unity场景树渲染体系物理体系）"><a href="#unity-第二课（unity场景树渲染体系物理体系）" class="headerlink" title="unity 第二课（unity场景树渲染体系物理体系）"></a>unity 第二课（unity场景树<em>渲染体系</em>物理体系）</h1><h2 id="unity组件开发的优点"><a href="#unity组件开发的优点" class="headerlink" title="unity组件开发的优点"></a>unity组件开发的优点</h2><ul><li>使用一个开发工具，将所有的工作环节都集成在一起，相互独立的进行开发，开发效率提升。</li></ul><h2 id="场景树"><a href="#场景树" class="headerlink" title="场景树"></a>场景树</h2><p><code>GameObject = 节点 + Transform</code></p><ul><li>每一个场景是由节点树组成的（由节点的Transform组成的）</li><li>场景树基于Transform组成 而不是游戏节点GameObject</li></ul><h2 id="图像世界"><a href="#图像世界" class="headerlink" title="图像世界"></a>图像世界</h2><p><strong>渲染关系</strong><br>Mesh（3D模型网格） + Mesh render + 材质（Material 皮肤、贴图） = 3D模型</p><h2 id="物理世界"><a href="#物理世界" class="headerlink" title="物理世界"></a>物理世界</h2><p><strong>物理关系</strong><br>加刚体，运动的物体，可以运动可以受力。<br>不加刚体，静止的物体。<br>只有刚体而没有形状的话，相当于幽灵没有实质，所以需要物理形状。<br>在物理形状上，会有物理材质，就像不同天气，地面会有不同的地面（湿润、干燥）。</p><ul><li>刚体（Rigidbody）：让一个物体具有重量具有物理属性</li></ul><blockquote><p>物体分为两种</p><ul><li>没加刚体就是静态不动物体</li><li>加刚体的物体拥有物理属性可受力</li></ul></blockquote><ul><li>物理形状（Collider 碰撞器）：让物体拥有形状<ul><li>物理材质（下雨过后地面很滑，出太阳之后地面很干，这地面可以称为物理材质）</li></ul></li></ul><blockquote><p>有形状物体与物体才会发生联系</p></blockquote><h1 id="unity-第三课-Unity-C-的基本结构-类-成员-类的函数"><a href="#unity-第三课-Unity-C-的基本结构-类-成员-类的函数" class="headerlink" title="unity 第三课 (Unity C#的基本结构_类_成员_类的函数)"></a>unity 第三课 (Unity C#的基本结构_类_成员_类的函数)</h1><p>游戏的程序简单运作模式分为三步骤</p><ul><li><p>初始化</p></li><li><p>while循环</p><ul><li>处理游戏事件</li><li>渲染游戏场景画面</li><li>是否需要休眠（<strong>cpu性能好的情况才会休眠，如果性能不好就会一直执行循环，休眠是为了节约cpu，不休眠是为了给游戏换取最大的流程程度</strong>）<blockquote><p>1s要维持60fps 1s 分为60份 1s / 60 = 0.01666…（0.016s）</p><pre><code>cpu的处理能力 如果在0.01s就已经处理完了 (事件+物理计算+渲染画面)cpu就会休眠0.006s如果你cpu能力无法在0.016s内完成（事件+物理计算+渲染画面）你的游戏帧数就无法达到60fps</code></pre><ul><li>这个休眠就是用来维持游戏帧数在60fps上下，根据不同的cpu处理能力来决定休眠的时间</li></ul></blockquote></li></ul></li><li><p>游戏结束处理</p></li></ul><blockquote><p>手游 帧频到达60（顶峰） 虽然还能继续往上加 但是人眼是分辨不出什么差别的，60帧频就是人眼的极限了看着的画面就很流畅，如果继续增加帧频只会费电。</p></blockquote><h2 id="组件代码入口"><a href="#组件代码入口" class="headerlink" title="组件代码入口"></a>组件代码入口</h2><p>MonoBehaviour 组件的基本规则（基类）</p><ul><li>void Awake(){} 组件实例加载时调用</li><li>void Start(){} 在第一次update之前调用</li><li>void Update(){} 游戏每次刷新的时候调用</li><li>void FixedUpdate() {} 物理引擎每次固定刷新的时候调用，与帧频无关 主要是用于物理计算 （固定机制 根据cpu当前性能得到一个固定的频率）</li><li>void OnGUI() {} 绘制2D元素入口的时候调用，你如玩家的昵称，血条 绘制GUI元素</li></ul><blockquote><p>组件类和脚本文件名称要保持一致</p></blockquote><ul><li><p>程序跑起来的时候生成的</p><ul><li>栈 在函数执行返回之后进行回收</li><li>堆 在没有任何引用指向的时候进行回收</li></ul></li><li><p>程序加载启动的时候</p><ul><li>数据段、代码段 在程序关闭时 回收</li></ul></li></ul><h1 id="unity第四课-Unity-C-表达式-条件-循环-函数传参-out关键字"><a href="#unity第四课-Unity-C-表达式-条件-循环-函数传参-out关键字" class="headerlink" title="unity第四课 (Unity C#表达式_条件_循环_函数传参_out关键字)"></a>unity第四课 (Unity C#表达式_条件_循环_函数传参_out关键字)</h1><h2 id="out和ref"><a href="#out和ref" class="headerlink" title="out和ref"></a><a href="https://blog.csdn.net/qq373011556/article/details/81944690" rel="external nofollow noopener noreferrer" target="_blank">out和ref</a></h2><p>同：<br>1、都能返回多个返回值。</p><p>2、若要使用 ref 和 out 参数，则方法定义和调用方法都必须显式使用 ref 和 out 关键字。在方法中对参数的设置和改变将会直接影响函数调用之处 (参数的初始值）。</p><p>异：<br>1、ref 指定的参数在函数调用时候必须初始化，不能为空的引用。而 out 指定的参数在函数调用时候可以不初始化；</p><p>2、out 指定的参数在进入函数时会清空自己，必须在函数内部赋初值。而 ref 指定的参数不需要。</p><h1 id="unity第五课-Unity-C-构造函数调用基类继承-多态-重载"><a href="#unity第五课-Unity-C-构造函数调用基类继承-多态-重载" class="headerlink" title="unity第五课 (Unity_C#构造函数调用基类继承_多态_重载)"></a>unity第五课 (Unity_C#构造函数<em>调用基类</em>继承_多态_重载)</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul><li>基类的引用变量来保存子类的实例</li><li>使用 <code>virtual</code> 关键字修饰的函数就是一个虚函数，在实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过 <code>override</code> 关键字）所以说 子类如果要重写父类函数想实现C++的多态的话还得在子类函数前面用 <code>override</code> 关键字进行修饰。</li><li>虚函数的实现：每一个类都有一个虚函数表，当一个函数为虚函数的时候就会添加进表中，当new 这个实例的时候，会生成一个指向虚函数表的引用变量，当基去调用这个函数的时候，发现为虚函数，就会用这个引用变量去虚函数表中找这个函数，因为每一个类的虚函数表<br><img src="http://image.tjl-myblog.cn:4455/C#虚函数与虚函数表.png" alt="图片还没有哦"></li></ul><h1 id="第六课（Unity-C-数组-string-static-const-泛型编程-名字空间）"><a href="#第六课（Unity-C-数组-string-static-const-泛型编程-名字空间）" class="headerlink" title="第六课（Unity_C#数组_string_static_const_泛型编程_名字空间）"></a>第六课（Unity_C#数组_string_static_const_泛型编程_名字空间）</h1><p><code>string.Format</code> 格式化生成字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = string.Format(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, &quot;xiaohong&quot;, 10, &quot;male&quot;);</span><br></pre></td></tr></table></figure></p><p><code>string.Equals</code> 两个字符串是否相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">str = &quot;Hello&quot;;</span><br><span class="line">if(str.Equals(&quot;Hello&quot;))&#123;</span><br><span class="line">    //相等则进</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// == 表示比较 两个数据对象是否是同一个 如果是字符串值的比较就用这个函数</span><br></pre></td></tr></table></figure></p><p><code>ToUpper</code> 字符串转换为大写<code>str.ToUpper()</code></p><p><code>ToLower</code> 字符串转换为小写<code>str.ToLower()</code></p><h2 id="静态变量（static）、const、readonly"><a href="#静态变量（static）、const、readonly" class="headerlink" title="静态变量（static）、const、readonly"></a>静态变量（static）、const、readonly</h2><blockquote><p>类中不需要使用成员变量、纯逻辑而使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">    //static const 全局唯一</span><br><span class="line">    //使用类名.xxx</span><br><span class="line">    public static int pi = 3.14;</span><br><span class="line">    public static const int b = 2;</span><br><span class="line">    public const int c = 2; //不加static也行 const 不能修改的变量（常量）</span><br><span class="line"></span><br><span class="line">    //每一个实例，都会有一个readonly变量</span><br><span class="line">    //readonly的变量又一次修改的机会</span><br><span class="line">    //在对象构造的时候可进行赋值进行修改 之后就无法进行修改了</span><br><span class="line">    public readonly int test_readonly = 4;</span><br><span class="line"></span><br><span class="line">    //const 修饰累的成员变量，在编译的时候确定的常量，运行的时候无法修改</span><br><span class="line">    //readonly实例化的时候确定的常量，可以在构造函数的时候修改，之后就无法修改了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Debug.Log(Person.pi);</span><br><span class="line"></span><br><span class="line">Debug.Log(Person.b);</span><br><span class="line"></span><br><span class="line">Debug.Log(Person.c);</span><br></pre></td></tr></table></figure><p>使用 <code>类名.xxx</code>，存在数据段上（全局变量，静态变量）</p><p><strong>静态成员变量（全局唯一）<br>静态成员方法</strong></p><p>静态成员函数不需要实例直接用类即可调用，由于没有对象实例，静态成员没有this，我们没法访问对象的成员和调用成员函数。处理纯粹的逻辑例如<code>Math.sin Math.cos</code></p><h2 id="泛型编程（和C-的模板很像）"><a href="#泛型编程（和C-的模板很像）" class="headerlink" title="泛型编程（和C++的模板很像）"></a>泛型编程（和C++的模板很像）</h2><blockquote><p>假如一个类需要实现数值之间的<code>+、-、*、/</code>的计算，如果这个数值有<code>int float double</code>等多种数据类型的话，那么就需要N个类来实现这个方法了，如果使用泛型的话，只需要定义一个泛型类就可以实现N种计算<br><strong>泛型使用之前需要给定一个数据类型，因为他本是是没有数据类型的</strong><br>泛型可以是类可以是函数方法，如果成员方法要是泛型，那么类就先要是泛型才行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//这是一个泛型函数</span><br><span class="line">void Swao&lt;T&gt;(T a, T b)&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这是一个泛型类， 整数（int） Point、浮点数（int） Point</span><br><span class="line">//使用之前需要给定一个数据类型 会自动隐式生成相对数据类型的类</span><br><span class="line">class Point&lt;T&gt;&#123;</span><br><span class="line">    T xpos;</span><br><span class="line">    T ypos;</span><br><span class="line"></span><br><span class="line">    //这是一个泛型成员函数</span><br><span class="line">    public void add_object(T x, T y)&#123;</span><br><span class="line">        this.xpos = x;</span><br><span class="line">        this.ypos = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point&lt;int&gt; Point_int = new Point&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">//隐式生成</span><br><span class="line">// class Point&#123;</span><br><span class="line">//     int xpos;</span><br><span class="line">//     int ypos;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">Point&lt;float&gt; Point_float = new Point&lt;float&gt;();</span><br><span class="line"></span><br><span class="line">//隐式生成</span><br><span class="line">// class Point&#123;</span><br><span class="line">//     float xpos;</span><br><span class="line">//     float ypos;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间（）"><a href="#命名空间（）" class="headerlink" title="命名空间（）"></a>命名空间（）</h2><blockquote><p>为了彼此不互相冲突而有的命名空间，一般做库的时候才会使用命名空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using my_namespace;//让命名空间，加入搜索列表</span><br><span class="line"></span><br><span class="line">//制作自己的命名空间</span><br><span class="line">namespace my_namespace</span><br><span class="line">&#123;</span><br><span class="line">    //外面虽然已经有 Ponit 类了，但是由于命名空间不一样所以可行</span><br><span class="line">    class Point&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point point = new Ponit();</span><br><span class="line"></span><br><span class="line">//命名空间.xxx 每一个都加命名空间很麻烦 使用using即可解决</span><br><span class="line">//加了using 即可Point mypoint = new Ponit();这样使用</span><br><span class="line"></span><br><span class="line">my_namespace.Point mypoint = new my_namespace.Ponit();</span><br></pre></td></tr></table></figure><blockquote><p><strong>例如上面例子，如果有一样的就会先在当前文件查找 Point，如果找不到因为using 就会去my_namespace命名空间去查找。都找不到就会报错</strong></p></blockquote><h1 id="第七课-（unity-transform组件一）"><a href="#第七课-（unity-transform组件一）" class="headerlink" title="第七课 （unity_transform组件一）"></a>第七课 （unity_transform组件一）</h1><blockquote><p>任何一个组件，都会有一个gameObject指向它挂载的节点实例.<br>任何一个组件，都有个数据成员指向这个节点的transfrom组件实例的;<br>this.transfrom; 通过任何一个组件来获得每一个节点的transfrom组件。<br>同理，transfrom它也是一个组件，所以它也有一个gameObject指向它挂的节点</p></blockquote><blockquote><p><strong>每一个游戏物体 都有transfrom组件 而 每一个组件都有gameObject  所有用this.gameObject  能到到当前组件的实例 this.transfrom.gameObject  也能得到当前组件实例</strong></p></blockquote><blockquote><p>this.gameObject 与this.transform.gameObject是一样的<br>this.transform.transform.transform 可以一直这样往后面写，因为this是组件，又一个transform指向它的transform组件实例, this.transform.transform 如果你闲着不累可以写多一点。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//this.gameObject 和 this.transform.gameObject 是一样的</span><br><span class="line"></span><br><span class="line">this.gameObject.name //通过挂载的脚本得到name</span><br><span class="line">this.transform.Find(&quot;name&quot;).gameObject.name</span><br><span class="line">this.transform.Find(&quot;name&quot;);//通过名字查找节点</span><br><span class="line">this.transform.FindChild(&quot;name&quot;); //通过孩子节点的名字查找</span><br><span class="line"></span><br><span class="line">// Find(&quot;name/name&quot;) //可填多重路径</span><br><span class="line">// FindChild(&quot;name&quot;) //不能是多重路径</span><br></pre></td></tr></table></figure><h2 id="相对坐标-绝对坐标"><a href="#相对坐标-绝对坐标" class="headerlink" title="相对坐标/绝对坐标"></a>相对坐标/绝对坐标</h2><blockquote><p><strong>编辑器里面的 <code>postion</code> 是相对坐标，可是代码里面的<code>postion</code>是绝对坐标</strong><br>编辑器里面的世界坐标等于所有父节点的坐标加自己的相对坐标（绝对坐标）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这里是代码 和 编辑器里面是相反的</span><br><span class="line">this.transform.position //这个的是绝对坐标（世界坐标）</span><br><span class="line">this.transform.localPosition; //这个的是相对坐标</span><br></pre></td></tr></table></figure><h1 id="第八课-（unity-transform组件二）"><a href="#第八课-（unity-transform组件二）" class="headerlink" title="第八课 （unity_transform组件二）"></a>第八课 （unity_transform组件二）</h1><blockquote><p>一个网格的大小为1m</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 将局部坐标转成世界坐标</span><br><span class="line">// 将 Vector3(0, 0, 0) 这个坐标相对于以 this.transform 为原点的坐标 转为世界坐标</span><br><span class="line">// 假如 this.transform 的坐标为 Vector3(0, 0, 10) 那么  Vector3(0, 0, 0) </span><br><span class="line">// 相对于 Vector3(0, 0, 10) 的世界坐标就为 Vector3(0, 0, 10) 将点</span><br><span class="line">Vector3 w_pos = this.transform.TransformPoint(new Vector3(0, 0, 0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 就用 TransformVector（我的南方）就得到了，我的南方在地球的什么方</span><br><span class="line">// 简而言之就是 来获取本地向量 在 世界的什么方向</span><br><span class="line"></span><br><span class="line">//我的南方 不等于 地球的南方，我想知道 我的南方 在地球的什么方向 就用 TransformVector（我的南方向量）就得到了 我的南方在地球的什么方向 （TransformVector 可得到，我的本地坐标 在 世界坐标的什么 方向） 将向量</span><br><span class="line">w_pos = this.transform.TransformVector(0, 0, 0);</span><br><span class="line"></span><br><span class="line">// 将世界坐标转成局部坐标 将世界坐标的点 假如世界坐标点为 Vector3(0, 0, 10) </span><br><span class="line">// 那么 local_wpos 就为 Vector3(0, 0, 5) </span><br><span class="line">// Vector3(0, 0, 10)  这个点 相对于 Vector3(0, 0, 15)这个点的什么位置 Vector3(0, 0, 5) </span><br><span class="line">// 世界坐标转局部坐标</span><br><span class="line">Vector3 local_wpos = this.transform.InverseTransformPoint(new Vector3(0, 0, 15));</span><br><span class="line"></span><br><span class="line">// 平移物体 1：第二个参数为 参考系 2 第一个参数为 每个方向的分量</span><br><span class="line">// Tranlate(new Vector3(0,0,1),this.transform) this.transform 实例的方向</span><br><span class="line">// Tranlate(new Vector3(0,0,1),Space.World) 世界坐标轴方向</span><br><span class="line">// Tranlate(new Vector3(0,0,1),Space.self) 自身坐标轴方向</span><br></pre></td></tr></table></figure><blockquote><p>一个旋转主要就三种表示方法：</p><ul><li>矩阵（需要16个元素来存放，耗内存）</li><li>欧拉角（万象节锁，没有平滑插值，unity顺序为 ZXY）</li><li>四元素（提供平滑插值，欧拉角没有，比欧拉角多一个维度，复杂一点，增加了一个向量+外加多少度）</li></ul></blockquote><blockquote><p><strong>unity为了防止万向节锁代码里面 用的是四元素，编辑器为了只管看变化用的是欧拉角</strong><br><strong>unity transform里面为了避免万象节锁，使用的是四元数来存放一个旋转<br>unity编辑器里面为了直观的来旋转，使用的是欧拉角来表示</strong></p></blockquote><p>unity编辑器里面的旋转 是 欧拉角 代码里面是四元素 （unity中编辑器和代码是不一样的比如之前的position）</p><blockquote><p>物体旋转</p><ul><li>transform存放一个代表旋转的四元数rotation;</li><li>四元数转换成对应的欧拉角eulerAngles;</li><li>欧拉角转成四元数Quaternion.Euler(在原来基础上旋转，叠加需要，两个四元素相乘，<strong>把每个小变换组成一个大的总的变换，那么是用 * 和矩阵类似</strong>);</li><li>Rotate(旋转欧拉角度函数，在当前的基础上旋转);</li></ul></blockquote><h1 id="第九课-（unity-transform组件三）"><a href="#第九课-（unity-transform组件三）" class="headerlink" title="第九课 （unity_transform组件三）"></a>第九课 （unity_transform组件三）</h1><p><a href="https://blog.csdn.net/ChinarCSDN/article/details/82914420" rel="external nofollow noopener noreferrer" target="_blank">Unity 增量时间 Time.deltaTime 详解</a></p><ul><li><p>能达到一样的效果</p><blockquote><p><strong>欧拉角旋转</strong><br>this.cube.Rotate(new Vector3(0, 45, 0));<br><strong>旋转向量 + 角度</strong><br>this.cube.Rotate(new Vector3(0, 1, 0), 45);</p></blockquote></li><li><p><strong>RotateAround</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// RotateAround 围绕一个点 旋转多少度</span><br><span class="line">Vector3 pos = new Vector3(0, 0, 0);</span><br><span class="line">// 原点 方向上 角度45/s</span><br><span class="line">this.sphere.RotateAround(pos, new Vector3(0, 1, 0), Time.deltaTime * 45);</span><br></pre></td></tr></table></figure></li><li><p><strong>LookAT</strong></p><blockquote><p>跟看一个物体一样，一直看着这个物体不转眼</p><ol><li>头顶方向,旋转时候饶的这个向量，默认为y (0, 1, 0)</li><li>旋转角度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一个为 要盯着哪一个实例看 第二个为 方向 Y</span><br><span class="line">// 鼠标点击人物往哪一个方向看 这个函数就起到了关键的作用</span><br><span class="line">this.transform.LookAt(看的点的位置, new Vector3(0, 1, 0));</span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p><strong>Quaternion.FromToRotation</strong></p><blockquote><p>从开始向量，到目标向量的旋转四元素角度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//起点 终点 会 生成一个旋转角度</span><br><span class="line">Quaternion rot = Quaternion.FromToRotation(new Vector3(0, 0, 1), new Vector3(1, 0, 1));</span><br><span class="line">this.cube.rotation = rot;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>Lerp</strong></p><blockquote><p>线性插值 直线移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 起点         终点</span><br><span class="line">// from(0,0,0) to(10,0,0)</span><br><span class="line">// 用插值也能达到移动物体的目的 下面的代码会让cube的实例移动到(10,0,0)的位置然后停止</span><br><span class="line">// 最后一个参数用来控制移动的速度</span><br><span class="line">// this.cube.transform.position = Vector3.Lerp(Vector3.zero, Vector3.right * 10, 速度)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>Slerp</strong></p><blockquote><p>球面插值 球面弧线移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 起点         终点</span><br><span class="line">// 因为球面圆形就是 0 0 0 如果from为 0 0 0就会少一个点那么他就会是直线移动而不是球的弧线</span><br><span class="line">// from(-10,0,0) 球面插值from这个不能为 0 0 0  to(10,0,0)</span><br><span class="line">// 用插值也能达到移动物体的目的 下面的代码会让cube的实例移动到(10,0,0)的位置然后停止</span><br><span class="line">// 最后一个参数用来控制移动的速度 </span><br><span class="line">// this.cube.transform.position = Vector3.Slerp(Vector3.right * -10, Vector3.right * 10, Time.time * 0.1f);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="第十课（C-的结构体、属性、ref）"><a href="#第十课（C-的结构体、属性、ref）" class="headerlink" title="第十课（C#的结构体、属性、ref）"></a>第十课（C#的结构体、属性、ref）</h1><p>结构体是值类型 用 new 结构体也只是调用结构体的构造函数 他并不会在堆上开堆，用的是栈内存</p><h1 id="第十一课（unity-几何体-材质-FBX-package导入导出）"><a href="#第十一课（unity-几何体-材质-FBX-package导入导出）" class="headerlink" title="第十一课（unity_几何体_材质_FBX_package导入导出）"></a>第十一课（unity_几何体_材质_FBX_package导入导出）</h1><p><strong>材质的常用的着色模式</strong></p><ul><li>standard</li><li>mobile/diffuse(漫反射)</li></ul><p><strong>材质mobile/diffuse</strong></p><ul><li>Tiling 分别x、y铺多少块（会受到纹理Wrap Mode的影响 这个来决定图片怎么铺）</li><li>Offset 0,0左下角(开始铺) 1,1右上角</li></ul><p><strong>纹理</strong></p><ul><li>Wrap Mode 图片铺的样式（包装模式）<ul><li>Clamp 边缘填充（以边缘的像素进行填充）</li><li>Repeat 循环填充（用图片循环，平铺）</li></ul></li><li>Filter Mode 放大缩小时的插值模式 (Point)表示不用算法会造成放大后图片比较不清晰</li></ul><p><strong>FBX模型</strong></p><ul><li>模型顶点坐标</li><li>纹理坐标</li><li>模型动画(可以没有)</li></ul><p><strong>package导入导出</strong></p><ul><li>export导出</li><li>import导入</li></ul><h2 id="unity2017-3-0导入模型，模型无法修改材质问题"><a href="#unity2017-3-0导入模型，模型无法修改材质问题" class="headerlink" title="unity2017.3.0导入模型，模型无法修改材质问题"></a>unity2017.3.0导入模型，模型无法修改材质问题</h2><p>导入材质发现无法修改材质<br><img src="unity学习笔记/11_1.png" alt="图片暂时没有哦"></p><p>选择导入的模型 将 location 从 use embedded materials 改成 use external materials (legacy);<br><img src="unity学习笔记/11_2.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/11_3.png" alt="图片暂时没有哦"></p><p>修改之后再点击材质你就会发现材质可以修改了，然后按照对应的材质手动修改好就行了。</p><p>切断与原模型的联系，就算模型源文件删除了也不会影响场景里面的模型<br><img src="unity学习笔记/11_4.png" alt="图片暂时没有哦"></p><h1 id="第十二课（unity-Camera-摄像机详解）"><a href="#第十二课（unity-Camera-摄像机详解）" class="headerlink" title="第十二课（unity_Camera 摄像机详解）"></a>第十二课（unity_Camera 摄像机详解）</h1><ul><li><p>Clear Flage<br><strong>以什么什么为背景来绘制我们的场景</strong><br><img src="unity学习笔记/12_1.png" alt="图片暂时没有哦"></p></li><li><p>Culling Mask<br><strong>对哪一些物体是可见的</strong></p><ul><li>Everything <strong>所有可见</strong></li><li><p>Nothing <strong>所有不可见</strong></p><p>根据Layer来勾选是否能看见物体（如果一个物体的Layer为test时Culling Mask中没有对test勾选那么这个物体就是不可见的）</p></li></ul></li><li><p>Clipping Planes<br>摄像机能看到的最近距离和最远距离<br><img src="unity学习笔记/12_2.png" alt="图片暂时没有哦"></p></li><li><p>Viewport Rect 视口大小<br><img src="unity学习笔记/12_3.png" alt="图片暂时没有哦"></p></li><li><p>Depth<br>摄像机的绘制循序 <strong>大先绘制 小后绘制</strong></p></li><li><p>Target Display<br>可以接多个显示设备</p></li><li><p>Projection投射类型</p><ul><li>Perspective 透视投影算法 锥形（3D转2D 用相似三角形换算出投影过来的 近的宽，远的窄）<br>  <img src="unity学习笔记/12_4.png" alt="图片暂时没有哦"><ul><li>Field of View 视角大小    控制投影的大小</li></ul></li><li>Orthographic 平行投影 立方体<ul><li>Size 在纵向上一半的显示范围 可根据这个值和屏幕宽高比换算出真实宽高<blockquote><p>例如：size为5，屏幕宽高比为 5:4 那么他的宽就是 因为是纵向的一半所有需要乘2，高为(5 <em> 2) </em> 5 / 4 = 12.5（算出一个比例为多少 ）宽就是 5 * 12.5 = 62.5 （比例 5 : 4） 最后得到的宽高(62.5 : 50)</p></blockquote></li></ul></li></ul></li></ul><h2 id="绘制流水线"><a href="#绘制流水线" class="headerlink" title="绘制流水线"></a>绘制流水线</h2><ul><li>模型裁剪，剔除掉不在视椎的范围的物体（视椎裁剪）</li><li>世界坐标转为摄像机坐标</li><li>摄像机坐标转视口坐标 摄像机的3D坐标转为2D坐标 –&gt; 投影,成像 投影算法：正交投影(2D UI)，透视投影</li><li>视口坐标转屏幕坐标 </li></ul><h1 id="遮挡剔除-Occlusion-Culling-默认开启"><a href="#遮挡剔除-Occlusion-Culling-默认开启" class="headerlink" title="遮挡剔除 (Occlusion Culling) 默认开启"></a>遮挡剔除 (Occlusion Culling) 默认开启</h1><blockquote><p>先绘制远的物体再绘制进的物体 这样近的物体就会覆盖远的物体.<br>如果近的物体完全把远的物体挡住了，开启遮挡剔除就不会绘制后面的，如果关闭遮挡剔除那么后面虽然看不到，但是还是会绘制出来，开始有利于游戏性能<br><strong>都是以Mesh来确定是否来遮挡剔除</strong> 建模的时候就要注意区分节点，如果节点是一个那么就没法使用遮挡剔除</p></blockquote><h1 id="第十三课（unity-初识光源一）"><a href="#第十三课（unity-初识光源一）" class="headerlink" title="第十三课（unity_初识光源一）"></a>第十三课（unity_初识光源一）</h1><p>光三个因素</p><ul><li>颜色</li><li>范围</li><li>强度</li></ul><p>太阳光（平行光源）</p><ul><li>颜色 </li><li>范围（整个世界全局可见） </li><li>强度 所有强度一致的</li><li>生活参照：太阳</li></ul><p>灯泡（点光源）</p><ul><li>颜色 </li><li>范围 球体范围内进行衰减，距离越近强度越强</li><li>强度 从中心点开始，像四周减弱; </li><li>生活参照：普通的灯泡</li></ul><p>台灯或舞台（聚光灯）</p><ul><li>颜色 </li><li>范围 有特定的方向和范围, 像锥形;</li><li>强度 从中心轴开始，像四周减弱</li><li>生活参照：台灯、舞台灯、聚光灯</li></ul><p>光有颜色 255 255 255 白光<br>假如光的强度只有0.5的白光 128 128 128</p><blockquote><p>光的颜色 + 光的强度就 = 新的颜色 + 材质上的颜色做混合 = 全新的颜色</p></blockquote><h2 id="光属性"><a href="#光属性" class="headerlink" title="光属性"></a>光属性</h2><p>Render Mode</p><ul><li>auto 自动选择</li><li>important 质量更好 像素进行光照</li><li>not import 性能更好 顶点进行光照</li></ul><p>Cookie 使用一个带Alpha通道的纹理来制作一个遮罩，是光线在不同的地方有不同的强度</p><p>Intensity 光的强度<br>Draw Halo 光晕</p><ul><li><p>太阳光 Directional light</p><ul><li>Culling Mask和摄像机是一样的<blockquote><p>光照对哪一些层是有效的</p></blockquote></li></ul></li><li><p>点光 Point light<br>Range 光的半径（半径越大，光的衰减就越慢，也就越亮）</p></li><li><p>聚光灯 Spotlight<br>Range 椎体高<br>Spot Angle 锥角（越大范围越大，越小范围越小）</p></li></ul><h2 id="光源模式"><a href="#光源模式" class="headerlink" title="光源模式"></a>光源模式</h2><p>Baking/2017.3.0为(Mode):</p><ul><li>实时模式(Realtime)<blockquote><p>优点：光照实时计算出来，可以不断的变化<br>缺点：所有光照实时计算出来，消耗CPU</p></blockquote></li><li>烘焙模式(Baked)游戏静态物体，又需要阴影的可以用烘焙来达到更好的游戏性能<blockquote><p>优点：预先计算出来，性能好，烘焙出来之后去掉之前的光也会有光<br>缺点：不能够动态的改变（烘焙出来的影子，物体移动阴影不会发生改变）</p></blockquote></li></ul><p><strong>烘焙步骤</strong>:</p><ol><li>场景中的3D物体设置成静态光照的模式;<br><img src="unity学习笔记/13_1.png" alt="图片暂时没有哦"></li><li>烘焙的光源设置成Baked;<br><img src="unity学习笔记/13_2.png" alt="图片暂时没有哦"></li><li>打开Lighting窗口，在Scene Tab下点击Build;<br><img src="unity学习笔记/13_3.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/13_4.png" alt="图片暂时没有哦"></li></ol><ul><li>混合模式(Mixed) 对动态的物体使用实时光照，对静态的物体使用烘焙</li></ul><h1 id="第十四课（unity-UGUI-Canvas详解）"><a href="#第十四课（unity-UGUI-Canvas详解）" class="headerlink" title="第十四课（unity_UGUI_Canvas详解）"></a>第十四课（unity_UGUI_Canvas详解）</h1><p>做2D有三套UI</p><ul><li>自带的GUI</li><li>NGUI(广泛用来做2D界面 开源的第三方包) 需要安装<blockquote><p>unity5.x后 把NGUI作者找到 开发了UGUI</p></blockquote></li><li>UGUI 内置的</li></ul><p>3D世界显示2D元素</p><ol><li>使用正交摄像机</li><li>使用透视摄像机，将2D元素移动到合适的距离</li></ol><ul><li>像素换算米<blockquote><p>像素变成米然后后面再来计算,640<em>960 单位为100 最后得到6.4 </em> 9.6<br><img src="unity学习笔记/14_1.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/14_5.png" alt="图片暂时没有哦"></p></blockquote></li></ul><h2 id="2D元素充满屏幕-3D摄像机做2D"><a href="#2D元素充满屏幕-3D摄像机做2D" class="headerlink" title="2D元素充满屏幕(3D摄像机做2D)"></a>2D元素充满屏幕(3D摄像机做2D)</h2><p>计算正确的Z距离（zeye）</p><blockquote><p>tan(摄像机视角角度 <em> 0.5) = (h / 2) / zeye；<br>最佳Z值 zeye = h / (2 </em> tan(30))<br>Z / zeye = 最佳缩放比例</p></blockquote><ol><li>用z来设置，计算出最佳的z距离（Z得固定）<blockquote><p>tan(30) <em> 2 = 1.1547<br>假如分辨率为 h 640 </em> w 960 = h 6.4 * w 9.6<br>6.4 / 1.1547 = 5.54为最佳的z距离</p></blockquote></li></ol><blockquote><p>如果2D与3D共存，上面的Z固定了可能会造成遮挡的情况，所有用下面的可以解决此问题<br>不管Z为多少，用Z / 最佳z距离 即可得出2D元素的缩放比例，即可完成图片铺满全屏效果</p></blockquote><ol start="2"><li>使用缩放比例进行调整设置<blockquote><p>假如z = 10<br>z / 最佳z距离（5.54） = 合适的缩放比例（x 1.8, y 1.8）</p></blockquote></li></ol><p>UGUI 核心</p><ul><li>Canvas(做正确的显示的 做比例适配的)</li><li>控件（按钮等）</li><li>事件响应（自动创建EventSystem 接收事件）</li></ul><p>Canvas</p><ul><li><p>Render Mode </p><ul><li>Screen Space-Overlay 覆盖到屏幕的上方，就和电视的菜单一样都是在上方（没办法和3D共存）<blockquote><p>不支持UI组件image的材质球，显示不出来材质</p></blockquote></li><li><p>Screen Space-Camers 需要指定摄像机 不指定就和上面是一样的</p><ul><li>Plane Distance 决定2D界面和3D界面的的遮挡关系<blockquote><p>这个值小于3D的Z值就会挡住3D物体 大于3D就会显示3D物体</p></blockquote></li></ul></li><li><p>World Spance  </p><ul><li>2D和3D完全在一起（<strong>用自己上面的换算Z和缩放比例</strong>）</li><li>(这里的Z可决定2D和3D遮挡关系的Z了）和上面Plane Distance一样</li><li>Canvas先计算出最佳Z值填上去，遮挡关系要选好不要遮挡了不需要遮挡的物体</li><li>再用Z / 最佳Z = 缩放比例填上缩放比例即可这个是修改Canvas的</li><li>Canvas下面只需要修改像素为米的单位即可完成充满屏幕的匹配（640 <em> 960改为6.4 </em> 9.6）<br><img src="unity学习笔记/14_2.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/14_3.png" alt="图片暂时没有哦"></li></ul></li></ul></li><li>Pixel Perfect 勾选画质更好 更完美的填充像素（subpixel）</li></ul><p>Canvas Scaler 比例计算</p><p>Canvas Scaler and Screen Space-Camers</p><ul><li>UI Scale Mode<ul><li>Constant Pixel Size 图片有多大就只显示多大到窗口里面（不做任何缩放） 按像素来（显示窗口就要写死分辨率的）</li><li>Scale With Screen Size 按屏幕来缩放 一般用这个<ul><li>找好标准屏幕是多少<ul><li>Reference Resolution x 960 y 640 就会按照 960 * 640 来进行缩放<blockquote><p>只有同比例的缩放才会不影响大小</p></blockquote></li><li>假如我放在一个1920 <em> 1080的屏幕里面，得到比例由上面的960 </em> 640为比例缩放得到缩放比例，宽获取比例 1920 / 960 = 2,    高获取比例1080 / 640 = 1.6875</li><li>如果以高度来当缩放因子，宽度就会明显得不到填充完整，因为宽需要缩放2。</li><li>如果以宽度来当缩放因子，高度就会明显显示不完整（出界），因为高只需要1.6875。</li><li>用Match滑动条来决定到底是以宽(1)来做缩放因子，还是以高(1)来做缩放因子<br><img src="unity学习笔记/14_4.png" alt="图片暂时没有哦"></li><li>如果Mathch值为0.5那么就用(宽缩放因子 + 高缩放因子) / 2 = 一个差值，这个差值就是最终的缩放因子,<strong>一般我们不是用宽，就是用高来决定</strong>。<blockquote><p>选定大的因子来做缩放就会充满铺满但是小的那一方可能会显示不完整<br>选定小的因子来做缩放，就会有一方会充满不了屏幕</p></blockquote></li></ul></li></ul></li><li>Constant Physical Size 按物理尺寸比例比例来进行缩放，如果物理尺寸不一样就会拉大或缩小</li></ul></li></ul><p>Canvas Scaler and World Spance</p><ul><li>Canvas Scaler 没有作用</li></ul><h2 id="image组件"><a href="#image组件" class="headerlink" title="image组件"></a>image组件</h2><p>可用材质球制定纹理（Screen Space-Overlay不支持材质球）</p><ul><li>Raycast Target<blockquote><p>应该认为这是光线投射的目标吗(是否可以为射线的目标)</p></blockquote></li><li>Preserve Aspect<blockquote><p>保持图像现有尺寸（保持图片宽高比）</p></blockquote></li><li>Set Native Size<blockquote><p>将图片尺寸设置为纹理的原始像素大小<br>560 * 363最佳Z为3.14</p></blockquote></li></ul><h1 id="第十五课（unity-UGUI-RectTransform组件与UI屏幕适配）"><a href="#第十五课（unity-UGUI-RectTransform组件与UI屏幕适配）" class="headerlink" title="第十五课（unity_UGUI_RectTransform组件与UI屏幕适配）"></a>第十五课（unity_UGUI_RectTransform组件与UI屏幕适配）</h1><p><strong>常用分辨率</strong></p><ul><li>iphone5<ul><li>1136 * 640</li></ul></li><li>iphone4<ul><li>960 * 640</li></ul></li><li>iPad<ul><li>768 * 1024</li></ul></li><li>800 * 480</li><li>1920 * 1080</li><li>1080 * 1920</li></ul><p>Pivot</p><blockquote><p>中心点 左下为0,0 右上角1,1<br>中心点到锚点的距离</p></blockquote><p>Anchors</p><blockquote><p>左下为0,0 右上角1,1<br>相对于父节点位置的停靠点（百分比）,用来做适配用的</p></blockquote><p>Canvas</p><blockquote><p>与屏幕的大小一样</p></blockquote><p>UI界面的屏幕适配</p><ol><li>确定美术的设计分辨率<br><img src="unity学习笔记/15_1.png" alt="图片暂时没有哦"></li><li>UI界面Canvas节点的配置，设置Canvas参考分辨率</li><li>背景图要能确保充满所有的屏幕，重要的景物在主流屏幕分辨率下的公共区域</li><li>UI布局找准停靠点<blockquote><p>只需<strong>设置好父节点的停靠点</strong>（<strong>父物体一般大小设置为0</strong>,父节点就是用来做停靠点的），这样做适配就不用管子节点的位置，只需要把父节点的停靠点停好，那么<strong>子节点是相对于父节点</strong>停靠的，这样就很方便了。</p></blockquote></li></ol><h1 id="第十六课（Unity-UGUI-Image与Sprite-2D-and-UI-）"><a href="#第十六课（Unity-UGUI-Image与Sprite-2D-and-UI-）" class="headerlink" title="第十六课（Unity_UGUI_Image与Sprite(2D_and_UI)）"></a>第十六课（Unity_UGUI_Image与Sprite(2D_and_UI)）</h1><p>Filter Mode 纹理的缩放模式算法</p><p>Image Type 缩放模式</p><ul><li>simple<blockquote><p>图片缩放到目标大小</p></blockquote></li><li>tiled<blockquote><p>图片平铺填充到目标大小</p></blockquote></li><li>slice<blockquote><p>图片按照九宫格缩放（指定缩放区域，一些特殊的，不缩放的，比如QQ的气泡）</p></blockquote></li><li>Filled<blockquote><p>指定区域显示，垂直，水平，圆周（cd动画）</p><ul><li>Fill Method 显示的类型（圆周360）</li><li>Fill Origin 开始显示的方位 Botton Top Left Right</li><li>Fill Amount 图片显示的百分比 （0 - 1）</li><li>Clock wise 是否顺时针显示</li></ul></blockquote></li></ul><p>Sprite Edit 配合 slice这个使用</p><blockquote><p>精灵九宫格拉伸区域</p></blockquote><p>PackTag</p><blockquote><p>指定打包时候的标志，自动打包的标志，优化</p></blockquote><p>Pixels Per Unit</p><blockquote><p>以多少为一个unity单位(米) 默认100为1个单位</p></blockquote><h1 id="第十七课（Unity-UGUI-RawImage与Texture和Button）"><a href="#第十七课（Unity-UGUI-RawImage与Texture和Button）" class="headerlink" title="第十七课（Unity_UGUI_RawImage与Texture和Button）"></a>第十七课（Unity_UGUI_RawImage与Texture和Button）</h1><p>Texture</p><blockquote><p>会把贴图转为2^N次方</p><ul><li>用于显示图片的贴图（Texture/Sprite(2D and UI)）</li><li>Alpha from Grayscal<br>将灰度作为Alpha通道的值</li><li>WarpMode <ul><li>纹理寻址超过范围的填充模式<ul><li>Clamp（边缘填充）</li><li>Repeat（循环填充）</li></ul></li></ul></li></ul></blockquote><p>RawImage</p><ul><li>UV Rect 贴图纹理寻址</li><li>怎么贴<br><img src="unity学习笔记/17_1.png" alt="图片暂时没有哦"></li></ul><blockquote><p>RawImage于Image的区别，<strong>UV Rect贴图寻址</strong>可以做一些效果如：<strong>滚动的地图</strong>，其他没有什么这种需求建议使用Image</p></blockquote><p>RawImage于Image的区别</p><ol><li>Sprite只能用在Image组件上做2D and UI</li><li>Sprite可以做九宫格</li><li>Sprite一般用作小图，可以打Atlas（图集所有小图的集合） Packing Tag</li><li>Texture基于纹理寻址模式，不能打包Atlas</li><li>UI需要修改UV Rect和利用寻址模式的（滚动地图）,用Texture，否者用Sprite</li></ol><p>Button</p><p>Interactable 是否使用按钮</p><p>按钮的4种过度效果</p><ul><li>Transition 鼠标的过度效果<ul><li>None 没有任何效果</li><li>Color Tint 颜色过度</li><li>Sprite Swap 精灵过度</li><li>Animation 动画过度<blockquote><p>正常效果<br>划过效果<br>按下效果<br>禁用效果</p></blockquote></li></ul></li></ul><h1 id="第十八课（Unity-UGUI-Mask-布局-Text组件）"><a href="#第十八课（Unity-UGUI-Mask-布局-Text组件）" class="headerlink" title="第十八课（Unity_UGUI_Mask_布局_Text组件）"></a>第十八课（Unity_UGUI_Mask_布局_Text组件）</h1><p>Mask</p><ul><li>Rect Mask 2D 矩形mash<blockquote><ol><li>创建一个空节点，指定节点的大小用于裁剪</li></ol></blockquote></li></ul><ol start="2"><li>添加Rect Mask组件</li><li>把需要裁剪的图片放在这个组件下面，就会通过这个矩形区域被裁剪掉。<blockquote><p>Mask节点下面的孩子只能通过mash区域可见,其他区域会被参见，只能在这个矩形区域内可见</p></blockquote></li></ol><ul><li>Mask（很像蒙版）<blockquote><ol><li>创建Mash图片创建Image对象（这个图片要是<strong>不透明的</strong>，比如一个圆形头像）</li></ol></blockquote></li></ul><ol start="2"><li>在这个节点上加入Mask组件</li><li>将图像加入到这个Image孩子节点下（即可通过这个圆形头像看到圆形区域子节点的图像）</li><li>加入的孩子节点只能通过不透明区域看到<blockquote><p>在这个节点下面的孩子只能通过不透明的区域看到<br>有毛边的话可以用一个头像外边框</p></blockquote></li></ol><p>Vertical Layout Group 组件</p><blockquote><p>垂直布局 自动把很多个元素，垂直进行布局，不用我们去手动操作</p><ul><li>Spacing<br>每个元素之间的间隔</li><li>Padding<br>排版是从哪儿开始的，距离起点的距离</li><li>Child Alignment<br>怎么布局</li><li>Child Force Expand<br>width和height可防止父节点大小过大时会把图片拉伸，去掉勾即可</li></ul></blockquote><p>Horizontal Layout Group 组件</p><blockquote><p>水平布局 自动把很多个元素，垂直进行布局，不用我们去手动操作</p><ul><li>Spacing<br>每个元素之间的间隔</li><li>Padding 局部边缘填充<br>排版是从哪儿开始的，距离起点的距离</li><li>Child Alignment<br>孩子排版的方式</li><li>Child Force Expand 自适应宽高度<br>width和height可防止父节点大小过大时会把图片拉伸，去掉勾即可</li></ul></blockquote><p>Grid Layout Group 组件</p><ul><li>Cell Size<blockquote><p>每一个的大小</p></blockquote></li><li>Spacing<blockquote><p>之间的间隔</p></blockquote></li><li>Start Corner 第一个元素的位置<blockquote><p>从哪儿开始排的</p></blockquote></li><li>Start Axis<blockquote><p>垂直还是水平</p></blockquote></li><li>Constarint <ul><li>Fiexible </li><li>Fixed Column Count 固定列数</li><li>Fixed Row Count 固定行数</li></ul></li></ul><p>Text 组件</p><p>1：Text 显示的文本<br>2: Font 使用的文字的字体;<br>3: FontStyle: 文字字体样式;<br>4: LineSpacing: 行间距; 只对垂直溢出有效<br>5: Alignment: 对齐方式;<br>7: Horizontal 水平溢出;<br>8: Vertical 垂直溢出;<br>9: RichText 多格式文本 \&lt;color=blue&gt;&lt;\/color&gt;</p><ul><li>Best Fit 最佳匹配方式<ul><li>Min 字体最小能被缩小到多小</li><li>Max 字体最大能被放大到多大</li></ul></li></ul><h1 id="第十九课（Unity-UGUI-Solider-Toggle-InputTextfiled组件）"><a href="#第十九课（Unity-UGUI-Solider-Toggle-InputTextfiled组件）" class="headerlink" title="第十九课（Unity_UGUI_Solider_Toggle_InputTextfiled组件）"></a>第十九课（Unity_UGUI_Solider_Toggle_InputTextfiled组件）</h1><p>Slider<br>1: 修改滑动条背景色 –&gt; Background,指定图片或颜色;<br>2: 修改滑动条进度的颜色–&gt;Fill Area–&gt;Fill 指定图片或颜色;<br>3: 修改滑动点与按钮一样:  颜色/图片/动画/过度效果<br>3: 滑动的值被改变: 抛出on value Change事件;<br>4: 获得当前滑动条的进度值[0, 1],</p><blockquote><p>可以修改这个值[min, max];</p></blockquote><p>Toggle<br>1: 勾选框背景–&gt;Background   颜色或图片;<br>2: –&gt;Background–&gt;Checkmark 勾选框 颜色或图片;<br>3: 组件节点的RectTransform 大小是响应时间的范围;<br>4: 获得勾选框的值isOn;<br>5:Toggle 勾选过度 渐变/None;<br>6: 每次修改，抛出on value change事件;</p><p>InputField<br>Selection Color 选中文本时的颜色<br>Read Only 勾选表示该内容无法被修改</p><h1 id="第二十课（Unity-Recttransform-stretch-预制体-ScrollView）"><a href="#第二十课（Unity-Recttransform-stretch-预制体-ScrollView）" class="headerlink" title="第二十课（Unity_Recttransform_stretch_预制体_ScrollView）"></a>第二十课（Unity_Recttransform_stretch_预制体_ScrollView）</h1><p>更新数据</p><ul><li>预制体数据同步到物体用 Revert</li><li>物体数据同步到预制体用 Apply</li></ul><h1 id="第二十一课（Unity-Input输入详解）"><a href="#第二十一课（Unity-Input输入详解）" class="headerlink" title="第二十一课（Unity_Input输入详解）"></a>第二十一课（Unity_Input输入详解）</h1><blockquote><p>监听Input事件都是在Update里面监听</p></blockquote><ul><li>Input.mousePosition<blockquote><p>监听当前鼠标位置（以屏幕左下角为原点）</p></blockquote></li><li>Input.anyKey<blockquote><p>持续啊亲下，直到弹起（可以是键盘也可以是鼠标）</p></blockquote></li><li>Input.anyKeyDown 当前按下<blockquote><p>当前按下</p></blockquote></li><li>Input.inputString<blockquote><p>返回输入的assic字符</p></blockquote></li><li>Input.acceleration<blockquote><p>如果没有重力传感器，那么就是返回的（0,0,0）返回重力加速度传感器的值，加速度的方向</p></blockquote></li><li>touches<blockquote><p>返回当前触摸事件</p></blockquote></li></ul><h2 id="获取虚拟轴的值"><a href="#获取虚拟轴的值" class="headerlink" title="获取虚拟轴的值"></a>获取虚拟轴的值</h2><ul><li>Input.GetAxis（0 - 1有差值）/Input.GetAxisRaw（0 - 1没有差值）返回虚拟轴的值<blockquote><p>Eidt –&gt; ProjectSetting –&gt; Input<br>Input.GetAxis(“Horizontal”)<br>水平虚拟轴</p></blockquote></li></ul><p>GetAxis(“Mouse X”)<br>GetAxis(“Mouse Y”)</p><blockquote><p>距离上一次鼠标的变化 dx dy</p></blockquote><h2 id="虚拟按键-判断按键有没有按下"><a href="#虚拟按键-判断按键有没有按下" class="headerlink" title="虚拟按键 判断按键有没有按下"></a>虚拟按键 判断按键有没有按下</h2><ul><li>Input.GetButton(“Firel”)<blockquote><p>持续按下，Firel鼠标左键</p></blockquote></li><li>Input.GetButtonDown(“Firel”)<blockquote><p>当前按下</p></blockquote></li><li><p>Input.GetButtonUp(“Firel”)</p><blockquote><p>当前弹起</p></blockquote></li><li><p>Input.GetKey()</p><blockquote><p>持续按下</p></blockquote></li><li>Input.GetKeyDown()<blockquote><p>当前按下</p></blockquote></li><li>Input.GetKeyUp()<blockquote><p>当前弹起</p></blockquote></li><li>KeyCode.xx<blockquote><p>键盘上的按键</p></blockquote></li></ul><h2 id="判断鼠标有没有按下"><a href="#判断鼠标有没有按下" class="headerlink" title="判断鼠标有没有按下"></a>判断鼠标有没有按下</h2><p>Input.GetMouseButtonDown(0 1 2)左键 右键 中键<br>鼠标当前按下<br>Input.GetMouseButtonUp(0 1 2)左键 右键 中键<br>鼠标当前抬起<br>Input.GetMouseButton(0 1 2)左键 右键 中键<br>鼠标持续按下</p><p>GetTouche() 返回当前触控Touch对象</p><h2 id="Input-Manager参数"><a href="#Input-Manager参数" class="headerlink" title="Input Manager参数"></a>Input Manager参数</h2><p>1: Name: 轴的名字;<br>2: Descriptive: 正向方向描述;<br>3:  Button:正向反向按钮和附加按钮;<br>4: Gravity:复位的速度，用于按键和鼠标；<br>5: Dead: 小于该值的输入值, 都会被视为0，用于摇杆。<br>6: Sensitivity(灵敏度): 对于键盘输入，该值越大则响应时间越快，该值越小则越平滑。对于鼠标输入，设置该值会对鼠标的实际移动距离按比例缩放<br>7: Snap对齐: 如果启用该设置，当轴收到反向的输入信号时，轴的数值会立即置为0，仅用于键/鼠标 输入。<br>8:Invert 反转: 启用该参数可以让正向按钮发送负值，反向按钮发送正值。<br>9:Type 类型: 所有的按钮输入都应设置为 键/鼠标 (Key / Mouse) 类型，对于鼠标移动和滚轮应设为 鼠标移动(Mouse Movement)。摇杆设为摇杆轴 (Joystick Axis)，用户移动窗口设为窗口移动 （Window Movement）。<br>10:Axis 轴: 设备的输入轴（摇杆，鼠标，手柄等）<br>11:Joy Num 摇杆编号: 设置使用哪个摇杆。默认是接收所有摇杆的输入。仅用于输入轴和非按键。 </p><ul><li>Touch</li></ul><p>1:fingerID; 手指ID<br>2: position  手指位置<br>3: deltaPosition 距离上一次的偏移;<br>4: phase: 触摸相位TouchPhase.Began Moved, cancel, ended;<br>5: Touch事件同时会触发 GetMouseButton(0)事件,能够使用<br>Input.GetAxis(“Mouse X/Y”)获取触摸偏移位置;<br>6: 到底用Touch还是用Mouse,如果对触摸的准确性要求不高，可以使用Mouse,否则还是区别对待，使用Touch，如果要多点触控，那么自己判断，直接自己使用Touch</p><ul><li>Input.Touch<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//只有移动设备有这个touch</span><br><span class="line">if (Input.touchCount &gt; 0) &#123;</span><br><span class="line">    Touch t = Input.GetTouch(0);</span><br><span class="line">    // t.position; //触摸的位置;</span><br><span class="line">    // t.deltaPosition; // 距离上一次,位置的偏移</span><br><span class="line">    // t.phase // 触摸的相位，--&gt;状态， 按下，滑动，弹起,cancel;</span><br><span class="line">    // Touch,只在移动设备上能用，所以统一，鼠标和这个Touch,</span><br><span class="line">    // Touch同时也会发送一个 鼠标左键的事件,模拟一次鼠标左键;</span><br><span class="line">    // GetMouseButton(0), 鼠标，和触摸都可以当作鼠标事件来处理，那么</span><br><span class="line">    // 我们的代码就只要写一次。单点触摸的时候。</span><br><span class="line">    // 多点触摸,自己处理Touch事件。</span><br><span class="line"></span><br><span class="line">    // 单点触控</span><br><span class="line">    // t.position, --&gt; mousePostion;</span><br><span class="line">    // t.deltaPosition --&gt; Input.GetAxis(&quot;Mouse X/Y&quot;);</span><br><span class="line">    // Begin(Down 当前按下), ended(Up 当前抬起), moved(Button 持续按下)</span><br><span class="line">    // end </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第二十二课（Unity-帧动画播放组件）"><a href="#第二十二课（Unity-帧动画播放组件）" class="headerlink" title="第二十二课（Unity_帧动画播放组件）"></a>第二十二课（Unity_帧动画播放组件）</h1><p><strong>帧动画基本介绍</strong></p><ul><li>美术准备好一个连续动作的离散图片</li><li>程序在准确的时间来切换这个图片</li><li>优点<ul><li>简单、速度快</li></ul></li><li>缺点<ul><li>资源占用相对过大</li></ul></li></ul><blockquote><p>代码控制image组件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前代码强制要求要加入一个Image组件</span><br><span class="line">// 如果没有Image，就会自动加上。如果有就使用</span><br><span class="line">// 在MonoBehaviour外面定义</span><br><span class="line">[RequireComponent(typeof(Image))]</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果代码要求这个节点会依赖某一个（必须）组件<code>[RequireComponent(typeof(Image))]</code>可以加上这句话，如果你忘记添加该组件，不用担心这句代码会自动给你加上该组件，如果已有组件那么就使用这个组件，不会造成冲突，很实用</strong></p></blockquote><blockquote><p>该播放第几张图片 = （向下取整）（经过总时间 / 图片切换间隔时间）</p></blockquote><p><strong>如果需要循环播放，直接用（把数值调整为初始化状态）</strong></p><blockquote><p>如果直接赋值为初始化可能会造成动画不流畅,所以这里用了减法，把之前叠加的数据都减去即可</p><ul><li>经过总时间 -= (切换间隔 * 总图片张数)</li><li>图片索引 -= 总图片张数</li></ul></blockquote><h1 id="第二十三课（Unity定时器事件委托节点操作）"><a href="#第二十三课（Unity定时器事件委托节点操作）" class="headerlink" title="第二十三课（Unity定时器事件委托节点操作）"></a>第二十三课（Unity定时器<em>事件委托</em>节点操作）</h1><ul><li><p>定时器 （不支持参数）</p><ul><li><p>一次性定时器</p><ul><li>Invoke(“function_name”,time);<blockquote><p>多少秒后调用，只会调用一次</p></blockquote></li></ul></li><li><p>循环定时器</p><ul><li>InvokeRepeating(“function_name”,time, t);<blockquote><p>time秒之后开始调用，每隔t秒调用一次</p></blockquote></li><li>CancelInvoke(“function_name”);<blockquote><p>取消一个循环定时器</p></blockquote></li></ul></li></ul></li><li><p>委托</p><blockquote><p>和订阅号一样，如果订阅号新发布了文章，那么就会推送给，每一个订阅了他的人<br>订阅号发布文章 – &gt; 订阅号告诉订阅中心（委托） –&gt; 然后订阅中心 –&gt; 向已经订阅了的人推送这篇文章</p></blockquote></li></ul><p>我们触发这个事件，我们只需要告诉委托就好了，并不需要知道，多少人需要这个事件，我们告诉委托有这个事件之后，那么他就会把这个事件推送给需要的人。</p><p>触发者：不需要关心多少人在监听（不需要关系多少人在等我们的文章，我们只需要把写好的文章发布出来，就会通知委托，然后委托把这个文章（事件）推送给需要的监听者，监听者自然也就监听到了自己感兴趣的文章（事件））<br>监听者：不需要关心触发者是谁，何时会发送，谁会发送，如果我们监听感兴趣的东西有了，那么就自动会收到新来的文章（就能调用得到相关事件的函数，我们只会对自己感兴趣的来进行处理）</p><blockquote><p>监听者不需要管触发者，只要是自己感兴趣的触发者，自然他发的东西，监听就会自动获取得到。</p></blockquote><p>监听者：设置需要委托的函数，告诉委托，有这个事件触发了，请你调用我这个函数。<br>委托者：当有这个事件触发以后，委托者就会调用，每一个监听者委托的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个委托类型，定义这个委托能委托什么样的函数</span><br><span class="line">public delegate void EventHandler(string name, int age);</span><br><span class="line"></span><br><span class="line">// 定义一个委托实例的引用变量</span><br><span class="line">public EventHandler e;</span><br><span class="line"></span><br><span class="line">// public event EventHandler e; event修饰的委托只能是实例内部触发</span><br><span class="line"></span><br><span class="line">// 实例化委托实例 一般不这样写 原理是这样的 下面 用 e = a 方便一些</span><br><span class="line">// e = new EventHandler(a);</span><br><span class="line"></span><br><span class="line">// 下面是隐式创建了委托实例和这个一样 e = new EventHandler(a);</span><br><span class="line">e = a</span><br><span class="line">// e = a + b</span><br><span class="line">// e = a + b - a</span><br><span class="line">// e += a;</span><br><span class="line"></span><br><span class="line">//委托可用 + - += -= 来增加或减少委托函数</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">需要委托的函数 参数需要和 定义委托类型一样 string name, int age</span><br><span class="line">例如</span><br><span class="line"></span><br><span class="line">这个函数就是监听者，准备要委托的函数</span><br><span class="line">void a(string name, int age)&#123;</span><br><span class="line">    Debug.Log(&quot;a&quot; + name + age);</span><br><span class="line">    // 委托函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个函数就是监听者，准备要委托的函数</span><br><span class="line">void b(string name, int age)&#123;</span><br><span class="line">    Debug.Log(&quot;a&quot; + name + age);</span><br><span class="line">    // 委托函数</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 触发者</span><br><span class="line">// 触发委托，就会调用相对应委托的函数</span><br><span class="line">e(&quot;小明&quot;, 10); //打印 小明10</span><br><span class="line"></span><br><span class="line">// 委托可跨脚本 只要委托函数参数是委托类型的那么就可以委托</span><br><span class="line">// 当触发的时候，就会调用这个委托函数</span><br><span class="line"></span><br><span class="line">// 跨脚本也可以触发委托事件，因为获得了脚本对象的那个委托</span><br><span class="line">// 如果有个需求，就是我在外部能添加委托，但是我无法触发委托呢？ 在委托前面加 event</span><br><span class="line">// event 修饰的委托，就只能是在它的成员函数里面触发，达到了上面的需求</span><br></pre></td></tr></table></figure><ul><li><p>系统封装的委托类</p><blockquote><p>System 命名空间下<br>Action</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Action e; // 没有参数的委托</span><br><span class="line">public Action&lt;string&gt; e //模板委托 最多4个参数模板 多于4个就自己定也可以</span><br><span class="line">// public delegate void EventHandler(xxx);</span><br><span class="line"></span><br><span class="line">// 一般用法 </span><br><span class="line">// public 外部能加入委托</span><br><span class="line">// event 外部只能添加不能触发委托，委托只能由内部触发</span><br><span class="line">public event Action&lt;int&gt; action = null;</span><br><span class="line"></span><br><span class="line">// 添加委托函数</span><br><span class="line">action += b;</span><br><span class="line">void b(int num)&#123;</span><br><span class="line">    Debug.Log(&quot;num = &quot; + num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触发 action</span><br><span class="line">if(this.action != null)&#123;</span><br><span class="line">    //触发委托</span><br><span class="line">    this.action(10); // 打印 num = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>删除节点/删除组件</p><ul><li>删除自己所在的节点,节点上所有组件全部删除<br>MonoBehaviour.Destroy(this.gameObject);</li><li>删除组件(删除别的节点 先获取再删除)<br>MonoBehaviour.Destroy(this.Getponent<image>().gameObject);</image></li><li>删除组件(删除自己)<br>MonoBehaviour.Destroy(this);</li><li>删除组件(删除别的组件上面的组件 先获取再删除)<br>MonoBehaviour.Destroy(this.Getponent<image>());<blockquote><p>删除节点的时候会把挂载的所有组件都删除</p></blockquote></image></li></ul></li></ul><p>上面的删除会调用<code>OnDestroy</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 一般在OnDestroy里面删除委托</span><br><span class="line">void OnDestroy()&#123;</span><br><span class="line">    // 监听了委托删除组件的时候记得删除相应的委托</span><br><span class="line">    // -= 即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>隐藏自己/禁用节点</p><blockquote><p><code>this.gameObject.SetActive(false)</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// （禁用节点）隐藏节点时调用</span><br><span class="line">// 禁用节点之后节点的事件函数也不会执行 除非是用定时器之前定的才会执行调用</span><br><span class="line">void OnDisable()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>显示自己/激活节点</p><blockquote><p><code>this.gameObject.SetActive(true)</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// （激活节点）显示节点时调用</span><br><span class="line">void OnEnabal()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="第二十四课（Unity-BmpFont的使用和第一个编辑器扩展功能）"><a href="#第二十四课（Unity-BmpFont的使用和第一个编辑器扩展功能）" class="headerlink" title="第二十四课（Unity_BmpFont的使用和第一个编辑器扩展功能）"></a>第二十四课（Unity_BmpFont的使用和第一个编辑器扩展功能）</h1><blockquote><p>BmpFont制作工具：GlyphDesigner(Mac系统)</p><ul><li>GlyphDesigner(Mac系统)<ul><li>导入字库</li><li>调整好想要的大小和颜色</li><li>导出即可得到<em>.fnt和对应的</em>.png</li></ul></li></ul></blockquote><ul><li>字库<ul><li>系统字库<blockquote><p>优点：省空间<br>缺点：效果中规中矩，无法做特定文字</p></blockquote></li><li>自定义字库(无线字符个数)<blockquote><p>优点：样式自定义、灵活<br>缺点：unity需要携带字库文件，占用太大空间</p></blockquote></li><li>BmpFont（位图文字 有限的字符个数）<blockquote><p>优点：速度快，占用空间小（因为是有限的）<br>能做出特殊效果的文字<br>缺点：也正因为有限所有成了他的缺点</p></blockquote></li></ul></li></ul><h2 id="手动计算字模"><a href="#手动计算字模" class="headerlink" title="手动计算字模"></a>手动计算字模</h2><p>BmpFont 有个图片<em>.png 有个文件</em>.fnt（）</p><ul><li>先创建 一个字库（命名和*.fnt文件一样）<br><img src="unity学习笔记/24_1.png" alt="图片暂时没有哦"></li><li>创建字体库 材质球（命名和*.fnt文件一样）<br><img src="unity学习笔记/24_2.png" alt="图片暂时没有哦"><blockquote><p>再拖上对应需要使用的png文件</p></blockquote></li><li>使用材质球<br><img src="unity学习笔记/24_3.png" alt="图片暂时没有哦"></li><li>设置字体需要使用的数量<br><img src="unity学习笔记/24_4.png" alt="图片暂时没有哦"></li><li>填写UV等参数<br><img src="unity学习笔记/24_5.png" alt="图片暂时没有哦"><blockquote><p>例如<br>char id=52 x=2 y=2 width=25 height=33 xoffset=0 yoffset=0 xadvance=20 page=0 chnl=0 letter=”4”<br><strong>UV公式<br>X = x / 贴图宽(2/128 = 0.015625) ； Y = 1 - y / 贴图高(1- 2/128 = 0.984375)<br>W = width / 贴图宽(25/128 = 0.1953125) ； H = -1 <em> height / 贴图高 (-33/128 = -0.2578125)<br>Vert<br>X = xoffset (0) ; Y = yoffset (-0.5 </em> height)<br>W = width(25) ； H = height(33)       advance = xadvance (20)；</strong><br><img src="unity学习笔记/24_6.png" alt="图片暂时没有哦"></p></blockquote></li></ul><h2 id="扩展编辑器自动计算字摸（字体模型库）"><a href="#扩展编辑器自动计算字摸（字体模型库）" class="headerlink" title="扩展编辑器自动计算字摸（字体模型库）"></a>扩展编辑器自动计算字摸（字体模型库）</h2><p>创建文件</p><ul><li><p>Editor（扩展编辑器代码名字一定不能错）</p><blockquote><p>Editor里面的代码不会混合项目代码<br>  用来扩展我们的编辑器<br>  一定要是Editor（这里面的代码都表示是扩展编辑器用的，而不是实际项目中用的）</p></blockquote></li><li><p>加入扩展编辑器的脚本<code>CreateFontEditor.cs</code></p></li><li><p>打开vs2017可以发现多了个带Editor的项目<br>  <img src="unity学习笔记/24_7.png" alt="图片暂时没有哦"></p></li><li>入口菜单（点菜单就会调用 CreateFont）<blockquote><p>没有那个路径会生成一个新的菜单路径<br>  <img src="unity学习笔记/24_8.png" alt="图片暂时没有哦"></p></blockquote></li><li>就可以使用插件进行自动计算了<ul><li><img src="unity学习笔记/24_9.png" alt="图片暂时没有哦"></li><li><img src="unity学习笔记/24_10.png" alt="图片暂时没有哦"></li></ul></li></ul><h1 id="第二十五课（Unity物理引擎的使用-一-）"><a href="#第二十五课（Unity物理引擎的使用-一-）" class="headerlink" title="第二十五课（Unity物理引擎的使用(一)）"></a>第二十五课（Unity物理引擎的使用(一)）</h1><blockquote><p>Unity2D物理引擎基于Box2D封装而成</p></blockquote><ul><li><p>刚体</p><blockquote><p>控制物体运动和受力</p><ul><li>刚体的物理参数设置:<ul><li>UseAutoMass/Mass:刚体质量,根据密度*面积计算出来</li><li>Linear Drag: 线性阻尼(阻力);</li><li>Angular Drag: 旋转阻尼;</li><li>Gravity Scale: 重力缩放因子（重力）;</li><li>is Kinematic: 静态刚体和动态刚体（是否为静态刚体，静态不动的刚体）;</li><li>Sleep 模式: 刚体休眠模式，没有参与受力就会休眠，也可以设置永久不休眠;</li><li>collistionDetectionMode: 刚体碰撞检测的模式(连续/分离)<ul><li>discrete（分离）</li><li>Continuous（连续）一般用于速度很快的物体，一般用于子弹检查</li></ul></li><li>Constraints<ul><li>Freeze Position（X Y） 这个为true则刚体不能进行移动，锁轴</li><li>Freeze Rotation 这个为true 刚体则不能旋转</li></ul></li></ul></li></ul></blockquote></li><li><p>碰撞器</p><blockquote><p>是物体的形状 + 碰撞的物理参数（物理材质、摩擦力、弹力）</p><ul><li>碰撞器的物理参数设置: <ul><li>Is Trigger 触发器 勾选表示物体是一个虚体，只会触发相应事件，不会发生物理运动</li></ul></li><li>矩形碰撞器</li><li>圆形碰撞器（Edge）</li><li>边界碰撞器（Circle）</li><li>多边形碰撞器（Polygon）</li></ul></blockquote></li></ul><h1 id="第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑-Camera跟随玩家）"><a href="#第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑-Camera跟随玩家）" class="headerlink" title="第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑_Camera跟随玩家）"></a>第二十六课（Unity刚体组件<em>键盘控制人物跑动跳跃</em>物理地形编辑_Camera跟随玩家）</h1><h1 id="第二十七课（Unity碰撞管理与碰撞检测）"><a href="#第二十七课（Unity碰撞管理与碰撞检测）" class="headerlink" title="第二十七课（Unity碰撞管理与碰撞检测）"></a>第二十七课（Unity碰撞管理与碰撞检测）</h1><ul><li>物理引擎设置<ul><li><img src="unity学习笔记/27_1.png" alt="图片暂时没有哦"></li><li><img src="unity学习笔记/27_2.png" alt="图片暂时没有哦"></li></ul></li></ul><h2 id="物体碰撞器"><a href="#物体碰撞器" class="headerlink" title="物体碰撞器"></a>物体碰撞器</h2><p>节点碰撞发生的时候</p><blockquote><p>它会去查询所有组件里面有没有对应的事件函数，如果有就调用这个节点上挂载事件函数</p></blockquote><ul><li>碰撞开始事件<br>void OnCollisionEnter2D(Collision2D c){}<blockquote><p>Collision2D 碰撞信息<br>  c.gameObject 获取与我们碰撞的节点</p></blockquote></li><li>碰撞结束事件<br>void OnCollisionExit2D(Collision2D c){}</li><li>碰撞持续事件<br>void OnCollisionStay2D(Collision2D c){}</li></ul><p>##　物体触发器</p><ul><li>开始触发<br>void OnTriggerEnter2D(Collider2D c)<blockquote><p>Collider2D 碰撞信息<br>  c.gameObject 获取与我们碰撞的节点</p></blockquote></li><li>结束触发<br>void OnTriggerExit2D(Collider2D c)</li><li>持续触发<br>void OnTriggerStay2D(Collider2D c)</li></ul><h1 id="（二十八-amp-二十九）一个2D项目（飞机大战）"><a href="#（二十八-amp-二十九）一个2D项目（飞机大战）" class="headerlink" title="（二十八&amp;二十九）一个2D项目（飞机大战）"></a>（二十八&amp;二十九）一个2D项目（飞机大战）</h1><ul><li>Screen.height（逻辑宽度，显示的高度）</li><li>如果是设置的640 * 960<blockquote><p><img src="unity学习笔记/28_1.png" alt="图片暂时没有哦"></p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Canvas设置的是 设计宽高</span><br><span class="line">// Game视图的是 逻辑宽高</span><br><span class="line">// Screen获取的就是 逻辑宽高</span><br><span class="line">// 因为屏幕适配的问题（如果设计宽高和逻辑宽高不一样，那么就需要适配一下，再来获取屏幕高度了，不然会导致对应不上） 640.0f / Screen.width = 得到缩放因子 宽度比例</span><br><span class="line">// 真正的高度等于 Screen.height * 得到的缩放因子 宽度比例</span><br><span class="line">// SetParent(this.bullet_root, 是否使用世界) 这个函数后面使用false 不然可能会出现大小或位置不对 用局部</span><br></pre></td></tr></table></figure><h2 id="RequireComponent-typeof-Componentname"><a href="#RequireComponent-typeof-Componentname" class="headerlink" title="[RequireComponent(typeof(Componentname))]"></a>[RequireComponent(typeof(Componentname))]</h2><blockquote><p><strong>写好之后重新挂载到脚本才会去生成组件，如果先挂载脚本到实例，写了这个代码的话，他也不会自动帮你生成对应的组件，这点要注意。先写代码，再挂实例！</strong></p></blockquote><blockquote><p>如果预制体制作需要重复工作且每一个不一样，可用<code>Break Prefab Instance</code>暂时切断他们的联系然后重命名再加上新的元素即可</p></blockquote><h1 id="第030课（Unity3D物理引擎-一-刚体碰撞器材质）"><a href="#第030课（Unity3D物理引擎-一-刚体碰撞器材质）" class="headerlink" title="第030课（Unity3D物理引擎(一)刚体碰撞器材质）"></a>第030课（Unity3D物理引擎(一)刚体碰撞器材质）</h1><ul><li><p>刚体</p><ul><li>Mass 质量</li><li>Drag 阻力</li><li>Angular Drag 旋转阻力</li><li>Use Gravity 是否受重力影响 true 不受重力影响</li><li>Is kinematic (是否受牛顿运动学影响): false,正常的物理计算，true运动只会在代码和动画里面受影响，普通的碰撞等都不会改变它的运动状态;</li><li>Interpotate: (物体运动插值模式)<br>None(最近计算值)  Interpolate(内插值) extrapolate(外插值)</li><li>Collision Detection<ul><li>Discrete(离散模式 资源少,静止,低速) </li><li>Continuous(连续检测，高速体积小)</li><li>Continus Dynamic（动态连续物体）被使用了Continusous检测撞击的对象，使用Continus Dynamic模式;<blockquote><p>如果子弹使用了连续监测，那么子弹撞击的那面墙就是使用<code>Continus Dynamic</code>这个离散模式</p></blockquote></li></ul></li><li><p>Constraints 锁轴</p></li><li><p>常用参数</p><ul><li>角速度(angularVelocity);</li><li>线性速度(velocity);</li><li>重心(center of mass)</li><li>碰撞检测开关(detectCollisions): 默认为true, 关闭检测碰撞 false;<blockquote><p>把物理形状的盒子全部关闭也是可以达到上面的效果，因为只要关闭就不会发生物理碰撞了</p></blockquote></li><li>intertiaTensor惯性张量 intertiaTensorRotation 惯性张量旋转;</li><li>最大角速度(maxAngularVelocity);</li><li>最大穿透速度(maxDepenetrationVelocity)</li><li>position: 刚体的世界坐标,与图像的transform.position尽量保持一致;<blockquote><p>物体也有个position 大致相等，刚体带动物体进行移动<br>  刚体先有position带动物体(并不完全一样，有微小的差异)</p></blockquote></li><li>rotation: 刚体在世界坐标的旋转;</li><li>useConeFiction是否使用锥形摩擦,一般false; true一般不使用;</li><li>mass 质量</li></ul></li><li>常用方法<ul><li>AddForce 给刚体一个力,方向是世界坐标</li><li>ForceMode 类型: t（即0.02s 系统指定）</li><li>f•t=m•v (force)   f•t=1.0•v (Acceleration)  </li><li>f•1.0=m•v(Impulse)  f•1.0=1.0•v(VelocityChange)</li><li>AddForceAtPosition postion是世界体系坐标，确保坐标在物体内;</li><li>AddRelativeForce力方向 相对于物体坐标</li><li>MovePosition/MoveRotation 调整刚体到指定的位置/旋转</li><li>AddTorque/AddRelativeToque: 施加一个力矩(相对力矩);</li><li>设置密度SetDensticy,体积是碰撞器体积;</li><li>Sleep: 强制刚体休眠; Wakeup 唤醒刚体;</li><li>SweepTest/SweepTestAll 扫描检测，返回射线碰撞到的刚体; </li></ul></li></ul></li></ul><h2 id="AddForce（世界坐标方向的力）"><a href="#AddForce（世界坐标方向的力）" class="headerlink" title="AddForce（世界坐标方向的力）"></a>AddForce（世界坐标方向的力）</h2><blockquote><p>AddForce(力的方向 <em> 力的大小(质量 </em> xxx)，力的模式(ForceMode))</p><ul><li>Force力计算模式 力会持续0.02s<br><strong>用刚体的质量给它加一个连续的力。时间0.02f</strong><br>力 f<br>持续时间 t = 0.02f<br>质量 m<br>初速度 v0<br>作用力 v1<br>f <em> t = m </em> (v1 - v0)<br>力跟质量有关系 一般用这个</li></ul></blockquote><ul><li><p>Acceleration 力计算模式 力会持续0.02s</p><blockquote><p><strong>把一个连续的加速度加到刚体上，忽略它的质量。时间0.02f</strong><br>持续时间 t = 0.02<br>m 质量 不会受质量的影响 质量为1.0f<br>f <em> t(1.0f) = m(1.0f) </em> (v1 - v0)</p></blockquote></li><li><p>Impulse力计算模式 力会持续1s</p><blockquote><p><strong>利用刚体的质量，给它加上一个瞬间的力脉冲。时间1.0f</strong><br>持续时间 t = 1.0f<br>f <em> t = m </em> (v1 - v0)</p></blockquote></li><li><p>VelocityChange 力计算模式 力会持续1s</p><blockquote><p><strong>向刚体添加瞬时速度变化，忽略其质量时间1.0f</strong><br>持续时间 t = 1.0f<br>m = 1.0f<br>f <em> t(1.0f) = m(1.0f) </em> v(VelocityChange)<br>它这个力只会和速度有关系</p></blockquote></li></ul><p>##　AddForceAtPosition（世界坐标方向的力）</p><blockquote><p><strong>默认给力到重心</strong><br>AddForceAtPosition(力的方向 <em> 力的大小(质量 </em> xxx) * 给力到哪一个点(确保是在物体内)，力的模式)<br>就像一个力打上一个球的边缘一样，会使用这个球旋转</p></blockquote><h2 id="AddRelativeForce（相对坐标方向的力，模型坐标）"><a href="#AddRelativeForce（相对坐标方向的力，模型坐标）" class="headerlink" title="AddRelativeForce（相对坐标方向的力，模型坐标）"></a>AddRelativeForce（相对坐标方向的力，模型坐标）</h2><h2 id="AddTorque（世界坐标方向力）"><a href="#AddTorque（世界坐标方向力）" class="headerlink" title="AddTorque（世界坐标方向力）"></a>AddTorque（世界坐标方向力）</h2><blockquote><p>AddTorque(Vector3.right * 10); 力矩方向给右边 会绕x轴旋转<br>给个力矩就会使这个物体做圆周运动<br>给绕哪一个轴旋转的力矩 就会绕哪个轴旋转</p></blockquote><h2 id="AddRelativeTorque（相对坐标方向力，模型坐标）"><a href="#AddRelativeTorque（相对坐标方向力，模型坐标）" class="headerlink" title="AddRelativeTorque（相对坐标方向力，模型坐标）"></a>AddRelativeTorque（相对坐标方向力，模型坐标）</h2><h2 id="物理管理器"><a href="#物理管理器" class="headerlink" title="物理管理器"></a>物理管理器</h2><ul><li>Gravity 重力,设置重力的大小和方向;</li><li>Default Material：为每个物体给一个默认的物理材质;</li><li>Bounce Threshold 反弹阈值,低于这个不进行反弹计算;</li><li>SleepThreshold 休眠阈值能量低于这个阈值休眠 E = (sqrt(v) + sqrt(A)) * 0.5<blockquote><p>v 速度 A 角度</p></blockquote></li><li>Default Contact offset 默认接触偏差,低于该值认为刚体已经接触必须&gt;0;</li><li>Solver Iteration Count 关节和连接迭代次数;</li><li>Raycasts Hit Triggers 射线是否命中触发器, true检测命中, false忽略触发器;</li><li>Enable Adaptive Force 允许自适应力 修正模拟运动状态的数值偏差;碰撞矩阵,配置层级间的碰撞关系;</li></ul><h2 id="物理形状-碰撞器"><a href="#物理形状-碰撞器" class="headerlink" title="物理形状/碰撞器"></a>物理形状/碰撞器</h2><ul><li>Box Collider 盒子碰撞器;</li><li>Sphere Collider 球体碰撞器</li><li>Capsule Collider 胶囊碰撞器;</li><li>Mesh Collider  网格碰撞器（使用这个的物体不能直接加刚体 unity 5.0）;<blockquote><p>或勾选刚体的 <code>Is Kinematic</code></p></blockquote></li><li>Terrian Collider 地形碰撞器;</li><li>Wheel Collider 车轮碰撞器;</li></ul><h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><blockquote><p>每种物体的弹力，摩擦力等物理参数可能不一样，unity使用物理材质来描述它们;</p><ul><li>Dynamic Friction 滑动摩擦(动态摩擦)</li><li>Static Firction 静态摩擦</li><li>Bounciness 表面弹性;</li><li>Friction Combine 摩擦力的混合方式</li><li>Bounciness Combine 弹力的混合方式;</li></ul></blockquote><ul><li>Bounce Combine<ul><li>Average 平均值<blockquote><p>如果一个球弹力为1 地面为0 那么弹一次 就会取他们直接弹力的平均值 弹力有衰减</p></blockquote></li><li>Maximun 最大值<blockquote><p>球弹力为1 地面为0 最大值为1 那么球就会一直弹下去 弹力一直为1</p></blockquote></li></ul></li></ul><h1 id="第三十一课（Unity3D物理引擎-二-刚体碰撞检测配置与触发器配置）"><a href="#第三十一课（Unity3D物理引擎-二-刚体碰撞检测配置与触发器配置）" class="headerlink" title="第三十一课（Unity3D物理引擎(二)刚体碰撞检测配置与触发器配置）"></a>第三十一课（Unity3D物理引擎(二)刚体碰撞检测配置与触发器配置）</h1><p>##　Physics</p><blockquote><p>类 物理设置 代码设置物理设置</p></blockquote><p>忽略两个层之间的碰撞<br>Physics.IgnoreLayerCollision(8, 9);</p><h1 id="第三十二课（unity-自带摇杆与车轮碰撞器的使用）"><a href="#第三十二课（unity-自带摇杆与车轮碰撞器的使用）" class="headerlink" title="第三十二课（unity_自带摇杆与车轮碰撞器的使用）"></a>第三十二课（unity_自带摇杆与车轮碰撞器的使用）</h1><ul><li>WheelCollider<blockquote><p>x 用来控制方向 y 用来控制向前还是向后</p><ul><li>motorTorque：车轮移动的力矩,为正向前，为负向后</li><li>steerAngle: 车轮的转向角;</li><li>rmp: 每分钟转多少转;<br>(rmp * 360 / 60) 1s转多少度</li></ul></blockquote></li></ul><ul><li>车轮<blockquote><p>车轮碰撞器如果需要阻力（在刚体上加）目前只知道的唯一方法</p></blockquote></li></ul><h1 id="第三十三课（unity关节的基本介绍和基本使用）"><a href="#第三十三课（unity关节的基本介绍和基本使用）" class="headerlink" title="第三十三课（unity关节的基本介绍和基本使用）"></a>第三十三课（unity关节的基本介绍和基本使用）</h1><p>unity的帮助手册 组件手册/物理组件/关节组件相关介绍</p><blockquote><p>关节必须加刚体</p></blockquote><h2 id="关节"><a href="#关节" class="headerlink" title="关节"></a>关节</h2><blockquote><p>链接刚体的</p></blockquote><ul><li><p>铰链关节(hinge Joint)</p><blockquote><p>将两个刚体束缚在一起，在两者之间产生铰链效果;</p></blockquote><p>  使用</p><blockquote><p>Axis 绕选轴开始旋转</p><ul><li>创建一个圆柱体与一个立方体;</li><li>调整他们的大小类是与门的形状;</li><li>分别添加刚体组件;</li><li>为圆柱体创建一个铰链关节(Hinge Joint)</li><li>冻结圆柱体的位置和旋转;</li><li>给立方体一个冲量;</li></ul></blockquote></li><li><p>固定关节(Fixed Joint)</p><blockquote><p>将两个刚体束缚在一起, 相对位置保持不变，永远不会变化;</p></blockquote><p>  使用</p><ul><li>创建2个球体,分别对2个球体加上刚体组件;</li><li>在其中一个球体里面加入固定关节(Fixed Joint),并关联好另外的刚体;</li><li>给其中一个刚体一个冲量</li></ul></li><li><p>弹簧关节(Spring Joint)</p><blockquote><p>将两个刚体束缚在一起, 相对位置保持不变，永远不会变化;</p></blockquote><p>  使用</p><ul><li>创建1个立方体(墙)和1个球体,分别对2个物体加上刚体组件;</li><li>在其中一个球体里面加入弹簧关节(Spring Joint),并关联好另外的刚体;</li><li>给球体一个力;</li></ul></li><li><p>角色关节(Character Joint)</p><blockquote><p>应用广泛的基本关节,角色关节配合Ragdoll使用,是一个扩展的球窝关节;</p></blockquote><p>  使用</p><ul><li>创建2个球体,分别对2个球体加上刚体组件;</li><li>在其中一个球体里面加入角色关节(Character Joint),并关联好另外的刚体;</li></ul></li><li><p>可配置关节(Configurable Joint)</p><blockquote><p>参数可配置，可以穿件很多灵活的关节;<br>  <a href="www.ceeger.com/Components/class-ConfigurableJoint.html">可配置关节属性</a></p></blockquote><p>  可配置关节使用</p><ul><li>创建一个立方体，创建一个球体，分别加上刚体组件;</li><li>选中立方体，加入可配置关节</li><li>X Motion, Y Motion, Z Motion 修改为Locked;</li><li>修改立方体的参数，让它固定位置;</li></ul></li></ul><h1 id="第三十四（关节案例分析）"><a href="#第三十四（关节案例分析）" class="headerlink" title="第三十四（关节案例分析）"></a>第三十四（关节案例分析）</h1><blockquote><p>固定关节如果链接多了，关节质量又不一样的话，会有回弹的效果<br>机械手夹物体<br>导入导出不会导出配置的物理配置/层级关系</p></blockquote><h1 id="第三十五（蒙皮网格与布料组件的介绍和基本使用）"><a href="#第三十五（蒙皮网格与布料组件的介绍和基本使用）" class="headerlink" title="第三十五（蒙皮网格与布料组件的介绍和基本使用）"></a>第三十五（蒙皮网格与布料组件的介绍和基本使用）</h1><blockquote><p>例如要模拟衣服，随风摆动，模拟布料需要用到蒙皮网格和布料;<br>蒙皮网格可以模拟出非常柔软的网格体,用于布料和角色的蒙皮功能；<br>蒙皮网格 + 布料组件能模拟出布料效果；</p></blockquote><ul><li>Skinned Mesh Renderer 蒙皮网格<blockquote><p>是一种网格渲染器,是一种渲染网格的方式;</p></blockquote></li><li>布料是Cloth组件;</li></ul><h1 id="第三十六课（粒子系统和基本使用）"><a href="#第三十六课（粒子系统和基本使用）" class="headerlink" title="第三十六课（粒子系统和基本使用）"></a>第三十六课（粒子系统和基本使用）</h1><ul><li><p>unity创建一个粒子 </p><ul><li>GameObject–&gt; Particle System;</li><li>创建一个节点–&gt;添加一个ParticleSystem组件;</li></ul></li><li><p>粒子参数</p><ul><li><p>粒子系统主体;</p><ul><li>Duration: 粒子喷射周期;</li><li>Looping: 是否循环喷射;</li><li>Prewarm: 预热(Loop状态下预产生下一周期的粒子);</li><li>StartDelay: 粒子喷射延迟,Prewarm无法延迟;</li><li>Start Lifetime: 粒子生命周期;</li><li>Start speed: 粒子喷射速度;</li><li>Start Rotation: 粒子大小;</li><li>Start Color: 粒子颜色；</li><li>Gravity Modifier: 相对与重力加速的的重力密度(缩放比);</li><li>Inherit Velocity: 新生粒子的继承速度;</li><li>Simulation Space: 粒子系统的模拟空间;</li><li>Play On Awake: 是否在加载的时候播放;</li><li>MaxParticles: 一周内发射的例子数,多与此数目停止发射;</li></ul></li><li><p>喷射(Emission);</p></li><li><p>形态(shape);</p><blockquote><p>决定了例子系统喷射的范围;</p><ul><li>主要的形状有:<ul><li>球体(Sphere)</li><li>半球体(HemiSphere)</li><li>圆锥体 Cone</li><li>盒子(Box) </li><li>网格(Mesh)</li><li>环形(Cricle) </li><li>边线(Edge)</li></ul></li></ul></blockquote></li><li><p>生命周期内的速度偏移(velocity over lifetime);</p></li><li>生命周期内的限制速度(limit velocity over lifetime);</li><li>生命周期内的受力偏移(Force velocity over lifetime);</li><li>生命周期内的颜色(Color velocity over lifetime);</li><li>颜色随速度的变化(Color by Speed);</li><li>生命周期内的大小(Size over lifetime);</li><li>大小随速度变化(Size by speed);</li><li>生命周期内的转速(Rotation over lifetime);</li><li>角速度随速度变化(Rotation by Speed);</li><li>外部作用力(External Forces)</li><li>碰撞(Collision)</li><li>子发射系统(Sub Eimitters);</li><li>纹理层动画(Texture Sheet Animation);</li><li>渲染器(Render); </li></ul></li></ul><h1 id="第三十七课（初识shader）"><a href="#第三十七课（初识shader）" class="headerlink" title="第三十七课（初识shader）"></a>第三十七课（初识shader）</h1><h2 id="shader概述"><a href="#shader概述" class="headerlink" title="shader概述"></a>shader概述</h2><ul><li>Shader是给GPU执行的程序,中文叫做着色器;<ul><li>着色器<blockquote><p>在GPU画面绘制</p></blockquote></li></ul></li><li>着色器是运行在图形处理单元上，可以让开发人员直接操作图形硬件渲染功能；</li><li>shader能开发出很多好的效果，UV动画，水, 雾 等一些特效, 这些用程序开发出来比较困难，性能还不好;</li><li>渲染流水线, 模型投影, 定点着色;</li><li>shader一般主要有: <strong>固定管线着色器</strong>,  <strong>顶点片元着色器</strong>, <strong>表面着色器</strong>;<ul><li>固定管线着色器(慢慢会被淘汰);</li><li>顶点shader: 干预模型形态的shader; </li><li>像素shader: 干预像素着色的shader;<blockquote><p>模型定点运算的时候，可以加入顶点shader来干预顶点的位置;顶点着色的时候，加入像素shader来干预像素的上色;</p></blockquote></li></ul></li></ul><h2 id="GPU编程语言"><a href="#GPU编程语言" class="headerlink" title="GPU编程语言"></a>GPU编程语言</h2><ul><li>什么是Direct3D和opengl;</li><li>目前面向GPU的编程语言主要有三种:<ul><li>HLSL 语言 通过Direct3D编写的着色器程序，只能在Direct3D里面使用;</li><li>Cg 语言 NVIDIA和微软合作提供的语言,与C相似，Direct3D和opengl都支持；</li><li>GLSL语言 支持OpenGL上编写Shader程序;</li></ul></li><li>Unity使用ShaderLab来进行着色程序的编写，对不同的平台进行编译，重点支持Cg语言;  </li></ul><blockquote><ul><li>Direct3D<br>win微软</li><li>opengl<br>安卓、Linux、win以外的平台等</li></ul></blockquote><ul><li>定义shader<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个Shader,每一个着色程序都要有一个Shader</span><br><span class="line">Shader “name” &#123; // name shader名字</span><br><span class="line">    // 定义的一些属性，定义在这里的会在属性查看器里面显示; </span><br><span class="line">    [Propeties]  </span><br><span class="line">    // 子着色器列表，一个Shader必须至少有一个子着色器; </span><br><span class="line">    Subshaders: &#123;....&#125;</span><br><span class="line">    // 如果子着色器显卡不支持，就会降级,即Fallback操作;</span><br><span class="line">    [Fallback]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>display name是在属性检查器的名字;<br>type: 这个属性的类型<br>值: 只这个属性的默认值;</p><ul><li><p>name(“display name”, type) = 值;</p><blockquote><p>name指的是属性的名字，Unity中用下划线开始_Name;</p><ul><li>类型(type):<ul><li>Float</li><li>Int</li><li>Color(num, num, num, num)(0 ~ 1) </li><li>Vector(4维向量)</li><li>Range(start, end)</li></ul></li><li>纹理属性<ul><li>2D: 2D纹理属性;</li><li>Rect: 矩形纹理属性;</li><li>Cube: 立方体纹理属性;</li><li>3D: 3D纹理属性;</li></ul></li></ul></blockquote></li><li><p>name(“displayname”, 2D) = “name” {options}</p><ul><li>Options: 纹理属性选项<ul><li>TexGen:纹理生成模式,纹理自动生成纹理坐标的模式;顶点shader将会忽略这个选项; </li><li>ObjectLinear, EyeLinear, SphereMap, CubeReflect CubeNormal</li><li>LightmapMod: 光照贴图模式如果设置这个选项,纹理会被渲染器的光线贴图所影响。</li></ul></li></ul></li><li><p>定义</p><ul><li>_Range (“range value”, Range(0, 1)) = 0.3; // 定义一个范围</li><li>_Color(“color”, Color) = (1, 1, 1, 1); // 定义一个颜色</li><li>_FloatValue(“float value”, Float) = 1 // 定义一个浮点</li><li>_MainTex (“Albedo”, Cube) = “skybox” {TexGen CubeReflect} // 定义一个立方贴图纹理属性;</li></ul></li></ul><h2 id="Subshaders"><a href="#Subshaders" class="headerlink" title="Subshaders"></a>Subshaders</h2><ul><li><p><code>SubShader {[Tags], [CommonState], Pass {} }</code>子着色器由 标签(Tags),通用状态,通道列表组成,它定义了一个渲染通道列表，并可选为所有通道初始化需要的通用状态;</p><ul><li>Tags {“标签1” = “value1” “key2” = “value2”}<ul><li>标签的类型:<ul><li>Queue tag 队列标签;</li><li>RenderType tag  渲染类型标签;</li><li>DisableBatching tag 禁用批处理标签;</li><li>ForceNoShadowCasting Tag 强制不投阴影标签;</li><li>IgnoreProjecttor 忽略投影标签;</li><li>CanUseSpriteAtlas Tag,使用精灵图集标签;</li><li>PreviewType Tag预览类型标签;</li></ul></li></ul></li><li>Pass<ul><li>subshader 包装了一个渲染方案，这些方案由一个个通道(Pass)来执行的，SubShader可以包括很多通道块,每个Pass都能使几何体渲染一次;</li><li>Pass基本语法:<ul><li><code>Pass { [Name and Tags] [RenderSetup] [Texture Setup]}</code>Pass块的Name引用此Pass,可以在其它着色器的Pass块中引用它，减少重复操作,<strong>Name命令必须大写</strong>;</li></ul></li></ul></li></ul></li><li><p>SubShader渲染的时候，将优先渲染一个被每个通道所定义的对象。</p></li><li><p>通道的类型: </p><ul><li>RegularPass<ul><li>Lighting 光照: 开启关闭定点光照 On/Off</li><li>Material{材质块}: 材质,定义一个使用定点光照管线的材质;</li><li>ColorMaterial: 颜色集 计算定点光照的时使用顶点颜色;</li><li>SeparateSpecular: 开光状态 开启或关闭顶点光照相关的镜面高光颜色，On/Off;</li><li>Color 设置定点光照关闭时的所使用的颜色;</li><li>Fog{雾块}: 设置雾参数;</li><li>AlphaTest: Alpha测试</li><li>ZTest: 深度测试模式;</li><li>ZWrite: 深度写模式;</li><li>Blend: 混合模式 SourceBlendMode, DestBlendMode, AlphaSourcesBlendMode, AlphaDstBlendMode;</li><li>ColorMask 颜色遮罩: 设置颜色遮罩,颜色值可以由RGB或A或0或R,G,B,A的组合,设置为0关闭所有颜色通道渲染;</li><li>Offset偏移因子: 设置深度偏移;</li></ul></li><li>特殊通道(UsePass/GrabPass)<ul><li>UsePass<ul><li>UsePass: 插入所有来自其它着色器的给定名字的通道;</li><li>UsePass ”Shader/Nmae”, Name为着色器通道;</li><li>UsePass “Specular/BASE” // 插入Specular中为Bass的通道;</li></ul></li><li>GrabPass<ul><li>GrabPass {}: 一种特殊通道类型，他会捕获物体所在的位置的屏幕的内容，并写入一个纹理中，这个纹理能被用于后续通道中完成一些高级图像特效,后续通道可以使用_GrabTexture进行访问(访问上一次截取到的);</li><li>GrabPass{“纹理名称”} 捕获屏幕内容到指定纹理中，后续通道可以通过纹理名称来访问;</li></ul></li></ul></li></ul></li><li><p>在通道中定义状态同时对整个子着色器可见，那么所有的通道可以共享状态;</p></li></ul><p>通道示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags &#123;“Queue”, “Transparent” &#125;</span><br><span class="line">    Pass &#123;</span><br><span class="line">        Lighting Off   // 关闭光照</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>shader通过通道来进行达到不同显示的渲染</p><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><blockquote><ul><li>降级: 定义在所有子着色器之后,如果没有任何子着色器能运行，则尝试降级;</li><li>Fallback “着色器名称”;</li><li>Fallback Off;<br><strong>没有降级，并且不会打印任何警告</strong>;</li></ul></blockquote><h2 id="Category分类"><a href="#Category分类" class="headerlink" title="Category分类"></a>Category分类</h2><ul><li>分类是渲染命令的逻辑组。例如着色器可以有多个子着色器,他们都需要关闭雾效果，和混合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 所有的shader将把 这个给设置为Mode Off</span><br><span class="line">Shader “xxxx” &#123;</span><br><span class="line">Categroy &#123;</span><br><span class="line">     Fog &#123; Mode Off &#125;</span><br><span class="line">     SubShader &#123;...&#125;</span><br><span class="line">     SubShader &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第三十八课（unity-顶点片元shader与第一个shader）"><a href="#第三十八课（unity-顶点片元shader与第一个shader）" class="headerlink" title="第三十八课（unity_顶点片元shader与第一个shader）"></a>第三十八课（unity_顶点片元shader与第一个shader）</h1><h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><ul><li>物体空间: 3D物体自己的坐标空间 一般设计时几何体以中心为原点,人物以双脚为原点;</li><li>世界空间: 3D物体在场景中的世界坐标, 整个游戏场景的空间;</li><li>摄像机空间: 以观察摄像机为原点的坐标系下的坐标空间;</li><li>投影成像  3D坐标转换到屏幕空间;</li></ul><h2 id="Unity坐标系转换"><a href="#Unity坐标系转换" class="headerlink" title="Unity坐标系转换"></a>Unity坐标系转换</h2><ul><li>transform.localToWorldMatrix   局部转世界的矩阵;</li><li>transfrom.worldToLocalMatrix  世界坐标转局部坐标矩阵;</li><li>MultiplyPoint, MultiplyPoint3x4 MultiplayVector 来进行坐标变换;</li><li>shader中 左乘unity_WorldToObject矩阵来实现世界坐标转局部坐标变换;</li><li>shader中左乘unity_ObjectToWorld矩阵来实现局部转世界的转换; </li><li>UNITY_MATRIX_MV 基本变换矩阵 x 摄像机矩阵;</li><li>UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵;</li><li>UNITY_MATRIX_V 摄像机矩阵;</li><li>UNITY_MATRIX_P 投影矩阵;</li><li>UNITY_MATRIX_VP摄像机矩阵x投影矩阵;</li><li>UNITY_MATRIX_T_MV (基本变换矩阵 x 摄像机矩阵) 转置矩阵;</li><li>UNITY_MATRIX_IT_MV(基本变换矩阵 x 摄像机矩阵) 的逆转置矩阵;</li><li>UNITY_MATRIX_TEXTURE0 纹理变化矩阵;</li></ul><h2 id="GPU管道流水线"><a href="#GPU管道流水线" class="headerlink" title="GPU管道流水线"></a>GPU管道流水线</h2><blockquote><p><img src="unity学习笔记/38_1.png" alt="图片暂时没有哦"></p></blockquote><h2 id="顶点片元着色器"><a href="#顶点片元着色器" class="headerlink" title="顶点片元着色器"></a>顶点片元着色器</h2><ul><li>优点<blockquote><ul><li>控制灵活</li></ul></blockquote></li><li>缺点<blockquote><ul><li>不能参与光照计算;</li></ul></blockquote></li><li>在着色器中插入Cg代码段,编写在 <code>CGPROGRAM</code> 与 <code>ENDCG</code> 之间;</li><li>编译指令: #pragma控制 着色器代码编译;<ul><li><code>#pragma vertex name</code> 将名称为 name 的函数编译为顶点着色器;</li><li><code>#pragma fragment name</code> 将名称为 name 的函数编译为片元着色器;</li></ul></li><li>参数和返回值有语义修饰</li></ul><h2 id="常用语义"><a href="#常用语义" class="headerlink" title="常用语义"></a>常用语义</h2><ul><li>POSITION : 位置</li><li>TANGENT : 切线</li><li>NORMAL: 法线</li><li>TEXCOORD0: 第一套纹理</li><li>TEXCOORD1: 第二套纹理</li><li>TEXCOORD2: 第三套纹理</li><li>TEXCOORD3: 第四套纹理</li><li><p>COLOR: 颜色</p></li><li><p>为什么加语义</p><blockquote><p>加语义是为了获取上一个工位的参数，完成之后也要语义，要传给下一个工位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    // 渲染通道</span><br><span class="line">    Pass &#123;</span><br><span class="line">        // 代码的入口</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            // 顶点着色器的入口</span><br><span class="line">            #pragma vertex my_vertex</span><br><span class="line">            // 怎么获取上一个工位的参数(语义绑定：看你需要上一个工位的什么工参数 就语义绑定什么参数)</span><br><span class="line">            // 需要获取上一个工位的 position</span><br><span class="line">            // 怎么把结果返回下一个工位(语义绑定：看你需要传递什么参数给下一个工位 就语义绑定什么参数)</span><br><span class="line">            // 需要把结果 position 给下一个工位</span><br><span class="line"></span><br><span class="line">            float4 my_vertex(float4 pos : POSITION) : POSITION&#123;</span><br><span class="line">                // UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵;把这个pos转换为 投影矩阵给下一个工位的position</span><br><span class="line"></span><br><span class="line">                // unity5.6以前的写法  </span><br><span class="line">                // o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);    </span><br><span class="line"></span><br><span class="line">                // unity5.6以后的写法</span><br><span class="line">                // o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                return UnityObjectToClipPos(pos);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 片元着色器的入口</span><br><span class="line">            #pragma fragment my_fragment</span><br><span class="line"></span><br><span class="line">            // fixed4能保存颜色的数据类型</span><br><span class="line">            // 把 color 返回给下一个工位 所有用来语义绑定 : COLOR</span><br><span class="line">            fixed4 my_fragment() : COLOR&#123;</span><br><span class="line">                // 把红色返回给下一个工位进行渲染</span><br><span class="line">                return fixed4(1.0, 1.0, 0.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="第三十九课（unity-Cg基础知识和基本使用）"><a href="#第三十九课（unity-Cg基础知识和基本使用）" class="headerlink" title="第三十九课（unity_Cg基础知识和基本使用）"></a>第三十九课（unity_Cg基础知识和基本使用）</h1><h2 id="基本类型表达式"><a href="#基本类型表达式" class="headerlink" title="基本类型表达式"></a>基本类型表达式</h2><pre><code>* 语法和C语言类是,有对应的编译器,程序是给显卡运行;* 可以从渲染流水线中获得对应的输入;* 指定的输出能流入下一个流水线模块;* 操作符号和C语言一样，可以使用 +, -, * /  &lt;, &gt;, &lt;=, &gt;= 等运算;* Cg提供了float half double 浮点类型;* Cg 支持定点数 fixed来高效处理 某些小数;* Cg使用int来表示整数;* bool 数据类型来表示逻辑类型;* sampler*,纹理对象的句柄, sampler/1D/2D/3D/CUBE/RECT* 内置向量数据类型: float4(float, float, float, float), 向量长度不能超过4;* 内置矩阵数据类型: float1x1 float2x3 float4x3 float4x4;不能超过4x4;* 数组类型float a[10]; 10个float, float4 b[10], 10个float4;* 语义绑定 float4 a : POSITION,返回值也可以语义绑定;</code></pre><p>##　结构体与语义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct name &#123;</span><br><span class="line">    // 类型 名字; </span><br><span class="line">    // 尽量不要使用;</span><br><span class="line">    返回值 函数名称(参数) &#123;</span><br><span class="line">        // 如果成员函数里面使用，数据成员，该成员定义在函数前;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>输入语义与输出语义:<ul><li>语义: 一个阶段处理数据，然后传输给下一个阶段，那么每个阶段之间的接口, 例如：顶点处理器的输入数据是处于模型空间的顶点数据（位置、法向量），输出的是投影坐标和光照颜色；片段处理器要将光照颜色做为输入;C/C++用指针，而Cg通过语义绑定的形式;</li><li>输入语义: 绑定接收参数,从上一个流水线获得参数;</li><li>输出语义: 绑定输出参数到下一个流水线模块;</li><li>语义: 入口函数上有意义(顶点着色入口,像素着色入口)，普通的函数无意义;</li></ul></li></ul><h2 id="标准内置函数"><a href="#标准内置函数" class="headerlink" title="标准内置函数"></a>标准内置函数</h2><ul><li>abs(num)绝对值;</li><li>三角函数;</li><li>cross(a, b) 两个向量的叉积;</li><li>determinant(M)矩阵的行列式;</li><li>dot(a, b) 两个向量的点积;</li><li>floor(x)向下取整;</li><li>lerp(a, b, f), 在a, b之间线性插值;</li><li>log2(x) 基于2为底的x的对数;</li><li>mul(m, n): 矩阵x矩阵, 矩阵x向量, 向量x矩阵;</li><li>power(x, y) x的y次方;</li><li>radians(x) 度转弧度;</li><li>reflect(v, n) v 关于法线n的反射向量;</li><li>round(x) 靠近取整;</li><li>tex2D(smapler, x) 二维纹理查找</li><li>tex3Dproj(smapler, x) 投影三维纹理查找;</li><li>texCUBE 立方体贴图纹理查找;</li><li>distance 计算点的距离</li></ul><h2 id="Unity自带函数"><a href="#Unity自带函数" class="headerlink" title="Unity自带函数"></a>Unity自带函数</h2><ul><li>引用Unity自带的函数库: <code>#include “UnityCG.cginc” Unity--&gt;Edit--&gt;Data--&gt;CGIncludes;</code></li><li>TRANSFORM_TEX: 根据顶点的纹理坐标，计算出对应的纹理的真正的UV坐标;</li><li>使用属性的变量: 在shader里面需要使用属性变量还需要在shader中定义一下这个变量的类型和名字;<strong>名字要保持一致</strong>;</li><li>外部修改shader的编辑器上的参数值;</li></ul><h1 id="第四十课（顶点片元Shader实例-正波-UV动画）"><a href="#第四十课（顶点片元Shader实例-正波-UV动画）" class="headerlink" title="第四十课（顶点片元Shader实例_正波_UV动画）"></a>第四十课（顶点片元Shader实例_正波_UV动画）</h1><blockquote><p>顶点片元 Shader Unlit Shader</p></blockquote><h2 id="float4-fixed4-Time"><a href="#float4-fixed4-Time" class="headerlink" title="float4 fixed4 _Time"></a>float4 fixed4 _Time</h2><ul><li>float4是内置向量 (x, y, z, w);   float4 a; 访问单独成员a.x, a.y, a.z, a.w;</li><li>fixed4 是内置向量(r, g, b, a);   fixed4 c; color.r, color.g, color.b, color.a;</li><li>float3是内置向量(x, y, z);</li><li>fixed3 是内置向量(r, g, b);</li><li>float2 是内置向量(x, y);</li><li>_Time: 自场景加载开始所经过的时间t，4个分量分别是 (t/20, t, t<em>2, t</em>3);</li><li>_SinTime:  t 是时间的正弦值，4个分量分别是 (t/8, t/4, t/2, t);</li><li>_CosTime: t 是时间的余弦值，4个分量分别是 (t/8, t/4, t/2, t);</li><li>unity_DeltaTime: dt 是时间增量，4个分量的值(dt, 1/dt, smoothDt,  1/smoothDt),平滑时间，防止时间间隔起伏太大;</li></ul><h1 id="第四十一课（表面着色器的基础知识和shader结构）"><a href="#第四十一课（表面着色器的基础知识和shader结构）" class="headerlink" title="第四十一课（表面着色器的基础知识和shader结构）"></a>第四十一课（表面着色器的基础知识和shader结构）</h1><blockquote><p>标准的表面着色器 Standerd Surface Shader</p></blockquote><ul><li>表面着色器包括4个函数:<ul><li>顶点变换函数;</li><li>表面着色函数;</li><li>光照模型;</li><li>最终颜色修改函数;<blockquote><p>1 3 4可选<br>表面着色器最终会被编译为一个复杂的顶点着色程序;</p></blockquote></li></ul></li></ul><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><ul><li><code>#pragma surface</code> 入口函数名称 光照模型  [Options] </li><li>suface 后面跟 表面着色的入口函数  surf(Input IN, inout SurfaceOutput o);<ul><li>Input 结构附加数据<ul><li>Input:<strong>包含着色所需要的纹理坐标　uv纹理名字;使用第二张纹理是uv2纹理名字;</strong><blockquote><p>附加数据:</p><ul><li>float3 viewDir  视图方向。</li><li>float4 color 每个顶点的颜色插值</li><li>float4 screenPos 屏幕空间中的位置。</li><li>float3 worldPos 世界坐标空间;   </li><li>float3 worldRef1 世界空间中的反射向量;</li><li>float3 worldNormal 世界空间中的法线向量;</li><li>float3 worldRef1; INTERNAL_DATA 世界坐标反射向量, 但必须表面着色写入o.Normal参数;</li><li>float3 worldNormal; INTERNAL_DATA 世界坐标法线向量, 但必须表面着色写入o.Normal参数;</li></ul></blockquote></li></ul></li><li>SurfaceOutput 结构体<ul><li>SurfaceOutput：<ul><li>half3 Albedo: 漫反射的颜色值;</li><li>half3 Normal: 法线坐标;</li><li>half3 Emission; 自发光颜色;</li><li>half Specular;  镜面反射系数;</li><li>half Gloss; 光泽系数;</li><li>half Alpha; 透明度系数;</li></ul></li><li>SurfaceOutputStandard(继承上方)：<ul><li>half Smoothness;    // 0=粗糙, 1=光滑</li><li>half Metallic;    // 0=非金属, 1=金属</li></ul></li><li>SurfaceOutputStandardSpecular(继承上方):<ul><li>fixed3 Albedo;     </li><li>fixed3 Specular;    </li><li>fixed3 Normal;     </li><li>half3 Emission;  </li><li>half Smoothness;    // 0=粗糙, 1=光滑  </li><li>half Occlusion;  // 遮挡(默认1)  </li><li>fixed Alpha;  </li></ul></li></ul></li></ul></li><li>光照模型： <ul><li>系统内置 Lambert(漫反射光照) BlinnPhong (高光光照)</li><li>自定义光照: 名字为Name <ul><li>half4 Lighting<name>(SurfaceOutput s, half3 lightDir, half atten);</name></li><li>half4 Lighting<name>(SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);</name></li><li>half4 Lighting<name>(SurfaceOutput s, half4 light);<br>可选参数(Options):</name></li></ul></li></ul></li><li><code>vertex: name vertex</code>顶点着色器入口函数: <ul><li>void <name> (inout appdata_full v) 只需改顶点着色器中的输入顶点数据;</name></li><li>half4 <name>(inout appdata_full v, out Input o) 修改输入顶点数据,以及为表面着色器传递数据;</name></li></ul></li><li><code>finalcolor: name</code> 最终颜色修改函数:<br>  void <name>(Input IN, SurfaceOutput o, inout fixed4 color);</name></li></ul><h2 id="其它可选参数"><a href="#其它可选参数" class="headerlink" title="其它可选参数"></a>其它可选参数</h2><ul><li>alpha: Alpha 混合模式，用户半透明着色器;</li><li>alphatest: varirableName Alpha测试模式，用户透明镂空着色器。</li><li>exclude_path:prepass 使用指定的渲染路径;</li><li>addshadow: 添加阴影投射器和集合通道;</li><li>dualforward: 将双重光照贴图用于正向渲染路径中;</li><li>fullforwardshadows 在正向渲染路径中支持的所有的阴影类型;</li><li>decal: add 附加印花着色器;</li><li>decal: blend 附加半透明印花着色器;</li><li>softvegetation 使用表面着色器，仅在Soft Vegetation 开启时被渲染;</li><li>noambient 不使用任何光照</li><li>novertexlights 在正向渲染中不适用球面调和光照或逐点光照;</li><li>nolightmap 在这个着色器上禁用光照贴图;</li><li>nodirlightmap 在这个着色器上禁用方向光照贴图;</li><li>noforwardadd 禁用正向渲染添加通道;</li><li>approxview: 对于有需要的着色器，逐顶点而不是逐像素计算规范化视线方向。</li><li>halfasview:  将半方向传递到光照函数中。</li></ul><h2 id="Unity坐标系转换-1"><a href="#Unity坐标系转换-1" class="headerlink" title="Unity坐标系转换"></a>Unity坐标系转换</h2><ul><li>transform.localToWorldMatrix   局部转世界的矩阵;</li><li>transfrom.worldToLocalMatrix  世界坐标转局部坐标矩阵;</li><li>MultiplyPoint, MultiplyPoint3x4 MultiplayVector 来进行坐标变换;</li><li>shader中 左乘unity_WorldToObject矩阵来实现世界坐标转局部坐标变换;</li><li>shader中左乘unity_ObjectToWorld矩阵来实现局部转世界的转换; </li><li>UNITY_MATRIX_MV 基本变换矩阵 x 摄像机矩阵;</li><li>UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵;</li><li>UNITY_MATRIX_V 摄像机矩阵;</li><li>UNITY_MATRIX_P 投影矩阵;</li><li>UNITY_MATRIX_VP摄像机矩阵x投影矩阵;</li><li>UNITY_MATRIX_T_MV (基本变换矩阵 x 摄像机矩阵) 转置矩阵;</li><li>UNITY_MATRIX_IT_MV(基本变换矩阵 x 摄像机矩阵) 的逆转置矩阵;</li><li>UNITY_MATRIX_TEXTURE0 纹理变化矩阵;</li></ul><h1 id="第四十二课（通用管道的通用指令-一-LOD与渲染队列）"><a href="#第四十二课（通用管道的通用指令-一-LOD与渲染队列）" class="headerlink" title="第四十二课（通用管道的通用指令(一) LOD与渲染队列）"></a>第四十二课（通用管道的通用指令(一) LOD与渲染队列）</h1><h2 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h2><p>根据不同的LOD版本使用不同版本的shader（subshader可以写多个，但是只会执行一个，如果都不执行，那么就会执行fallback “Diffuse”）</p><blockquote><p>外部设置LOD值,每个Subshader有个内部LOD值，(找到第一个大于或等于)当<strong>外部设置maximumLOD这个值大于等于这Subshader内部LOD值的时候就执行这个Subshader</strong>(根据设置LOD值来取决于执行哪一个Subshader)<br><strong>也可以说Subshader内部LOD值小于等于 外部设置maximumLOD 最大值的时候就执行这个Subshader</strong></p><ul><li>LOD Level of Detail, 根据LOD来设置使用不同版本的Shader;</li><li>着色器中给SubShader一个LOD值，程序来设置这个shader的LOD值，只有第一个大于等于LOD值subShader才会被执行;</li><li>每个shader最多只会有一个SubShader被使用;</li><li>通过Shader maximumLOD来设置最大的LOD值;</li><li>设置全局的LOD值，Shader.globalMaximumLOD;</li><li>Unity内置着色器分LOD等级:<ul><li>VertexLit kind of shaders 100</li><li>Decal, Reflective VertexLit 150</li><li>Diffuse 200</li><li>Difuse Detail  250</li><li>Bumped, Specular   300</li><li>BumpedSpecular  400</li><li>Parallax   500</li><li>Parallax Specular 600<br>如果需要写多个Subshader并想通过修改maximumLOD来进行改变使用哪一个shader一定要注意<br>内部Subshader的LOD值一定要<strong>从大到小排序</strong>(找到第一个小于或等于的颜色 可能进行覆盖)，不然可能会造成和想象不一样的结果</li></ul></li></ul></blockquote><h2 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h2><blockquote><p><strong>先绘制前面和2D(后向前)不一样</strong></p></blockquote><ul><li>渲染队列(Queue)标签可选值:<ul><li>Background 背景,对应的值为1000;</li><li>Geometry(default) 几何体对应的值为2000, 这个队列是默认的渲染队列,大多数不透明的物体;</li><li>AlphaTest Alpha测试,对应值为2450, alpha测试的几何体使用这种队列,它是独立于 Geometry的队列,它可以在所有固体对象绘制后更有效的渲染采用Alpha测试的对象;</li><li>Transparent:透明，对应值3000, 这个渲染队列在Geometry被渲染，采用从后向前的次序;<br>任何有alpha混合的对象都在这个队列里面渲染;</li><li>Overlay 覆盖对应值为4000, 这个渲染队列是最后渲染的物体;</li></ul></li><li>Unity 渲染模式: <blockquote><p>可通过shader设置 <code>&quot;Queue&quot;=&quot;Geometry+100&quot;</code>+不能有空格带上这个shader的物体将会被先渲染(ZTest off 的情况 关闭深度测试)</p><ul><li><strong>普通物体从前向后, Alpha从后向前</strong>;</li><li><strong>渲染队列的数值决定了Unity在渲染场景物体时的先后顺序(越大越先),关闭深度测试的情况下</strong>;</li></ul></blockquote></li></ul><h1 id="第四十三课（unity-渲染通道通用指令-二-）"><a href="#第四十三课（unity-渲染通道通用指令-二-）" class="headerlink" title="第四十三课（unity_渲染通道通用指令(二)）"></a>第四十三课（unity_渲染通道通用指令(二)）</h1><blockquote><p>混合模式、Alpha测试、深度测试、通道遮罩、面剔除</p></blockquote><h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><ul><li>在所有计算完成后，决定当前的计算结果输出到帧缓冲区时，如何混合源和目标,通常用来绘制半透明的物体;</li><li>Blend Off 关闭混合</li><li>Blend 源因子，目标因子: 配置并开启混合，产生的颜色和因子相乘，然后两个颜色相加</li><li>Blend 源因子,目标因子, 源因子A，目标因子A： 源因子与目标因子用户混合颜色值，源因子A，与目标因子A，用于混合alpha</li><li>BlendOp操作命令: 不是将颜色混合在一起，而是对他们进行操作，主要有:<br>Min, Max, Sub, RevSub</li><li>混合因子的类型：<ul><li>One 使用源或目标色完全显示出来;                 <ul><li>OneMinusSrcColor 阶段值 (1-源颜色的值)</li></ul></li><li>Zero 删除源颜色或目标颜色;                             <ul><li>OneMinusSrcAlpha 阶段值 (1-源颜色的Alpha值)</li></ul></li><li>SrcColor 这个阶段的值*源颜色值;                    <ul><li>OneMinusDstColor 阶段值 (1-目标颜色的值);</li></ul></li><li>DstColor 这个阶段的值* 帧缓冲颜色值;         <ul><li>OneMinusDstAlpha 阶段值 * (1-目标颜色Alpha值)</li></ul></li><li>DstAlpha 这个阶段的值 * 帧缓冲源Alpha值   </li><li>SrcAlpha 这个阶段的值 * 源颜色Alpha值</li></ul></li><li>一般放在放在Pass通道里面<blockquote><p>设置混合模式: Blend SrcAlpha OneMinusSrcAlpha;(再设置<code>&quot;Queue&quot;=&quot;Transparent&quot;</code> 可见Alpha)<br>  源因子 [SrcAlpha 这个阶段的值 * 源颜色Alpha值] + 目标因子 [OneMinusSrcAlpha 阶段值 (1-源颜色的Alpha值)]</p></blockquote></li></ul><h2 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h2><ul><li>Alpha测试: 阻止片元被写到屏幕的最后机会, 最终渲染出来的颜色计算出来后可通过透明度和最后一个固定值比较，如果通过测试则绘制次片元，否则丢弃此片元;</li><li>AlphaTest Off/On: 开启/关闭Alpha测试,默认是关闭的;</li><li>比较测试值的模式:<ul><li>Greater &gt;,  GEqual &gt;=, Less &lt;, LEqual &lt;=, Equal ==, NotEqual !=, </li><li>Always (永远渲染), Never(从不渲染);</li></ul></li><li>AlphaTest 条件 [变量] / 常数,<blockquote><p>变量加上[变量名]</p></blockquote></li><li>一般放在放在Pass通道里面;</li></ul><p>##　深度测试</p><ul><li>为了使近距离的物体挡住远距离的物体，当片元写入到缓冲的时候，需要将片元的深度值与缓冲区的深度值进行比较，测试成功写入帧缓冲区;</li><li>ZWrite  深度写开关, 控制是否将深度Z的片元写入缓冲区中，如果不绘制透明物体设置为On, 否则的话设置为Off，默认为On;</li><li>ZTest 深度测试模式: 设置深度测试的执行方式，默认为LEqual,深度测试的模式:<br>  Less &lt;, Greater &gt;, LEqual &lt;= , GEqual &gt;=, Equal ==, NotEqual !=, Always 总是绘制,关闭深度测试;</li><li>ZTest 条件</li><li>一般放在放在Pass通道里面;</li></ul><h2 id="通道遮罩"><a href="#通道遮罩" class="headerlink" title="通道遮罩"></a>通道遮罩</h2><ul><li>通道遮罩可以是开发人员指定渲染结果输出的通道，而不是通常情况下的RGBA四个通道;</li><li>可选的是RGBA的任意组合以及0，如果为0意味着不会写入到任何通道;</li><li>ColorMask RGBA(可选)</li><li>ColorMask 0什么也不输出</li></ul><h2 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h2><ul><li>通过不渲染背对摄像机的几何体的面来提高性能优化错误，所有的几何体都包含正面和反面</li><li>面剔除操作，大多数都是封闭的物体，所以不需要绘制背面;</li><li>面剔除操作: <ul><li>Cull Back: 不绘制背对摄像机的面，默认项</li><li>Cull Front,  不绘制面向摄像机的面,</li><li>Cull Off, 关闭面剔除操作</li></ul></li></ul><h1 id="第四十四课（unity-Shader抓屏通道-多条件编译-Shader注意事项）"><a href="#第四十四课（unity-Shader抓屏通道-多条件编译-Shader注意事项）" class="headerlink" title="第四十四课（unity_Shader抓屏通道_多条件编译_Shader注意事项）"></a>第四十四课（unity_Shader抓屏通道_多条件编译_Shader注意事项）</h1><h2 id="GrabPass"><a href="#GrabPass" class="headerlink" title="GrabPass"></a>GrabPass</h2><ul><li>使用抓屏通道, GrabPass {} 或 GrabPass { “ 纹理名称”}; _GrabTexture 变量访问</li><li>后续的Pass通道使用这个抓屏;</li><li>编写案例<ul><li>创建一个顶点片元着色器;</li><li>将这个着色器放到Overlay队列(保证绘制在最上层)</li><li>使用GrabPass通道截屏，并定义好变量来接收</li><li>设置顶点的UV坐标;</li><li>着色使用截图的纹理</li></ul></li></ul><h2 id="常用的gcinc"><a href="#常用的gcinc" class="headerlink" title="常用的gcinc"></a>常用的gcinc</h2><ul><li>cginc文件: 宏，帮助函数等，放在CGIncludes下面，开发人员可以开发自己的cginclude文件</li><li>常用的cginc文件: <ul><li>HLSL.Support.cginc 协助多平台开发的一些宏等，自动包含</li><li>UnityShaderVarirables.cginc 全局变量，自动包含；</li><li>UnityCG.cginc 常用的帮助函数;</li><li>AutoLight.cginc 光照和阴影功能；</li><li>Lighting.cginc 表面着色器的光照模型;</li><li>TerrainEngine.cginc 地形植被的光照着色函数;</li></ul></li></ul><h2 id="UnityCG-gcinc常用函数"><a href="#UnityCG-gcinc常用函数" class="headerlink" title="UnityCG.gcinc常用函数"></a>UnityCG.gcinc常用函数</h2><ul><li>UnityWorldSpaceViewDir: 给定对象空间的顶点位置朝向摄像机方向的世界坐标空间方向;</li><li>ObjSpaceViewDir: 给定对象空间的顶点位置朝向摄像机方向的对象空间方向;</li><li>ParallaxOffset: 计算用于视差法线贴图的UV偏移量;</li><li>Luminance: 将颜色转为亮度;</li><li>DecodeLightmap: 从光照贴图中解码颜色;</li><li>float EncodeFloatRGBA(float4 rgba): 将RGBA颜色编码为[0,1)的浮点数；</li><li>float4 DecodeFloatRGBA(float v): 将一个浮点数解码为RGBA的颜色;</li><li>UnityWorldSpaceLightDir 给定对象空间的顶点位置到光源的世界坐标空间方向;</li><li>ObjSpaceLightDir: 给定对象空间的顶点位置到光源的对象空间方向;</li></ul><h2 id="UsePass-通道-复用"><a href="#UsePass-通道-复用" class="headerlink" title="UsePass(通道) 复用"></a>UsePass(通道) 复用</h2><blockquote><p>使用复用之后的shader就算通过代码修改值，他们也只有一种shader效果，复用就算复用不能产生两种效果</p></blockquote><ul><li>编写过的pass可以重复使用,借助<code>UsePass &quot;ShaderPath/PASS_NAME&quot;</code></li><li>PASS名字要大写;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先给一个Pass(通道)一个名字 ONE</span><br><span class="line">Pass &#123;</span><br><span class="line">    name &quot;ONE&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 复用Pass(通道)</span><br><span class="line">UsePass &quot;Custom/ShaderName/ONE&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="multi-compile-编写不同版本的shader"><a href="#multi-compile-编写不同版本的shader" class="headerlink" title="multi_compile(编写不同版本的shader)"></a>multi_compile(编写不同版本的shader)</h2><ul><li>通过<code>multi_compile</code>编译多个版本的<code>shader</code>;</li><li>定义编译多个版本的开关 定义两个版本开关<ul><li><code>#pragma multi_compile MY_multi_1  MY_multi_2</code>;</li></ul></li><li>编写控制<ul><li><code>#ifdef MY_multi_1 #endif</code></li><li><code>#ifdef MY_multi_2 #endif</code></li></ul></li><li>使用控制<code>shader</code>编译出不同的版本 C#中控制<ul><li><code>Shader.EnableKeyword(&quot;MY_multi_1&quot;);</code> 打开 MY_multi_1</li><li><code>Shader.DisableKeyword(&quot;MY_multi_2&quot;);</code> 关闭 MY_multi_2</li></ul></li></ul><h2 id="移动平台优化"><a href="#移动平台优化" class="headerlink" title="移动平台优化"></a>移动平台优化</h2><ul><li>代码优化: <ul><li>预先计算好对应的值 sqrt(2) –&gt; 根号2 –&gt; 1.414..;</li><li>放心的使用向量相关操作，叉积,点击,基本都是硬件实现，很高效; </li><li>尽量减少函数调用减少开销;</li></ul></li><li>尽可能的计算放在顶点着色器中，顶点着色器的调用频率远低于片着色器；</li><li>几何复杂度考量：在IOS平台视口内的顶点数不要超过100K个，IOS默认的缓冲区就是就是这么大，超过这个数字，底层会做一些操作消耗更多的资源；</li><li>纹理大小为 2^n次方大小, 16, 64, 128, 256, 512, 1024;</li><li>使用适当的数据类型float &lt; half &lt; fixed(定点数); 性能</li><li>尽量慎用透明效果,透明效果GPU要逐像素渲染;</li></ul><h1 id="第四十五课（unity-天空盒3D拾取本地存储）"><a href="#第四十五课（unity-天空盒3D拾取本地存储）" class="headerlink" title="第四十五课（unity_天空盒3D拾取本地存储）"></a>第四十五课（unity_天空盒<em>3D拾取</em>本地存储）</h1><h2 id="天空盒（也是种材质-skybox）"><a href="#天空盒（也是种材质-skybox）" class="headerlink" title="天空盒（也是种材质 skybox）"></a>天空盒（也是种材质 skybox）</h2><ul><li>一个场景是由6幅正方形的纹理图无缝拼接而成, 在视野看来位于真实的视野一样;</li><li>两种天空盒: <ul><li>场景天空盒 Window-&gt;Lighting-&gt;Scene-&gt;Skybox,切换摄像机场景不改变;</li><li>摄像机天空盒: 摄像机上添加天空盒组件，切换摄像机，天空盒被切换; </li></ul></li></ul><h2 id="3D拾取"><a href="#3D拾取" class="headerlink" title="3D拾取"></a>3D拾取</h2><ul><li>游戏中需要用户触摸/点击 操作3D世界里面的3D物体，那么需要判断用户点击的是3D中的哪个物体;</li><li>3D拾取的原理: 从摄像机到屏幕空间的触摸点发出一条射线，这条射线第一个撞到哪个3D物体就会认为哪个3D物体被用户选择;</li><li>代码编写<ul><li>发射一条射线: Ray ray = Camera.main.ScreenPointToRay(Touch.position); </li><li>检测撞到那个物体: Raycast hit; bool Physics.Raycast(ray, out hit);</li><li>hit.transform, 获得物体的transform组件, name可以获得被碰撞的物体的名字;</li><li>Camera.main获取当前我们的主Camera</li><li>如果要拾取，需要有一个碰撞器</li></ul></li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul><li>PlayerPrefs类: 游戏开发中需要存储本地数据，借助这个能够实现本地存储;</li><li>PlayerPrefs主要方法:<ul><li>SetInt/SetFloat, SetString:   key–&gt;value</li><li>GetInt/GetFloat, GetString: key–&gt;value;</li><li>DeleteKey/DeleteAll 删除一个key/所有数据;</li><li>HasKey 判断一个Key是否存在;</li><li>Save 保存数据;</li></ul></li></ul><h1 id="第四十六课（unity-2D-3D声音的使用）"><a href="#第四十六课（unity-2D-3D声音的使用）" class="headerlink" title="第四十六课（unity_2D_3D声音的使用）"></a>第四十六课（unity_2D_3D声音的使用）</h1><blockquote><p>2D全局声音，3D有距离衰减</p></blockquote><ul><li>声音<ul><li>背景音乐</li><li>音效;</li></ul></li><li>声音文件支持的格式<ul><li>ogg</li><li>mp3</li><li>wave</li><li>AIFF</li></ul></li><li>音频管理器<blockquote><p><code>Edit--&gt;ProjectSetting--&gt; Audio</code></p><ul><li>Volume: 全局播放的音量;</li><li>RolloffScale: 衰减因子，越大，声音衰减越快；</li><li>Doppler Factor: 多普勒因子;模拟多普勒效应的监听效果:0关闭, 1 高速物体的多普勒效应会 比较明显的监听的到;</li><li>Default Speak Mode: 设想扬声器模式;默认值为2(立体声, AudioSpeakModer);</li><li>SampleRate: (输出采样率);</li><li>DSPBufferSize: 调整DSP缓冲区大小优化延迟和性能;</li><li>Virutal(虚拟)/RealVoliceCount(真实): 同时播放的真实声音的数量;</li><li>DisableAudio: 警用音频;</li></ul></blockquote></li></ul><h2 id="音频监听器"><a href="#音频监听器" class="headerlink" title="音频监听器"></a>音频监听器</h2><blockquote><p><code>Audio Listener</code>,在主摄像机上面已经有了<br>就跟我们<strong>耳朵</strong>一样,有距离而衰减(远小近大)</p></blockquote><ul><li>音频监听器在3D世界中扮演话筒的角色，他接受场景中输入的音频源，通过设备的扬声器来播放声音;</li><li>当一个音频监听器挂载到场景中的一个游戏对象上，任何音源如果接近音频监听器，都会输出到计算机的扬声器中,每个场景中只能有一个音频监听器，一般会默认的添加到主摄像机上;</li><li>AudioClip: 声音文件</li></ul><h2 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h2><blockquote><p>来帮助我们播放AudioClip的</p></blockquote><ul><li>音频源: 在场景中播放音频剪辑,如果一个音频剪辑是一个3D，那么音频源就会在给定的位置，然后随着距离进行衰减,还可以在3D和2D之间进行切换;</li><li>创建一个音频源:<ul><li>导入要播放的声音文件;</li><li>创建一个节点，并加上Audio–&gt;Audio Source组件;</li><li>将AudioClip加入到AudioSource中；</li><li>代码控制播放;</li></ul></li><li>属性:<ul><li>AudioClip: 要被播放的文件;</li><li>Output: 音频剪辑通过音频混合器输出;</li><li>Mute: 是否静音;</li><li>Play On Wake：唤醒是否播放;</li><li>loop: 是否循环播放;</li><li>Priority: 播放的优先级，0最高，256最低(可以把很重要的优先级设置高一些)</li><li>Volume 音量 Pitch 音调 Stereo Pan立体声(-1左声道, 1右声道)</li><li>Min/Max Distance 衰减距离的 开始结束, 最小距离(声音保持最大量),最大距离(不再衰减)</li><li>patial Blend(空间混合), 0为2D音效(不会随距离而衰减), 1为3D音效</li><li>Spread: (3D)立体声在扬声器空间中的传播速度;</li><li>Min Distance(3D) 声音衰减的最小距离</li><li>Max Distance(3D) 声音衰减的最大距离<blockquote><p>Audio Listener 到 音频的距离 如果他们距离超过最大距离，就会很小或听不见</p></blockquote></li><li>衰减模式: 对数，线性核自定义模式;</li></ul></li></ul><blockquote><p>AudioSettings类对声音全局设置类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取配置</span><br><span class="line">AuidoConfiguratio audio_config = AudioSettings.GetConfiguration</span><br><span class="line">// ... 省略修改</span><br><span class="line">// 修改之后用Reset设置好就行了</span><br><span class="line">AudioSettings.Reset(audio_config);</span><br></pre></td></tr></table></figure></p></blockquote><p>#　第四十七课（unity_水和雾特效）</p><h2 id="水"><a href="#水" class="headerlink" title="水"></a>水</h2><ul><li>Unity 自己实现了水的特效，帮助我们解决游戏中水的问题</li><li>Unity的水集成在了<code>Environment</code>的环境资源包里面，导入方法是 <code>Assert--&gt;Import--&gt;Environent</code>导入，需要正式版的才能看到这个菜单，我们使用别人导出来的package;</li><li>水分为Water与Water(Basic)两个文件夹，两个文件夹中都有一个Prefab预制体的文件，文件夹下面的有两个文件，对应Daytime(白天的水)和NightTimer(晚上的水),BasicX效果要差一些，但是占CPU比较低<blockquote><p>带Bsic的水质量低一些，相对的性能肯定好一些</p></blockquote></li><li>水是由Shader来实现的，所以要看一下水对应的shader，可以自己调节参数</li></ul><p>##　雾</p><p>开启Unity的雾模式</p><blockquote><p><code>window--&gt;Lighting--&gt;scene</code>勾选住<code>Fog</code></p><ul><li>Fog的模式：<ul><li>Linear 线性(默认)<ul><li>雾从start开始，接近end越浓</li></ul></li><li>Exponential <ul><li>可配置参数Density，雾的浓度，浓度越大，雾越大</li></ul></li><li>Exponential Squared<ul><li>可配置参数Density 越大表示雾越浓</li></ul></li></ul></li><li>Fog Color雾的颜色：可以配置雾的颜色</li></ul></blockquote><ul><li>RenderSettings类<ul><li>fogMode<ul><li>调整雾气的模式<code>enum FogMode</code></li></ul></li><li>fog的密度<code>fogDensity</code></li><li>start/end可通过fogStartDistance/fogEndDistance来设置</li><li>关闭雾<ul><li>fogMode = 0</li></ul></li></ul></li></ul><h1 id="第四十八课（unity-光照-二-）"><a href="#第四十八课（unity-光照-二-）" class="headerlink" title="第四十八课（unity_光照(二)）"></a>第四十八课（unity_光照(二)）</h1><ul><li>光照的本质:就是光的颜色和物体纹理的颜色的混合;<h2 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h2></li><li>点光源</li><li>定向光源</li><li>聚光灯</li><li><p>区域光源(只会对static的物体有效)</p><blockquote><p>区域光的范围会在场景中用黄色的光显示出来;z轴是光的方向; 光的强度会随距离衰减<br>  <strong>只能配合烘培GI使用</strong></p></blockquote><h2 id="发光材质-必须使用在static物体上才可以"><a href="#发光材质-必须使用在static物体上才可以" class="headerlink" title="发光材质(必须使用在static物体上才可以)"></a>发光材质(必须使用在static物体上才可以)</h2><blockquote><p>材质–&gt; Emission<br>Global Illumi –&gt; Baked<br>使用发光材质的物体就变成了一个发光体，只能对标记为static的物体有影响</p></blockquote><ul><li>发光材质也算是一种光源,通过给物体添加特殊的着色器，调节其自发光参数可以得到一个柔和的灯光效果。发光材质可以让物体表面发光，</li><li>发光材质也只能作用在被标记为static, 或LightStatic的物体上。光源的强度以2的次方速度衰减;</li></ul></li></ul><blockquote><p>区域光源和发光材质都是需要依赖于静态物体,只能配置烘焙GI使用</p></blockquote><h2 id="Light组件的参数"><a href="#Light组件的参数" class="headerlink" title="Light组件的参数"></a>Light组件的参数</h2><ul><li>Type: 灯光当前的类型;<ul><li>Directional: 光源为平行光</li><li>Point: 光源为点光源;</li><li>Spot: 光源为聚光灯;</li></ul></li><li>Baking: 全局光照模式 Realtime/Baked/Mix模式;</li><li>Range: 灯光所影响的最大访问，平行光不需要;</li><li>Color: 灯光发出光线的颜色;</li><li>Intensity: 灯光发射的明亮程度，0为关闭，1为最亮;</li><li>Bounes Intensity: 控制全局光照中光线的反弹强度。</li><li>Shadow Type: 灯光投影的阴影类型;</li><li>Cookie: 使用一个带有Alpha的纹理来制作一个遮罩，使光线在不同的地方有不同的亮度，当光源为点光源是必须为立方图纹理;</li><li>Draw Halo: 绘制光晕，如果勾选，光源会带有球形光晕;</li><li>Flare: (可选) 灯光耀斑，在光源位置绘制;</li><li>RenderMode: 灯光的渲染模式;<ul><li>Auto自动渲染模式,更具灯光亮度和当前设置的质量在运行时确定;</li><li>Important: 灯光会按照逐个像素渲染，用于重要的灯光特效;</li><li>Not Important: 灯光一最快的速度渲染;</li></ul></li><li>Culling Mask: 选择某些层(Layer)不受光源影响;</li></ul><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><blockquote><p>光照烘培出来的贴图，贴到模型物体上，减少运算负担，对静态物体有很好的效果;</p></blockquote><ul><li>光照贴图的烘培<ul><li>将不同的物体，和光源预先烘焙出来，生成一个光照贴图。</li><li>将要做光照烘培的物体配置成<code>Light static</code>模式;</li><li>将光源的Light组件上的<code>Baking</code>选为<code>Baked</code>;</li><li>打开烘培窗口<code>Window--&gt;Lighting</code></li><li>确认无误后，在Lighting窗口中的Scene面板中选择Build进行烘培, 将Auto(自动烘培)关闭;</li></ul></li></ul><h2 id="光照烘培的参数详解"><a href="#光照烘培的参数详解" class="headerlink" title="光照烘培的参数详解"></a>光照烘培的参数详解</h2><ul><li>Light过滤按钮:<ul><li>type: 设定灯光的类型,可以将灯光设置成平行光,点光源，区域光，聚光灯;</li><li>Baking: 光源的烘培模式;</li><li>Realtime:  对场景的物体都采取实时光照;</li><li>Baked: 对静态物体采用烘培光照，对非静态物体不起作用；</li><li>Mixed:对静态物体使用烘培光照，对非静态物体使用实时光照;</li><li>Bounce Intensity: 调节间接光的强度(从一个物体反射到另外一个物体上的光)</li></ul></li><li>Render过滤按钮:<ul><li>Lightmap static: 游戏对象是否为static /Lightmap static，如果是游戏对象参与到GI计算光照;</li><li>Scale In Lightmap: 该值影响了用于选中对象的lightmap的像素数目,默认值为1.0,每个对象所占的光照图像素的比例,可以通过它来优化光照，不重要对象减少比例，重要物体来获得更多的光照图像素来优化场景;</li><li>Preserve UV: 保护光照图UV，若模型没在3DMax等建模软件中展示UV，必须勾选住;</li><li>AutoUV Max Distance: 手动设置UV最大距离;</li><li>AutoUV Max Angle: 手动设置UV最大角度;</li><li>Important GI: 让自发光物体的照射范围更大;</li><li>Advance Parameters: 设置光照的质量;</li></ul></li><li>环境光照选项(Environment)<ul><li>Skybox: 场景中使用的天空盒;</li><li>Sun: 场景中的太阳光,可以为其指定一个固定的平行光源;</li><li>Ambient Source: 环境光的来源(默认天空盒);</li><li>Ambient Intensity: 环境光的强度;</li><li>Ambient GI: 指定环境光的光照模式是实时光照还是烘培,若两种GI模式都没有开启，该选项没有效果;</li><li>Reflection Source: 反射源,可以指定反射源氏天空盒或一个自定义的立体纹理图;</li><li>Reflection Instensity: 反射强度，可以设置来自天空盒或立体纹理图的反射强度;</li><li>Reflection Bounce: 反射计算的次数; </li></ul></li><li>Bake GI参数:<ul><li>Bake Resolution: 烘培的分辨率: 若该值为10，代表每一个单位分布10个纹理像素;</li><li>Blake Padding: 在LightMap中不同物体烘培图的间距;</li><li>Compress: 是否压缩光照贴图;</li><li>Ambient Occlusion: 烘培光照图产生一定数量的环境阻光,环境阻光计算每一点被一定距离内的其他物体或一定距离内自身物体的挡住的遮挡程度(用来模拟物体表面环境光以及阴影的覆盖比例,达到全局光照的效果);</li><li>Final Gather: 控制从最终聚焦点发射出的光线的数量，较高数值可以达到更好的效果;</li></ul></li><li>Other 设置可以设置光晕的效果;</li></ul><h1 id="第四十九课（unity光照-三-法线贴图与阴影设置详解）"><a href="#第四十九课（unity光照-三-法线贴图与阴影设置详解）" class="headerlink" title="第四十九课（unity光照(三)法线贴图与阴影设置详解）"></a>第四十九课（unity光照(三)法线贴图与阴影设置详解）</h1><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><ul><li>法线贴图是凹凸贴图技术上 的一种应用,有时也称为Dot3(仿立体)凹凸纹理贴图;</li><li><strong>法线贴图是在不增加多边形的情况下，增强模型的细节</strong>;</li><li>法线贴图是高精度模型导出来的一种贴图，作用到低精度jing’d度模型上面,增强低精度模型的细节同时，又能获取很好的性能;</li><li><p>法线贴图的使用:</p><ul><li>模型资源:<blockquote><p>美术提供</p><ul><li>低精度的模型</li><li>法线贴图(normal)</li><li>漫反射贴图(diffuse);   </li></ul></blockquote></li></ul></li><li><p>创建两个Shaders材质: </p><ul><li><code>Legacy Shaders/Diffuse</code>(漫反射贴图)</li><li><code>Legacy Shaders/Bumped Diffuse</code>(法线贴图)<ul><li>法线贴图的材质类型一定要是 <code>normalmap</code></li></ul></li></ul></li><li>代码切换材质:<ul><li>获取到材质然后materials使用new数值来确定需要使用多少个材质，需要多少就new多少个</li></ul></li></ul><h2 id="阴影的设置-光照"><a href="#阴影的设置-光照" class="headerlink" title="阴影的设置(光照)"></a>阴影的设置(光照)</h2><ul><li>unity可以通过修改阴影的参数来对阴影的质量进行设置;</li><li>unity使用阴影贴图来显示阴影的，阴影贴图可以看作是灯光投射到场景的阴影通过纹理贴图的形式表现出来;</li><li><p>阴影的质量取决于两个方面: </p><ul><li>贴图分辨率(Resolution)</li><li>阴影的类型(Type)<ul><li>Hard 硬件(GPU绘制 性能更好 不是所有显卡都支持硬件阴影绘制)<ul><li>硬阴影是GPU运算的，不影响CPU的性能和内存;hard比较生硬，但是软阴影比硬阴影要消耗更多的资源</li></ul></li><li>softer 软件(会影响CPU)<ul><li>处理更好，但是消耗也就更大<br>Resolution设置(默认设置的是Quality设置里面的):  </li></ul></li><li>低质量(Low Resolution)</li><li>中等质量(Medium Resolution)</li><li>高质量(High Resolution)</li><li>极高质量(Very High Resolution)<blockquote><p>越高，越清晰，消耗也越大;</p></blockquote></li></ul></li></ul></li><li><p>用户将阴影设置为 <code>Use Quality Settings</code>使用的是全局的设置参数:<br><code>Edit--&gt;Project Settings-&gt;Quality</code> 中和阴影相关的参数。</p></li><li><p>Shadows Type: 设置阴影的类型;</p></li><li>Shadow Resolution 阴影设置分辨率,分辨率越高，开销越大</li><li>Shadow Projection 阴影投射, 平行光的投射投影有两种: <ul><li>Close Fit渲染高分辨率阴影</li><li>Stable Fit渲染低分辨率阴影</li></ul></li><li>Shadow Distance: 相机阴影可见的最大距离,超过这个距离阴影不会被计算;提升性能，不会绘制超过范围的阴影</li><li>Shadow Casades : 阴影重叠，重叠数目越高，质量越好,开销越大;</li></ul><h2 id="阴影的优化"><a href="#阴影的优化" class="headerlink" title="阴影的优化"></a>阴影的优化</h2><ul><li>静态物体: 尽量使用光照贴图，将阴影预先烘培出来,不实时的计算阴影;</li><li>设置分辨率和阴影类型，适当降低开销，硬件阴影的消耗要比软件阴影的小;</li><li>设置阴影在摄像机范围的显示距离;</li><li>并非所有的显卡都支持硬件阴影,要做好测试;</li></ul><h1 id="第五十课（unity光照-四-渲染路径-颜色空间-Cookies-Flare-光照过滤）"><a href="#第五十课（unity光照-四-渲染路径-颜色空间-Cookies-Flare-光照过滤）" class="headerlink" title="第五十课（unity光照(四)渲染路径_颜色空间_Cookies_Flare_光照过滤）"></a>第五十课（unity光照(四)渲染路径_颜色空间_Cookies_Flare_光照过滤）</h1><h2 id="渲染路径和颜色空间"><a href="#渲染路径和颜色空间" class="headerlink" title="渲染路径和颜色空间"></a>渲染路径和颜色空间</h2><blockquote><p><code>Edit--&gt;ProjectSetting Player--&gt;Inspector--&gt;Other Setting --&gt; Rendering Path</code></p></blockquote><ul><li>Unity光影效果可以通过设置 渲染路径和颜色空间</li><li><strong>渲染路径(Rendering Path)</strong>: <strong>计算光照的着色方式</strong>;<ul><li><code>forward</code>: 着色时根据对应影响的灯光,每个光源着色一次,多个光源作用时会着色多次;<ul><li>优点: 快速，硬件要求低,快速的处理透明;</li><li>缺点: 每个光源都要有对应的成本,大量光源反而降低;</li></ul></li><li><code>Deferred</code>: 延迟渲染路径,将光的颜色着色到几何缓冲器,生成一个屏幕空间的贴图<ul><li>优点：大量 realttime 光源模式的时候更真实;</li><li>缺点：需要硬件水平要求高;</li></ul></li><li><code>Legacy Vertex Lit</code>: 顶点照明，所有的光照只会在顶点上计算<ul><li>优点：速度快，最广泛的硬件支持。</li><li>缺点：但是不支持阴影,法线贴图，灯光遮罩,高精度的高光等;</li></ul></li><li><code>Legacy Defferred</code>和<code>Defferfed</code>类似，但是是不一样的算法;Path`</li></ul></li><li><p><strong>颜色空间(Color Space)</strong>: 色彩空间决定采用哪种算法计算照明或材质加载时候的颜色混合</p><ul><li><code>Linear</code>颜色空间</li><li><code>Camma</code>颜色空间</li></ul></li><li><p>Cookies(光照过滤)</p><blockquote><p>会通过一张纹理图的Alpha通道来决定光照能透过什么光照射下来<br>  Cookies size 越小值越密集(控制密度)</p><ul><li>设置一下导入的纹理,在纹理属性的面板上选择Cookies <ul><li>配置好Cookies对应的光源类型(Light Type);  </li><li>可勾选住Alpha from Grayscale选项;</li></ul></li><li>在平行光源中只要把一张带着透明通道的纹理图或者灰度图拖动到光源上的Cookies上;</li></ul></blockquote></li></ul><h2 id="镜头光晕"><a href="#镜头光晕" class="headerlink" title="镜头光晕"></a>镜头光晕</h2><ul><li>镜头光晕又叫耀斑,模拟摄像机镜头内的一种光线折射的效果太阳对准摄像机镜头才有的效果));</li><li>耀斑的制作: <code>creator--&gt;Lens Flare</code>来制作一个耀斑，一般由美术和特效人员完成;</li><li>耀斑的使用(物体也可以加光晕): <ul><li>打开光源组件，将耀斑文件拖入到光源的<code>Flare</code>选项里面;</li><li>物体中添加耀斑组件<code>Lens Flare</code>然后关联耀斑文件资源;</li></ul></li><li><img src="unity学习笔记/50_1.png" alt="图片暂时没有哦"></li></ul><h1 id="第五十一课（unity光照-五-Stander着色器mobilediffuse着色器光探头的原理和使用）"><a href="#第五十一课（unity光照-五-Stander着色器mobilediffuse着色器光探头的原理和使用）" class="headerlink" title="第五十一课（unity光照(五)Stander着色器mobilediffuse着色器光探头的原理和使用）"></a>第五十一课（unity光照(五)Stander着色器<em>mobilediffuse着色器</em>光探头的原理和使用）</h1><ul><li><p>Mobile Diffuse</p><ul><li>漫反射着色器, 最简单的3D着色模式;</li><li>模型顶点，到顶点的纹理坐标，到着色的时候选择纹理上的颜色着色;</li><li>在光照之前，你把纹理本来的颜色着色上去，参数光照，漫反射部分;</li></ul></li><li><p>标准着色器(Standard)</p></li><li>基于物理学的着色是用模拟现实的方式呈现出材质和灯光之间的相互作用, 基于物理学的着色器给用户营造出连续性。;</li><li>为了表现出真实的灯光, 标准着色器模仿了能量存储(物体反射的光源不大于它接收的光源), Fresnel反射(视线不垂直于物体表面时夹角月小，反射越明显), 表面遮蔽;</li><li><p>Stander着色器的参数:</p><ul><li>Rendering Mode: 四种渲染模式;</li><li>Albedo: 漫反射纹理图,也可以设置颜色和透明度, 纹理颜色 + 调和颜色;</li><li>Metallic: 金属性，值越高，发射效果越明显;</li><li>Smoothness:影响反射时表面的光滑程度，值越高,反射效果越清晰;</li><li>Specular: 高光。颜色可以自行设置;</li><li>Normal Map: 法线贴图;</li><li>Height Map: 高度图, 通常是灰度图;</li><li>Occlusion: 环境遮罩贴图。</li><li>Emission: 自发光属性，开启后类是于一个光源，可以调节GI模式;</li><li>Detail Mask: 细节遮罩贴图。当某些地方不需要细节图，可以使用遮罩图进行设置。</li><li>Tiling: 贴图的重复次数;</li><li>Offset: 贴图的偏移量;</li><li>Secondary Maps: 细节贴图<blockquote><p>增强效果和细节</p></blockquote></li></ul></li><li><p>Rending Mode</p><ul><li>Standard Shader有四种渲染模式;<ul><li>Opaque 模式:这种模式代表该着色器<strong>不支持透明通道, 物体是完全不透明的</strong>;</li><li>Cutout 模式:这种模式下支持透明通道，<strong>要么就透明，要么就完全不透明</strong>,图片内容是否透明,由Albedo的Alpha值和Alpha Cutoff决定的。适合制作叶子，草灯，带有透明通道的图片但不希望出半透明效果的材质;</li><li>Fade 模式: 褪色模式,改模式下可以操作Albedo的Color的Alpha值来操作材质的透明度，比较适合做物体<strong>渐渐淡出的动画效果</strong>, <strong>当Alpha值降低了以后,表面的高光和反色也会变淡</strong>;</li><li>Transparent 模式: 这种模式下的材质通过Albedo的Color的Alpha值来操作材质的透明度<br>当物体为半透明的时候,<strong>表面的高光和反色不会变淡</strong>;<blockquote><p>Fade和Transparent的区别在于 表面的高光和反色前者会变淡，后者不会变淡</p></blockquote></li></ul></li></ul></li><li><p>Occlusion Map</p><blockquote><p>遮挡图,是一种模型的表面应该接受多少间接反射的图片<br>一个表面凹凸不平的物体,在其凹下的地方应该接受较少的间接光照，遮挡图是一张灰度图。</p><ul><li>白色(255)表示完全的间接照明</li><li>黑色(0)表示完全不接受间接照明;<br>通过灰度图来控制间接光照的多少，来让光照的模型更加真实</li></ul></blockquote></li><li><p>Secondary Maps</p><ul><li>又叫Detail Map,材质的次级贴图，又叫细节贴图,它的作用是展示第一组贴图中没有显示的材质细节效果, Unity允许用户在一个材质上添加一个次级的漫反射贴图和法线贴图;</li></ul></li></ul><h2 id="光探头"><a href="#光探头" class="headerlink" title="光探头"></a>光探头</h2><blockquote><p>如果场景使用了光照贴图(对静态物体进行了烘焙)，这时候我的游戏人物走到这个静态物体边，不会受到周围环境光照的影响，这肯定是不符合逻辑的,又不能使用实时计算光照(效率消耗比较高)，光探头就是用来做这个事情的。预先把这几个场景点放若干个采集点，人物就算走到已经使用了光照贴图的环境也会受光照的影响。<br><strong>光探头作用：主要用作在静态物体烘焙之后，使我们动态物体能更好的融入静态烘焙之后的环境，更加逼真的效果。</strong></p></blockquote><ul><li>光照贴图都是应用于静态物体，如果一个非静态物体在烘培好的Lighting map的场景中移动，这样的不能很好的融合到烘培好的场景中，最理想是实时计算，但是达不到理想的效果,针对这种提出光探头;</li><li>Light Probes 的原理是在场景中放上若干采样点，收集采样点的周围的光暗信息;然后在附近的几个点围城的区域内进行插值，将插值结果作用到动态物体上;</li><li>Light Probes应用细节:<ul><li>没有必要在光影无变化的区域内布置多个采样点;</li><li>在动态物体的活动空间来进行部署,不必要全部空间都部署;</li><li>在我们的一个节点上，添加<code>Light Probes Group</code>组件,来进行部署光d探头<ul><li>Add Probe 添加探头</li><li>Duplicate Selected 复制探头<blockquote><p>添加探头之后需要重新烘焙才能看出效果</p></blockquote></li></ul></li><li>在不同光影的区域内布置</li></ul></li><li>MeshRender上的光探头选项:<ul><li>Light Probes 选项的3个: <ul><li>off(关闭)    </li><li>Blend Probes(默认)反射探针将被启用。 </li><li>Use Proxy Volume(光照探头代理) <blockquote><p>指定光照探头。</p></blockquote></li></ul></li></ul></li></ul><h1 id="第五十二课（unity光照-六-反射探头的使用）"><a href="#第五十二课（unity光照-六-反射探头的使用）" class="headerlink" title="第五十二课（unity光照(六)反射探头的使用）"></a>第五十二课（unity光照(六)反射探头的使用）</h1><blockquote><p>在反射探头内的物体可被反射出来</p></blockquote><h2 id="反射探头"><a href="#反射探头" class="headerlink" title="反射探头"></a>反射探头</h2><blockquote><p>制作倒影</p></blockquote><ul><li>镜子金属等具有光滑表面的物体都会反射，而游戏中计算实时反射非常消耗CPU的资源,<br>unity5.0新增了一个反射探头的技术，通过采样点，生成反射Cubemap,然后通过特定的着色器从Cubemap中采样,就能显示反射效果了;</li><li>反射探头(Reflection Probe)的参数:<ul><li>type: 设置反射探头的类型<ul><li>baked 烘焙模式 静态</li><li>custom 烘焙模式多一些选项</li><li>realtime 实时模式</li></ul></li><li>Dynamic Object: 将场景中的没有标识为 Static的对象烘培到发射纹理中;</li><li>Cubemap: 烘培出来的立方体纹理图;</li><li>Refresh Mode 刷新模式: <ul><li>OnAwake只在唤醒时刷新</li><li>EveryFrame 每帧刷新</li><li>Via Scripts 有脚本控制;<br>Time slicing: 反射画面刷新频率: </li><li>All face at once: 9帧完成一次刷新(中等) </li><li>Individual Faces: 14帧完成刷新(性能消耗低) </li><li>no time slicing: 每帧刷新(性能消耗最大);</li></ul></li><li>Importance: 权重，根据权重来混合不同Probe的反射情况;</li><li>Intensity: 反射纹理的颜色亮度;</li><li>Box Projection: 若是勾选此项， Probe的Size和Origin会影响反射贴图的映射方式;</li><li>Size:该探头的区域大小，在该区域内所有的物体都会应用反射(需要Standard着色器);</li><li>Probe Origin: 反射探头原点,会影响到捕捉到的Cubemap;</li><li>HDR 生成Cubemap中是否使用高动态范围图像(High Dymainc Range)这也会影响探头的数据存储位置;</li><li>Shadown Distance: 在反射图中的阴影距离,超过该距离阴影不会被反射;</li><li>ClearFlags: 设置反射图中的背景是天空盒或者是单一的颜色;</li><li>Background: 设置背景的颜色;</li><li>Culling Mask: 反射剔除,决定哪些层的物体是否进行反射;</li><li>Using Occlustion Culling: 烘培时，是否启动遮挡剔除(一个物体被挡住看不见，是不会绘制的); </li><li>Clipping Plances: 反射的裁剪平面<ul><li>near </li><li>far</li></ul></li></ul></li></ul><h2 id="反射探头模式"><a href="#反射探头模式" class="headerlink" title="反射探头模式"></a>反射探头模式</h2><ul><li>Baked烘培模式: 类似于光照烘培，把反射探头设置好后,将反射信息烘培到CubeMap中，当游戏运行的时候直接使用烘培好的CubeMap;</li><li>Custom(自定义模式): 与Baked模式的探头的用法相同，需要手动烘培才能看到效果。Custom提供了更多的参数可以设置，如Dynamic Object，将非静态的物体烘培到发射图中，但是不会随着物体的移动而改变;CubeMap选项可以制定烘培出来的Cubemap;</li><li>Realtime模式: 可以实时的更新反射图,在这种类型的反射头不需要将被反射的物体勾选为Static, 能实时, 但是性能要求高;</li></ul><h2 id="位置大小"><a href="#位置大小" class="headerlink" title="位置大小"></a>位置大小</h2><ul><li>反射探头是由物体挂载<code>Relfection Probe</code>来决定的,位置设置完毕后需要设置大小;<ul><li>根据需要反射物体的大小对探针进行摆放,场景的中心，墙壁的角落, 若有一些物体比较小又有强烈的视觉效果(比如篝火), 就需要探头距离它很近能得到很好的反射效果;</li><li>放好探头后要设置探头的大小,探头的形状似一个轴对称的立方体,如果在立方体内有对应的着色器,其反射效果就会根据其所在的反射探头的区域进行显示。若有多个探头，根据权重进行混合;</li><li>默认情况下探头的原点是几何中心，可以通过<code>Probe Origin</code>参数进行偏移,一个大的物体来反射一个从边缘接近他的点。</li></ul></li></ul><h2 id="循环反射"><a href="#循环反射" class="headerlink" title="循环反射"></a>循环反射</h2><ul><li>循环反射: 两个物体可以都反射，那么就会形成循环反射 <code>interReflection</code></li><li>Unity不能无限循环下去，可以设置循环次数: <code>window--&gt;Lighting--&gt;Environment Lighting Reflection Bounes</code>来控制反射的次数, 最大反射次数为5次;</li></ul><h1 id="第五十三课（unity-光照系统-七-Realtime-BakedGI-预计算全局光照-全局光照详解）"><a href="#第五十三课（unity-光照系统-七-Realtime-BakedGI-预计算全局光照-全局光照详解）" class="headerlink" title="第五十三课（unity_光照系统(七)_Realtime_BakedGI_预计算全局光照._全局光照详解）"></a>第五十三课（unity_光照系统(七)_Realtime_BakedGI_预计算全局光照._全局光照详解）</h1><h2 id="全局光照-GI"><a href="#全局光照-GI" class="headerlink" title="全局光照 GI"></a>全局光照 GI</h2><ul><li>Realtime每帧都会计算光照,<strong>实时光照是不会反射的，所以它的光影显得单调</strong>;</li><li>Baked GI:通过烘培光照贴图的方式获得很好的光照效果，无法实时的改变光照;</li><li>预先计算全局光照: <code>Precumputed Realtime GI</code><blockquote><p>实时光照不能很好的显示间接光照的效果, 比如实时光照到一个红色的物体上。<br>红色物体发生反射,本来如果是实时不会有反射，如果使用预先光照，那么会预先计算好静态物体的反射, 让物体显示出间接光效果;</p></blockquote></li><li>环境光</li></ul><h2 id="预先计算全局光照-物体必须为Static，才能看到效果"><a href="#预先计算全局光照-物体必须为Static，才能看到效果" class="headerlink" title="预先计算全局光照(物体必须为Static，才能看到效果)"></a>预先计算全局光照(物体必须为Static，才能看到效果)</h2><blockquote><p>如果有光照射在一个物体上，这个物体会有反射光<br><strong>预先计算全局光照弥补了实时光照没有反射效果</strong></p></blockquote><ul><li>使用实时光照,编写场景;</li><li>开启预先光照选项 <code>Window ---&gt;Lighting--&gt;Scene面板--&gt;Precomputed Realtime GI</code>;</li><li><code>Bealtime resolution</code> 代表间接光照分辨率，值越高间接光照效果越明显;</li><li>运行场景，看到光源角度变化后，场景中的光影效果也是实时的;</li><li>通过预先光照，有效的降低了原本要在游戏中实时计算的全局光照运算数量,若用户需要在游戏中频繁的对光源修改颜色，光源方向，光源强度，一般使用预先光照;</li><li>预先光照也是针对静态物体而言;对于动态物体时不会计算预先光照的;</li><li>实时光照 + 预先光照 对静态物体生成反射效果;</li></ul><h1 id="第五十四课（unity-Mesh网格的详解）"><a href="#第五十四课（unity-Mesh网格的详解）" class="headerlink" title="第五十四课（unity_Mesh网格的详解）"></a>第五十四课（unity_Mesh网格的详解）</h1><h2 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h2><p>1:Autodesk 3D Studio Max 支持mac os windows;<br>2: Autodesk 3D Maya 支持windows<br>3: Cinema4D 支持mac os windows<br>4: Blender 开源跨平台的全能三维制作软件, 支持mac os windows, linux;</p><blockquote><p>Blender 开源电影</p></blockquote><p>5: Cheetah3D: 支持mac os<br>6: Unity与建模软件的单位比例:<br>   unity系统单位为m, 建模软件的m的尺寸大小不一样，所以导入的时候有差异:</p><table><thead><tr><th>软件名</th><th>内部米</th><th>导入unity后的尺寸/m</th><th>与Unity单位的比例关系</th></tr></thead><tbody><tr><td>3Dmax</td><td>1</td><td>0.01</td><td>100:1</td></tr><tr><td>Maya</td><td>1</td><td>100</td><td>1:100</td></tr><tr><td>Cinema 4D</td><td>1</td><td>100</td><td>1:100</td></tr><tr><td>Light Wave</td><td>1</td><td>0.01</td><td>100:1</td></tr></tbody></table><h2 id="网格Mesh"><a href="#网格Mesh" class="headerlink" title="网格Mesh"></a>网格Mesh</h2><ul><li>Unity提供一个Mesh类，允许脚本来创建和修改，通过Mesh类能生成或修改物体的网格，能做出非常酷炫的物体变形特效;</li><li>Mesh Filter 网格过滤器从资源中拿出网格并将其传递给MeshRender,用于绘制, 导入模型的时候,Unity会自动创建一个这样的组件;<blockquote><p>Mesh Filter 网格是从这个模型文件里面来读取我们这个模型的数据，然后通过Mesh网格绘制出来</p></blockquote></li><li>Mesh 是网格过滤器实例化的Mesh, Mesh中存储物体的网格数据的属性和生成或修改物体网格的方法<blockquote><p>Mesh 网格负责绘制这个物体的</p></blockquote></li><li>顶点数组<vector3>:  每个顶点的x, y, z坐标。Vector3对象,面与面有共用的顶点,所以为了节约内存，先存顶点，然后再存三角形;</vector3></li><li>三角形索引数组<int>: Mesh里面每个三角形为一个面,由于面与面的顶点公用，所以，用索引来表示三角形的一个面，可以节约模型内存空间, 0, 1, 2面,对应的顶点时在顶点数组中的索引,<strong>三角形顶点的顺序为逆时针为正面</strong>。</int></li><li>顶点法线: 面的法线是与面垂直的线, 严格意义上讲，点是没有法线的, 在光照计算的时候,使用法线来进行光照计算，如果一个面上所有的法线都是一样，那么光着色也一样，看起来会很奇怪,所以通过某种算法，把多个面公用的顶点的法线根据算法综合插值，得到顶点法线;</li><li>顶点纹理坐标<vector2>: 顶点对应的纹理上的UV坐标;</vector2></li><li>顶点切线<vector4> 顶点切线;<h2 id="Mesh的重要属性"><a href="#Mesh的重要属性" class="headerlink" title="Mesh的重要属性"></a>Mesh的重要属性</h2></vector4></li><li>Mesh重要的属性:<ul><li>vertices 网格顶点数组;</li><li>normals 网格的法线数组;</li><li>tangents 网格的切线数组;</li><li>uv 网格的基础纹理坐标;</li><li>uv2 网格设定的第二个纹理坐标;</li><li>bounds 网格的包围盒;</li><li>Colors 网格的顶点颜色数组;</li><li>triangles 包含所有三角形的顶点索引数组;</li><li>vectexCount 网格中的顶点数量(只读的);</li><li>subMeshCount 子网格的数量，每个材质都有一个独立的网格列表;</li><li>bonesWeights: 每个顶点的骨骼权重;</li><li>bindposes: 绑定姿势，每个索引绑定的姿势使用具有相同的索引骨骼;</li></ul></li><li>Mesh重要的方法:<ul><li>Clear 清空所有的顶点数据和所有的三角形索引;</li><li>RecalculateBounds 重新计算网格的包围盒;</li><li>RecalculateNormals 重新计算网格的法线;</li><li>Optimze 显示优化的网格;</li><li>GetTriangles 返回网格的三角形列表;</li><li>SetTriangles 为网格设定三角形列表;</li><li>CominMeshes 组合多个网格到同一个网格;</li></ul></li></ul><h2 id="空物体通过用代码绘制模型"><a href="#空物体通过用代码绘制模型" class="headerlink" title="空物体通过用代码绘制模型"></a>空物体通过用代码绘制模型</h2><blockquote><p>获取Mesh Filter然后获取到模型数据,然后通过代码获取到Mesh模型数据，通过赋值重现模型</p><ul><li>先清空 Clear</li><li>再赋值<ul><li>vertices 网格顶点数组;</li><li>normals 网格的法线数组;</li><li>triangles 包含所有三角形的顶点索引数组;</li><li>uv 网格的基础纹理坐标;</li><li>tangents 网格的切线数组;</li></ul></li><li>再重新计算包围盒 RecalculateBounds</li><li>再配置MeshRender组件，配置好材质</li></ul></blockquote><h2 id="扩展三角形面"><a href="#扩展三角形面" class="headerlink" title="扩展三角形面"></a>扩展三角形面</h2><p><img src="unity学习笔记/54_1.png" alt="还没有图片哦"></p><h1 id="第五十五课（unity-旧版动画系统）"><a href="#第五十五课（unity-旧版动画系统）" class="headerlink" title="第五十五课（unity_旧版动画系统）"></a>第五十五课（unity_旧版动画系统）</h1><h2 id="旧版动画系统"><a href="#旧版动画系统" class="headerlink" title="旧版动画系统"></a>旧版动画系统</h2><blockquote><p>动画在Fbx模型里面，需要用美术给的动画帧数来切分动画。</p><ul><li>导入一个包含多个动画的模型文件;</li><li>选中模型文件的Rig tab Animation –&gt; Legacy模式(传统的/旧版);</li><li>根据美术给出的时间点，来分割动画;</li><li>Animation组件动画播放:<ul><li>Animation 启用自动播放时，播放的默认动画;</li><li>Animations 可以从脚本的访问的动画列表;</li><li>Play Automatically: 是否自动播放</li><li>Animate Physics 动画是否与物理交互;</li><li>Culling Type 设置动画的剔除模型: <ul><li>Always Animate总是播放动画, </li><li>Base On Renders 只有渲染在屏幕上的对象才会播放动画;</li></ul></li></ul></li></ul></blockquote><h2 id="代码播放"><a href="#代码播放" class="headerlink" title="代码播放"></a>代码播放</h2><ul><li>Animation类的Play: 播放指定名称的动画;</li><li>Animation类的Stop:  停止播放指定名称的动画;</li><li>Animation类的CrossFade动画融合: 以融合模式来切换动画;<ul><li>动画融合能确保动画完美的过渡,两个动作之间不会有突然切换;</li><li>第一个参数下一个播放的名字, 切换的时间间隔, 淡入淡出的模式;</li><li>淡出的模式: <ul><li>PlayMode.StopSameLayer 淡入新动画时，只淡出与name同一层的动画,</li><li>PlayMode.StopAll 淡入新动画时，淡出所有的动画;</li></ul></li></ul></li><li>动画混合:<br>  动画混合能消减游戏创建动画数量,让一些动画只应用给身体的一部分,和其它的动画配合一起使用。一个挥手动画，空闲挥手，和行走挥手，如果没有动画混合，就要为这个挥手创建2个动画，一个是空闲的挥手，一个是行走的挥手。<br>  AddMixingTransform 进行动画混合;</li></ul><h1 id="第五十六课（unity-mecanim人形动画系统-一-Avatar动画控制器）"><a href="#第五十六课（unity-mecanim人形动画系统-一-Avatar动画控制器）" class="headerlink" title="第五十六课（unity_mecanim人形动画系统(一)Avatar动画控制器）"></a>第五十六课（unity_mecanim人形动画系统(一)<em>Avatar</em>动画控制器）</h1><h2 id="Mecanim动画"><a href="#Mecanim动画" class="headerlink" title="Mecanim动画"></a>Mecanim动画</h2><ul><li>旧版动画系统只能通过代码来控制动画播放,随着动画种类变多，代码复杂度也会增加，同时动画过渡也需要非常繁琐的代码控制,为了让有经验的动画师开发动画，unity推出了针对人物角色的Mecanim动画系统;</li><li>Mecanim支持运动重定向(Retargeting)功能,即把动画从一个角色模型应用到另一个角色模型;</li><li>Mecanim允许使用“肌肉”来控制不同骨骼的运动范围;</li><li>Mecanim动画系统三要素:<ul><li>Avatar: 从Mecanim系统的简化人形骨架结构到用户实际提供的骨架结构的映射;</li><li>Animator Controller: 动画控制器用来控制动画的播放和过渡条件</li><li>Animation Clip: 动画剪辑;</li></ul></li></ul><h2 id="配置Avatar"><a href="#配置Avatar" class="headerlink" title="配置Avatar"></a>配置Avatar</h2><ul><li>导入模型后，将模型的动画模式配置成Humanoid模式。<ul><li>None: 无模式, </li><li>Legacy: 旧版动画模式, </li><li>Generic 其他动画模式, </li><li>Humanoid 人形角色动画模式; </li></ul></li><li>系统将会自动生成模型对应的Avatar文件, 并作为其子对象;</li><li><p>大部分情况下Mecanim都能正确的生成Avatar文件,                                           <img src="unity学习笔记/56_1.png" alt="图片还没有哦"></p><blockquote><p>Configure这个前面会有一个勾,点击Config,能查看到<br>映射情况,如果有错误,就没有勾,点击Config,手动做好人形骨骼的映射。<br>完整的是绿色的，有红色的说明就是没有关联好的</p></blockquote></li><li><p>Mapping:</p><ul><li>Clear清除映射, </li><li>AutoMap自动映射;</li></ul></li><li><p>如果骨骼绑定正确，但是角色姿势不对（不是标准的T形）,<br>在Scene中可看到消息“Character not in T-Pose”，解决此问题<br>可通过<code>Pose-&gt;Enforce T-Pose</code>或旋转其它的骨骼。</p><blockquote><p><img src="unity学习笔记/56_2.png" alt="图片还没有哦"></p></blockquote></li><li><p>Muscle配置:对于过于夸张的一些动作，可以通过对骨骼限定范围来进行调整，让这个骨骼运动在这个范围内，这样，就不用重新制作动画;</p><ul><li>点击要限制的骨骼;  </li><li>调整骨骼的运动范围的参数;          </li></ul></li></ul><h2 id="动画控制器配置"><a href="#动画控制器配置" class="headerlink" title="动画控制器配置"></a>动画控制器配置</h2><ul><li>动画控制器</li><li>动画层</li><li>动画状态机<ul><li>动画状态机必然包含有3个动画状态单元 Any State, Exit, Entry;</li><li>动画状态机可以包含多个动画状态单元;</li><li>还可以包含子动画状态机;</li></ul></li><li>动画状态单元的创建:<ol><li>Animator窗口中鼠标右键 在菜单中选择 Create State–&gt;Empty;</li><li>将动画文件拖入到Animator窗口;</li></ol></li><li>过渡条件连接:<br>  (1)将鼠标放在状态单元上,鼠标右键–&gt;Make Transition,创建动画过渡条件，并再次点击在另一个状态单元上，完成过渡条件连接;</li><li>默认动画单元: <ul><li>idle被设置为默认动画并显示为黄色, 其他动画显示为灰色,</li><li>也可以在任意非默认单元上右键 Set As Default来设置默认的动画;</li></ul></li></ul><h2 id="过渡条件"><a href="#过渡条件" class="headerlink" title="过渡条件"></a>过渡条件</h2><ul><li>动画状态机搭建完成后，需要编写过渡条件，对过渡条件设置来播放和过渡;</li><li>Mecanim支持过渡参数类型Float, Int, Bool, Trigger, Parameters添加对应类型的参数</li><li>选中任意一个过渡条件,在属性视图中的Conditions列表中点击”+”添加参数，并为参数添加对比条件。<br> Greator, Less;</li><li>代码里面设置过渡条件，来控制代码播放;</li></ul><h1 id="第五十七课（unity-人形动画重定向与动画混合树）"><a href="#第五十七课（unity-人形动画重定向与动画混合树）" class="headerlink" title="第五十七课（unity_人形动画重定向与动画混合树）"></a>第五十七课（unity_人形动画重定向与动画混合树）</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul><li>在人形动画系统中，所有的角色动画都属于unity定义的统一的人形，而我们的角色动画都是征询这个规矩做的，Avatar文件做好映射，那么如果我们是基于人形而调的骨骼动画，动画师调出了角色A的动画，那么角色B也可以使用这个动画师做好的动画，他们使用同样的动画和动画控制器，这样简化了动画的工作，解绑了动画师和建模师之间的工作依赖。</li><li>传统的动画，每个模型要做一个动画，而人形动画可以解决这个问题。</li><li>能够使包体大小变小。</li></ul><h2 id="角色动画的混合"><a href="#角色动画的混合" class="headerlink" title="角色动画的混合"></a>角色动画的混合</h2><ul><li>游戏开发过程中,有时候会有将两个动画混合成一个动画的需求,比如编写一个边跑边招手的动作,开发好了跑步的动作，和招手的动作，按照传统的方式需要重新再开发一个动作，Unity提供了角色动画的混合，能把两个动画合成一个新的动画;</li><li>混合动画基于混合动画树完成，混合动画树是 动画状态的其中一种，可以加入到动画状态机，可以看作是混合后新的一个动画;</li><li>创建步骤: <ul><li>创建Blend Tree,  create—&gt; From New Blend Tree,</li><li>添加要混合的动画到动画列表，可以添加，也可以删除;</li><li>配置混合参数，来进行混合。</li><li>BlendTree支持子树</li></ul></li></ul><h2 id="动画混合算法"><a href="#动画混合算法" class="headerlink" title="动画混合算法"></a>动画混合算法</h2><ul><li>1D混合方式: 最简单常用的混合方式,每个被混合的子动画都会被分配一个可以修改的Float的值,开发人员可以修改这个值来改变混合动画的效果，混合结果中比例越大，就越靠近那个动画;</li><li>2D Simple Directional混合方式:以两个混合参数作为混合结果的横竖坐标值,混合的动画以正方形的方式混合在面板中。各自的混合比例用正方型外围的圆圈表现出来;每个动画的分布也以颜色的深浅表现出来;</li><li>2D Freeform Directional混合方式:每个源动画都有一个放射性的显示面板,颜色越白权重越大。反之越小,可以通过移动源动画点，对现实面板进行调整;</li><li>2D Freeform Cartesian混合方式: 源动画相连渐变表示,混合面板中颜色的深浅表示了各自动化的在混合动画中的权重;</li></ul><h1 id="第五十八课-unity-动画单元代码控制-代码生成动画控制器"><a href="#第五十八课-unity-动画单元代码控制-代码生成动画控制器" class="headerlink" title="第五十八课(unity_动画单元代码控制_代码生成动画控制器)"></a>第五十八课(unity_动画单元代码控制_代码生成动画控制器)</h1><h2 id="动画状态代码控制"><a href="#动画状态代码控制" class="headerlink" title="动画状态代码控制"></a>动画状态代码控制</h2><ul><li>每个动画状态，比如进入状态，离开状态, 等都有可能需要代码来参与和处理，比如，进入这个动画单元后做哪些事情，来开这个动画单元后做哪些事情，为了解决这个问题,unity允许每个动画单元来绑定一个脚本代码，这个脚本代码必须继承于StateMachineBehaviour;</li><li>可以在动画状态的Add Behaviour上添加挂载一个脚本到动画状态;</li><li>StateMachineBehaviour主要接口:<ul><li>OnStateEnter: 当动画开始播放的时候被调用;</li><li>OnStateUpdate: 每帧都会被调用;</li><li>OnStateExit:  当动画结束播放的时候被调用;</li><li>OnStateMove: 当动画被移动的时候调用;</li><li>OnStateIK: 当动画触发逆向运动学时调用此方法;</li></ul></li></ul><h2 id="代码生成动画控制器"><a href="#代码生成动画控制器" class="headerlink" title="代码生成动画控制器"></a>代码生成动画控制器</h2><blockquote><p>10个状态，每2个状态之间需要建立两两的联系，那么这个动画控制器就会有100个过渡条件，那么这个时候最好的方式是代码自动的生成动画控制器;</p></blockquote><ul><li>扩展编辑器，来动态生成这个动画控制器，不用手动的去修改;</li><li>扩展编辑器的相关的API:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// CreateAnimCtrl.cs</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEditor.Animations;</span><br><span class="line"></span><br><span class="line">// 添加菜单选项 // 例如 Assets/Create/CreateAnimCtrl</span><br><span class="line">[MenuItem(&quot;菜单路径&quot;)]</span><br><span class="line"></span><br><span class="line">static void Run()&#123;</span><br><span class="line">    // 入口函数</span><br><span class="line">    Debug.Log(&quot;called...&quot;);</span><br><span class="line"></span><br><span class="line">    // Step1 生成我们的动画控制文件(动画控制器)</span><br><span class="line">    // Assets/res/code_anim.controller 创建的文件路径以及名字</span><br><span class="line">    AnimatorController ctrl  = UnityEditor.Animations.AnimatorController.CreateAnimatorControllerAtPath(&quot;Assets/res/code_anim.controller&quot;);</span><br><span class="line">    // Step2 获取我们的动画状态机</span><br><span class="line">    AnimatorStateMachine state_machine = ctrl.layers[index].stateMachine;</span><br><span class="line"></span><br><span class="line">    // Step3 创建我们的动画状态</span><br><span class="line">    AnimatorState[] state = new AnimatorState[10];</span><br><span class="line">    for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line"></span><br><span class="line">        // 添加进状态机里面</span><br><span class="line">        state[i] = state_machine.AddState(&quot;state&quot; + i);</span><br><span class="line"></span><br><span class="line">        // 加载AnimationClip:  path动画路径文件名  </span><br><span class="line">        AnimationClip anim = AssertDatabase.LoaderAssetAtPath(&quot;path&quot;, typeof(AnimationClip)) as AnimationClip;</span><br><span class="line">        // 为每个状态指定动画:</span><br><span class="line">        state[i].motion = anim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 两两动画组合过度</span><br><span class="line">    for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">        for(int j = 0;j &lt; 10;j++)&#123; // i --&gt; j Transition</span><br><span class="line">            // 创建每个过渡的控制变量</span><br><span class="line">            ctrl.AddParameter(i + &quot;switch&quot; + j, AnimatorControllerParameterType.Trigger);</span><br><span class="line"></span><br><span class="line">            // 添加每一个过度动画需要的条件</span><br><span class="line">            AnimatorStateTransition trans = state[i].AddTransition(state[j], false);</span><br><span class="line">            trans.AddCondition(AnimatorConditionMode.If, 0, i + &quot;switch&quot; + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置一个默认动画状态;</span><br><span class="line">    state_machine.defaultState = state[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第五十九课（unity-地形的创建）"><a href="#第五十九课（unity-地形的创建）" class="headerlink" title="第五十九课（unity_地形的创建）"></a>第五十九课（unity_地形的创建）</h1><h2 id="地形的基本组件"><a href="#地形的基本组件" class="headerlink" title="地形的基本组件"></a>地形的基本组件</h2><ul><li>创建一个地形Object:  GameObject—&gt; 3D Object–&gt;Terrain;</li><li>这个节点包含了两个组件,Terrain 和 Terrain Collider;</li><li>Terrain Collider 地形与物理引擎方面的组件,实现了地形的物理模拟,似的其他的挂载了物理碰撞器的物体能够与地形进行物理交互;</li><li>Terrain Collider的参数含义:<ul><li>Material: 该地形的物理材质, 通过改变参数可以分别开发出像戈壁滩，软草地之类的效果;</li><li>Terrain Data: 地形数据,用户存储该地形的地势以及其他的信息;</li><li>Enable Tree Colliders: 开启树木参与碰撞检测;(一般是去掉的)</li></ul></li><li>Terrain 组件中有一排按钮分别对应了地形引擎的各项操作和设置;</li></ul><h3 id="Terrain"><a href="#Terrain" class="headerlink" title="Terrain"></a>Terrain</h3><h4 id="Raise-And-Lower-Terrain-升高-下降地形"><a href="#Raise-And-Lower-Terrain-升高-下降地形" class="headerlink" title="Raise And Lower Terrain(升高/下降地形)"></a>Raise And Lower Terrain(升高/下降地形)</h4><ul><li>Brushes: 画笔样式，使用不同样式绘制对应的地形;</li><li>Brush Size: 画笔大小,其实际含义为画笔直径长度，单位为m;</li><li>Opacity: 画笔透明度,值越大，调整的强度越大，反之越小;</li><li>点击和拖动鼠标可以使得鼠标点过的地方突起，同时按下shift,可以实现下凹的功能;</li><li>没有经过操作的是没有办法拉低的，水平面是动不了的;</li></ul><h4 id="Paint-Height-涂料高度"><a href="#Paint-Height-涂料高度" class="headerlink" title="Paint Height(涂料高度)"></a>Paint Height(涂料高度)</h4><ul><li>Brushes: 画笔样式。使用不同的画笔样式，可以绘制出相应样式的地形;</li><li>BrushSize: 画笔的大小长度为米为单位;</li><li>Opacity: 画笔的透明度，值越大，调整的强度越大，反之越小;</li><li>Height: 制定高度值;</li><li>Flatten: 使得整个地形的高度值都设置为指定的高度值，使得整个上移和下沉;</li></ul><h4 id="Smooth-Height-平滑高度"><a href="#Smooth-Height-平滑高度" class="headerlink" title="Smooth Height(平滑高度)"></a>Smooth Height(平滑高度)</h4><ul><li>Smooth Height:在处理过程中某些地形比较突兀，山峰过于锐利,需要对地形做平滑处理</li><li>Brushes: 画笔样式。使用不同的画笔样式，可以绘制出相应样式的地形;</li><li>BrushSize: 画笔的大小长度为米为单位;</li><li>Opacity: 画笔的透明度，值越大，调整的强度越大，反之越小;</li></ul><h4 id="地形灰度图-导入灰度图制作地形，可以用psd文件"><a href="#地形灰度图-导入灰度图制作地形，可以用psd文件" class="headerlink" title="地形灰度图(导入灰度图制作地形，可以用psd文件)"></a>地形灰度图(导入灰度图制作地形，可以用psd文件)</h4><ul><li>Unity将内置的地形引擎将地形的高度信息以灰度的形式保存到一张灰度图里面;</li><li>优点:<ul><li>存储空间小; </li><li>和其他的地形工具配合使用;</li></ul></li><li>灰度图的使用:<ul><li>打开Photoshop, 设置图片的宽度为33x33(1 + 32 * x, 当x = 1时为33) 32的整数倍 + 1;</li><li>制作高度图片后，将图片保存为Raw的格式;</li><li>点击Terrain Setting: 导入(Heightmap–&gt;Import Raw)刚才生成的Raw格式的灰度图，然后就会生成相应的高度图</li><li>也可以把当前的地形到处高度图给其他的人使用;</li></ul></li></ul><h4 id="Paint-Texture（地形贴图）"><a href="#Paint-Texture（地形贴图）" class="headerlink" title="Paint Texture（地形贴图）"></a>Paint Texture（地形贴图）</h4><ul><li>设置好地形的贴图，画笔经过的地方，都会将纹理贴到对应的地形上;</li><li>Brushes: 画笔样式;</li><li>Textures: 可绘制的纹理;</li><li>BrushSize: 画笔大小;</li><li>Opacity: 画笔透明度，值越大调整的强度就越大，反之越小;</li><li>Target Strength: 画笔涂抹的强度值，改值得范围为0~1,代表了地形原来的混合比例;</li><li>Unity也支持psd图片的格式(Photoshop的源文件格式),打包的时候会生成图片。方便了开发;</li></ul><h4 id="Place-Trees（植树-可用预制体）"><a href="#Place-Trees（植树-可用预制体）" class="headerlink" title="Place Trees（植树 可用预制体）"></a>Place Trees（植树 可用预制体）</h4><ul><li>可以通过涂画的方式来对树木进行种植,只要提供单个树目，就可以铺设;</li><li>Place Trees 参数:<ul><li>Trees: 树木对象的预制体对象;</li><li>Brush Size: 画笔大小，单位为米;</li><li>Tree Density: 植树密度，每次植树时参生树木的棵数;</li><li>Tree Height: 树木的高度，可以指定也可以随机分配;</li><li>Lock Width to Height: 是否锁定横纵比例,保持原始高度;</li><li>Tree Width: 树木的宽度。</li></ul></li></ul><h4 id="Place-Details（植草-可以用psd文件-纹理-、预制体）"><a href="#Place-Details（植草-可以用psd文件-纹理-、预制体）" class="headerlink" title="Place Details（植草 可以用psd文件(纹理)、预制体）"></a>Place Details（植草 可以用psd文件(纹理)、预制体）</h4><ul><li>功能与Place Trees相似;</li><li>Place Details 参数:<ul><li>Brushes: 画笔样式;</li><li>Brush Size: 画笔大小，单位为米;</li><li>Details: 纹理对象列表。</li><li>Opacity: 画笔的透明度, 值越大，强度越大;</li><li>Target Strength: 画笔的涂抹强度,该值的范围为0~1。</li></ul></li></ul><h4 id="TerrainSettings"><a href="#TerrainSettings" class="headerlink" title="TerrainSettings"></a>TerrainSettings</h4><ul><li>Draw: 是否显示地形;</li><li>PixelError: 像素误差,地形的绘制精度，值越大细节越少;</li><li>Base Map Dist 基础图距, 当与地形距离超过该值时，则以低分辨率来显示(远处细节减少，节省性能);</li><li>Cast Shadows:是否进行阴影投射;</li><li>Materials: 材质类型: 标准，漫反射, 高光，自定义(自己指定材质);</li><li>Reflection Probes: 反射探头的类型: 关闭,混合探头, 混合以及天空盒探头,一般；</li><li>Tickness:物理引擎中该地形可碰撞的厚度;</li><li>Draw:  是否显示花草树木;</li><li>Bake Light Probes For Tree: 烘培光照探头到树木上;</li><li>Detial Distance: 细节距离，与相机键的细节可现实的距离值(超过这个距离不显示);</li><li>Collect Detail Patches: 进行细节补丁的收集;</li><li>Detail Density: 细节的密度程度;</li><li>Tree Distance: 树木的可视距离;</li><li>Billboard Start: 标志板的起点(公告板，总是在最前，有的树可以调整距离让它一直在前，节约性能，因为只用了一张图片就可做出树木的效果)，比标志版形式出现的树木与摄像机的距离;</li><li>Fade Length: 渐变长度;</li><li>Max Mesh Trees:允许出现的网格类型的树木的最大数量;</li><li>Speed: 风吹过草地的风速;</li><li>Size: 模拟风能影响的范围;</li><li>Bending:草被封能吹弯的程度;</li><li>Grass Tint: 草地总着色量的值;</li><li>Terrain Width/Height/Length 地形的宽度/高度/总长度;</li><li>Heightmap Resolution地形灰度值的精度;</li><li>Detial Resolution: 细节精度值，越大，细节越精细;</li><li>Detial Resolution per patch: 每小块地形设置的精度值;</li><li>Control Texture Resolution: 将不同的纹理插值绘制到地形上时设置的精度值;</li><li>Base Texture Resolution:在地形上绘制基础纹理时采用的精度值;</li><li>Heightmap 高度图</li></ul><h1 id="第六十课（拖尾渲染器的使用）"><a href="#第六十课（拖尾渲染器的使用）" class="headerlink" title="第六十课（拖尾渲染器的使用）"></a>第六十课（拖尾渲染器的使用）</h1><h2 id="拖尾渲染器-Trall-Renderer"><a href="#拖尾渲染器-Trall-Renderer" class="headerlink" title="拖尾渲染器(Trall Renderer)"></a>拖尾渲染器(Trall Renderer)</h2><ul><li>游戏中炮弹后面的拖尾, 以及汽车轮胎拖痕等绚丽特效,unity提供了拖尾渲染器;</li><li>拖尾渲染器的属性:<ul><li>Materials: 用户渲染拖尾的材质数组。</li><li>Size: 在材质数组总共有多少元素。</li><li>Element 0:用户渲染拖尾的材质的引用;个数由Size决定;</li><li>Time:  拖尾的长度,以s为单位;</li><li>Start Width: 开始位置拖尾的宽度;</li><li>End Width: 结束位置的拖尾宽度;</li><li>Colors: 拖尾长度颜色渐变的拖尾数组,也可以在这些颜色中使用Alpha;</li><li>Color0 ~Color4 拖尾的颜色，从开始到结束;</li><li>Min Vertex Distance:  拖尾锚点之间的最小距离（越小精度越高，性能也就差一些，越大精度越低）;</li><li>AutoDesturct: 将这一项设置为允许,来使物体在静止时候后拖尾即将被销毁;</li></ul></li></ul><h2 id="使用事项"><a href="#使用事项" class="headerlink" title="使用事项"></a>使用事项</h2><ul><li>Materials材质:<br>  使用一个包含粒子着色器的材质，材质使用的贴图必须是平方尺寸,在size属性中可以设置材质的个数,在Element属性中添加材质;</li><li>Trail Width: 拖尾宽度，配合时间属性可以调节他显示和表现;</li><li>Trail Colors: 通过5种颜色和透明度组合循环变化拖尾,使用这些颜色能控制头部和尾部之间进行渐变;</li><li>Min Vertex Distance最小顶点距离;<br>  最小顶点距离决定了包含拖尾的物体在一个拖尾段实例化之前必须经过的距离,较小的值将更频繁的创建拖尾段, 生成更平滑的拖尾，性能有损失，较大的值将显示出更多的锯齿段,找一个满足效果的最大的值;</li><li>使用注意:<ul><li><strong>使用拖尾渲染器不能使用其他的渲染器</strong>,(一般创建一个空节点，添加拖尾渲染组件,将拖尾要跟随的物体设置为拖尾的父亲)</li><li>最好使用粒子材质，这样可以达到更好的效果;<br><img src="unity学习笔记/60_1.png" alt="还没有图片哦"></li></ul></li></ul><h1 id="第六十一课（unity-navmesh网格导航寻路）"><a href="#第六十一课（unity-navmesh网格导航寻路）" class="headerlink" title="第六十一课（unity_navmesh网格导航寻路）"></a>第六十一课（unity_navmesh网格导航寻路）</h1><h2 id="烘焙网格导航"><a href="#烘焙网格导航" class="headerlink" title="烘焙网格导航"></a>烘焙网格导航</h2><ul><li>将地图元素标记为 <code>Navigation Static</code></li><li>调出Navigation 导航窗口,<code>Window--&gt;Navigation</code>, 在改窗口下按下Bake按钮,进行网格导航烘培;<br>  <img src="unity学习笔记/61_1.png" alt="还没有图片哦"><br>  <img src="unity学习笔记/61_2.png" alt="还没有图片哦"></li><li>被标记为<code>Navigation Static</code>的对象，都会出现青色的导航网格层,同时在Assets目录下会生成Pathing文件<code>NavMesh.asset</code></li></ul><h2 id="Nav-mesh-agent（代理器挂载到要寻路的物体）"><a href="#Nav-mesh-agent（代理器挂载到要寻路的物体）" class="headerlink" title="Nav mesh agent（代理器挂载到要寻路的物体）"></a>Nav mesh agent（代理器挂载到要寻路的物体）</h2><ul><li>代理器,角色或NPC(非玩家控制角色)关联好这个组件就能够使用这个组件在在地图上行走;</li><li>nav mesh agent 参数:<ul><li>Radius 代理器半径;</li><li>Speed代理器移动速度;</li><li>Acceleration 代理器加速度;</li><li>Angular Speed代理器角速度;</li><li>Stop distance 代理器到达时与目标的距离; </li><li>Auto Tranver OffMesh Link 是否穿过自定义路线;</li><li>AutoBaking 是否自动停止无法达到目的地的路线;</li><li>Auto Repath: 原有路线发生变化的时候，是否重新寻路;</li><li>Height: 代理器的高度;</li><li>Base Offset: 代理器相对导航网格的偏移;</li><li>Obstacle AvoidanceType: 代理器回避级别;</li><li>Avoidance Priority 代理器回避优先级;</li><li>Area Mask: 代理器可使用的导航网格层,unity对导航网格层以2^0, 2^1次对第0层第1层进行编码, Walkable是各层数据的和，比如3，可以在第0层和第1层移动;</li></ul></li></ul><h2 id="自定义路线-Off-Mesh-Link"><a href="#自定义路线-Off-Mesh-Link" class="headerlink" title="自定义路线(Off Mesh Link)"></a>自定义路线(Off Mesh Link)</h2><ul><li>为了满足复杂的地形而提供的特殊组件,开发人员可以自行设计所需路线,该路线会并入到导航网络中;一并参与寻路计算;</li><li>Off Mesh Link含义:<ul><li>Start:  定义路线的起始位置信息(有一个小圆圈，表示路搭好了);</li><li>End 自定义路线的目标位置信息(有一个小圆圈，表示路搭好了);</li><li>Cost Override: 自定义路线的成本覆盖;</li><li>Bi directional 自定义路线是否允许双线穿越（可走向start也可以走向end）;</li><li>Activated: 是否激活改路线;</li></ul></li><li>自定义Area Type:<ul><li>Walkable: 这个区域可以行走;</li><li>Not Walkable: 这个区域不可以行走;</li><li>Jump: 可跳过，将会自动生成auto-generated Off-Mesh Links<h2 id="动态障碍物（Nav-mesh-obstacle）"><a href="#动态障碍物（Nav-mesh-obstacle）" class="headerlink" title="动态障碍物（Nav mesh obstacle）"></a>动态障碍物（Nav mesh obstacle）</h2></li></ul></li><li>导航代理在移动过程中会忽略碰撞体，所以就会穿越动态的障碍物，为了防止这个情况的发生，Unity 3D提供了一个NavMesh Obstacle组件来提供对动态障碍物的支持,这样就可以设置英雄不被穿越的效果;</li><li>Navmesh obstacle 参数含义:<br> (1) Radius: 动态障碍物的半径;<br> (2) Height:   动态障碍物的高度;<br> (3) Move Threshold: 动态障碍物移动阈值;<br> (4) Carve: 是否允许被代理穿越;</li></ul><h1 id="第六十二课（unity-协程-多线程-WWW类）"><a href="#第六十二课（unity-协程-多线程-WWW类）" class="headerlink" title="第六十二课（unity_协程_多线程_WWW类）"></a>第六十二课（unity_协程_多线程_WWW类）</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li>在主进程中开启另外一段逻辑处理，来协同当前程序的执行,但与多线程不同都是在主线程里面执行的,通过StartCoroutine方法来启动一个协程;</li><li><p>StartCoroutine是MonoBehaviour的一个方法,改方法可以启动一个协程,协程必须要是一个<br>IEnumerator 作为返回值的方法;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 用协程的方式来执行这个函数(这个协程)</span><br><span class="line">StartCoroutine(fun_name());</span><br><span class="line"></span><br><span class="line">// 协程的入口</span><br><span class="line">IEnumerator fun_name()&#123;</span><br><span class="line">    // 协程的代码</span><br><span class="line">    // yield中断协程程序</span><br><span class="line">    yield return null;</span><br><span class="line">    // 协程结束以后的代码</span><br><span class="line"></span><br><span class="line">    // 协程里面也可以启动协程</span><br><span class="line">    StartCoroutine(fun_other());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 协程的入口</span><br><span class="line">IEnumerator fun_other()&#123;</span><br><span class="line">    // 协程的代码</span><br><span class="line">    // yield中断协程程序</span><br><span class="line">    // 等3s再中断协程</span><br><span class="line">    yeild return new WaitForSeconds(3);</span><br><span class="line">    // 协程结束以后的代码 等待3s再执行后面的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>协同程序可以使用yield 关键字来中断协同程序;</p></li><li>协程也可以启动一个协程;</li><li>WaitForSeconds(): 等待多长时间后中断协程;</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>using System.Thread;</li><li>创建一个线程: (函数名就行了，不用括号)<ul><li>Thread r = new Thread(callback_name);  </li><li>r.start(); 启动运行线程;</li></ul></li><li>线程回掉函数 void run() {}</li><li>多个线程访问同一个数据的时候，会发生”冲突”(没有锁，如果两个线程同时修改这个公共数据，没有办法确定到底是哪一个线程修改的),需要线程安全的方式来访问;</li><li><p>线程锁是在访问公共数据的时候，先去获得这个锁，没有获得锁的线程将会被挂起,指导这个锁被释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">死锁</span><br><span class="line">    A线程拿了锁A，再等拿锁B</span><br><span class="line">    B线程拿了锁B，再等拿锁A</span><br><span class="line">    A等着，B也等着，就造成了死锁</span><br><span class="line">    解决方案：如果多个线程里面要获取多个锁的时候，为了避免死锁，要按相同的循序拿谁抢到就谁先执行</span><br><span class="line">    A线程拿了锁A，再等拿锁B</span><br><span class="line">    B线程拿了锁A，再等拿锁B(谁抢到就谁先执行)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 创建一个锁</span><br><span class="line">public static Object  o = new Object();</span><br><span class="line"></span><br><span class="line">lock(o) // 如果没有拿到这个锁 线程就会挂起等待，只有获取到了锁才会继续执行</span><br><span class="line">&#123; // 获得了这个锁</span><br><span class="line">//线程安全的执行代码</span><br><span class="line">&#125;;</span><br><span class="line">// 括号结束以后，就释放了这个锁，其他的线程就可以拿到这个锁</span><br></pre></td></tr></table></figure></li><li><p>线程休眠: Thread.Sleep(单位为ms);</p></li><li>多线程之间要避免死锁;</li></ul><h3 id="WWW网络类"><a href="#WWW网络类" class="headerlink" title="WWW网络类"></a>WWW网络类</h3><ul><li>WWW w = new WWW(url); 创建一个w</li><li>WWW(url)会在后台下载url数据;</li><li>yeild return w来在协程里等待下载完成;</li><li>完成后可以继续处理;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator http_baidu()&#123;</span><br><span class="line">    // 抓取百度网页</span><br><span class="line">    WWW w = new WWW(&quot;www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">    // 网络抓取是需要时间，在后台抓取网络数据，一段时候以后，才能完成抓取完整个数据</span><br><span class="line">    yeild return w;</span><br><span class="line"></span><br><span class="line">    // 抓取完成网络数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第六十三课（unity-AssetBundle的使用详解）"><a href="#第六十三课（unity-AssetBundle的使用详解）" class="headerlink" title="第六十三课（unity_AssetBundle的使用详解）"></a>第六十三课（unity_AssetBundle的使用详解）</h1><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><ul><li>Unity能用户存储资源的一种压缩格式的打包集合,他可以存任意一种Unity引擎可以识别的资源: 模型，音频，纹理图，动画, 开发者自定义的二进制文件; 安装包小，更新资源;</li><li>AssetBundle开发步骤:<ul><li>创建AssetBundle: 项目的资源打包AssetBundle的集合里面;</li><li>部署到web服务器, 让客户端下载我们的AssetBundle;</li><li>加载AssetBundle, 加载里面的资源;</li><li>卸载AssetBundle, 压缩包，镜像;</li></ul></li></ul><h2 id="AssetBundle创建"><a href="#AssetBundle创建" class="headerlink" title="AssetBundle创建"></a>AssetBundle创建</h2><ul><li>Assets窗口的资源才可以打包;</li><li>创建一个AssetBundle文件,它的名字固定式小写如果有大写系统也会换成小写;</li><li>AssetBundle可以设置一个Varaint(资源类型)，就是一个后缀。可以通过后缀来设置不同分辨率的资源;</li></ul><h3 id="配置AssetBundle打包-将要打包的资源配置好即可"><a href="#配置AssetBundle打包-将要打包的资源配置好即可" class="headerlink" title="配置AssetBundle打包(将要打包的资源配置好即可)"></a>配置AssetBundle打包(将要打包的资源配置好即可)</h3><ul><li>将一个资源打入到AssetsBundle: 点击资源，选择对应的AssetBundle就可以了;<ul><li><img src="unity学习笔记/63_1.png" alt="还没有图片哦"></li></ul></li><li>编写代码导出AssetBundle文件:<ul><li>using UnityEditor; 引入编辑器操作的名字空间; 继承Editor</li><li>调用Api:<ul><li>BuildPipeline.BuildAssetBundles(outpath, BuildAssetBundleOptions, BuildTarget);<ul><li>outpath 打包好的资源路径<blockquote><p>文件夹的路径需要手动创建，否者会报错;</p></blockquote></li><li>BuildAssetBundleOptions 一般设置为None就好 </li><li>BuildTarget 打包好的资源准备在哪一个平台上用(windows、ios、android…)</li></ul></li></ul></li></ul></li></ul><h3 id="使用buildmap来对指定的资源进行打包"><a href="#使用buildmap来对指定的资源进行打包" class="headerlink" title="使用buildmap来对指定的资源进行打包;"></a>使用buildmap来对指定的资源进行打包;</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// outpath 打包好的资源路径 文件夹的路径需要手动创建，否者会报错;</span><br><span class="line">BuildPipeline.BuildAssetBundles(outpath, AssetsBoundlesBuild[], BuildAssetBundleOptions, BuildTarget);</span><br><span class="line"></span><br><span class="line">//定义AssetBuild数组</span><br><span class="line">AssetBundleBuild[] buildMap = new AssetBundleBuild[2]; </span><br><span class="line"></span><br><span class="line">//打包的资源包名称，开发者可以随便命名</span><br><span class="line">buildMap[0].assetBundleName = &quot;resources&quot;;      </span><br><span class="line"></span><br><span class="line">//定义字符串，用来记录此资源包文件名称</span><br><span class="line">string[] resourcesAssets = new string[2]; </span><br><span class="line">//将需要打包的资源名称赋给数组      </span><br><span class="line">resourcesAssets[0] = &quot;resources/1.prefab&quot;;                 </span><br><span class="line">resourcesAssets[1] = &quot;resources/MainO.cs&quot;;</span><br><span class="line"></span><br><span class="line">buildMap[0].assetNames = resourcesAssets;//将资源名称数组赋给AssetBuild</span><br><span class="line"></span><br><span class="line">//打包资源并导出</span><br><span class="line">BuildPipeline.BuildAssetBundles(&quot;Assets/AssetBundles&quot;, buildMap, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);</span><br></pre></td></tr></table></figure><h2 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h2><ul><li>创建一个webserver, 配置好静态路径的位置，将生成的AssetBundle拷贝到服务器上;</li><li>生成Url路径后测试AssetBundle下载;</li><li>课程以node.js的express框架搭建的webserver为例来进行部署;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建服务器目录--&gt;在目录打开命令窗口安装 npm install express 安装 express</span></span><br><span class="line"><span class="comment">// www_root 放置资源的文件夹</span></span><br><span class="line"><span class="comment">// 创建js文件编写代码进行部署服务器</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 把静态文件路径 设置成服务器路径</span></span><br><span class="line">app.use(express.static(path.join(process.cwd(), <span class="string">"www_root"</span>)));</span><br><span class="line"><span class="comment">// 启用6868端口</span></span><br><span class="line">app.listen(<span class="number">6868</span>); <span class="comment">// http://127.0.0.1:6868/bundle_test  bundle_test 包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在命令窗口执行js脚本</span></span><br><span class="line"><span class="comment">// 使用 http://127.0.0.1:6868/bundle_test 访问看是否能找到要下载的文件 如果找到了 说明部署成功</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="AssetBundle下载"><a href="#AssetBundle下载" class="headerlink" title="AssetBundle下载"></a>AssetBundle下载</h2><ul><li><p>非缓冲下载: 创建一个WWW的实例来下载AssetBundle;</p><ul><li>使用协程下载AssetBundle,</li><li>使用WWW的URL接口来下载;<blockquote><p>不能使用 WWW 对象去下载一个已经被加载进来的<code>AssetBundle</code>(使用www之前要确保支援已卸载干净);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写一个协程准备下载</span><br><span class="line">IEnumerator use_bundle()</span><br><span class="line">&#123;</span><br><span class="line">    WWW w = new WWW(&quot;http://127.0.0.1:6868/bundle_test&quot;);</span><br><span class="line"></span><br><span class="line">    yield return w;</span><br><span class="line"></span><br><span class="line">    // 内存镜像</span><br><span class="line">    AssetBundle assetBundle = w.assetBundle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul></li><li><p>缓冲下载(传一个版本号，版本号不一样才会去下载,这个版本号自己定的):</p><blockquote><p>下载之后存到本地，如果再次下载版本号没变就从本地获取</p></blockquote><ul><li>使用WWW类的<code>LoadFromCacheOrDownload</code>来实现下载AssetBundle, 当再次下载的时候，只有当版本低或不存在的时候才下载;<blockquote><p>web平台缓冲的大小是50M， IOS/android缓冲的大小为4GB;</p></blockquote></li></ul></li></ul><h2 id="AssetBundle加载使用-内存镜像"><a href="#AssetBundle加载使用-内存镜像" class="headerlink" title="AssetBundle加载使用(内存镜像)"></a>AssetBundle加载使用(内存镜像)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 内存镜像</span><br><span class="line">AssetBundle assetBundle = w.assetBundle;</span><br><span class="line">// 使用单个资源</span><br><span class="line">// 资源所在的路径名字可在打包好的 `*.manifest` 文件下看`Assets`下面就是文件列表</span><br><span class="line">assetBundle.LoadAsset(&quot;路径&quot;); </span><br><span class="line"></span><br><span class="line">// 加载所有的资源</span><br><span class="line">assetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure><blockquote><p>使用完记得卸载，看需求是全部卸载还是保留已加载的</p></blockquote><h2 id="AssetBundle卸载"><a href="#AssetBundle卸载" class="headerlink" title="AssetBundle卸载"></a>AssetBundle卸载</h2><ul><li>卸载<ul><li>AssetBoundle.Unload(false);<blockquote><p>false: 卸载内存镜像不卸载Asset内存实例;</p></blockquote></li><li>AssetBoundle.Unload(true);<blockquote><p>true: 卸载内存镜像以及Asset的内存实例;</p></blockquote></li></ul></li></ul><h1 id="第六十四课（专题-一-DOTween插件使用）"><a href="#第六十四课（专题-一-DOTween插件使用）" class="headerlink" title="第六十四课（专题(一)DOTween插件使用）"></a>第六十四课（专题(一)DOTween插件使用）</h1><blockquote><p>补间动画</p></blockquote><h2 id="安装DOTween"><a href="#安装DOTween" class="headerlink" title="安装DOTween"></a>安装DOTween</h2><ul><li><a href="http://dotween.demigiant.com/getstarted.php" rel="external nofollow noopener noreferrer" target="_blank">官网</a></li><li>将DOTween解压后复制到项目的任意目录下(Editor, Plugins or Resources除外);</li><li>运行DOTween的Setup: 菜单栏的 Tools/Demigiant;</li><li>在代码里面 加上  DOTween的名字空间 using DG.Tween;</li><li>安装完DOTween插件后，很多组件能够支持Tween;</li></ul><h2 id="DOTween组件扩展"><a href="#DOTween组件扩展" class="headerlink" title="DOTween组件扩展"></a>DOTween组件扩展</h2><ul><li>其他的组件扩展了Tween接口: <a href="http://dotween.demigiant.com/documentation.php" rel="external nofollow noopener noreferrer" target="_blank">详情见文档</a><ul><li>AudioMixer  </li><li>AudioSource</li><li>Camera</li><li>Light</li><li>Material:</li><li>Rigidbody: </li><li>Rigidbody2D:</li><li>Transfrom</li></ul></li><li>Transfrom组件:<blockquote><p>会返回一个Tweener t</p><ul><li>组件实例.DOMove: 平移;</li><li>组件实例.DOScale: 缩放;</li><li>组件实例.DORotate 旋转;</li></ul></blockquote></li></ul><h2 id="Tweener常用操作"><a href="#Tweener常用操作" class="headerlink" title="Tweener常用操作"></a>Tweener常用操作</h2><ul><li><p>常用的播放控制函数</p><ul><li>组件实例.DOPause();  暂停一个Tween;</li><li>组件实例.DOPlay/DOPlayBackwards/DOPlayForward; 播放/向后/向前</li><li>组件实例.DOKill; // 删掉Tween; 默认是自己删掉的</li></ul></li><li><p>设置循环次数</p><ul><li>t.SetLoop(num); <ul><li>num为-1，一直循环;</li></ul></li></ul></li><li>Tweener 常用的事件:<ul><li>OnStart(callback_name); 开始的时候</li><li>OnComplete(callback_name); 完成的时候</li><li>OnKill(callback_name); 删掉的时候</li><li>OnUpdate(callback_name); 播放的时候<blockquote><p>OnComplete，o如果是小写，直接 += 函数(跟委托一样)，如果是大写就填回调函数</p></blockquote></li></ul></li></ul><h2 id="Sequence队列"><a href="#Sequence队列" class="headerlink" title="Sequence队列"></a>Sequence队列</h2><ul><li>创建一个队列容器:  <ul><li>Sequence seq = DOTween.Sequence()</li></ul></li><li>将Tween加入到容器队列 <ul><li>seq.Append(tween);</li></ul></li><li>设置队列容器的循环次数;<ul><li>seq.SetLoops(num); num为-1，一直循环;</li></ul></li><li>插入一个并行的Tween<ul><li>seq.Insert(“插到哪一个位置”,Tween)</li></ul></li></ul><h2 id="Ease缓动效果"><a href="#Ease缓动效果" class="headerlink" title="Ease缓动效果"></a>Ease缓动效果</h2><ul><li>Tweener设置缓动动画:<ul><li>SetEase(效果类型,缓动的持续时间);</li></ul></li><li>效果类型:<ul><li>OutBack: 快速移动超出目标，然后慢慢回到目标点;</li><li>…..</li></ul></li></ul><h1 id="第六十五课（专题-二-游戏中的模型描边和Shader切换）"><a href="#第六十五课（专题-二-游戏中的模型描边和Shader切换）" class="headerlink" title="第六十五课（专题(二)游戏中的模型描边和Shader切换）"></a>第六十五课（专题(二)游戏中的模型描边和Shader切换）</h1><h2 id="模型描边"><a href="#模型描边" class="headerlink" title="模型描边"></a>模型描边</h2><blockquote><p>1: LOL里面的模型描边效果:<br><img src="unity学习笔记/65_1.png" alt="还没有图片哦"><br>2: 可以找到模型描边的Shader,推荐使用(Toony):<br>一组第三方的Shader, 帮我们解决了模型描边的问题 </p></blockquote><h2 id="代码里面切换Shader"><a href="#代码里面切换Shader" class="headerlink" title="代码里面切换Shader"></a>代码里面切换Shader</h2><blockquote><p>加载shader是会有开销的，如果这个shader没有使用，是会被释放的</p></blockquote><ul><li>关联要切换Shader的材质</li><li>代码加载对应的Shader:   Shader.Find(“Shader的名字”);</li><li>切换材质对应的Shader;  Matrix.shader = Shader</li></ul><blockquote><p>在运行的时候，去加载shader 耗CPU 预先把这个shader加载好就可以了，unity就有一个机制，把常用的shader设置告诉他，那么他会帮你把这个shader常驻内存。<br>常用的shader，提前加载好。</p></blockquote><ul><li>将最常用的Shader, 放到Unity的Always Include里 –&gt; 优化检查</li><li><code>Edit--&gt; ProjectSetting --&gt; Graphics   --&gt;   Always-included Shaders</code><blockquote><p>Specify a list of Shaders that will always be stored along with the project, even if nothing in your scenes actually uses them. It is important to add shaders used by streamed AssetBundles to this list to ensure they can be accessed. 让这些Shader很重要，在开始的时候加载，常驻内存;</p></blockquote></li></ul><h1 id="第六十六课（专题-三-常用数据结构与JSON处理）"><a href="#第六十六课（专题-三-常用数据结构与JSON处理）" class="headerlink" title="第六十六课（专题(三)常用数据结构与JSON处理）"></a>第六十六课（专题(三)常用数据结构与JSON处理）</h1><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><ul><li>类型[] 名字 = new  类型[数量]{“初始化的值”, “”, ‘’”}; 如果有初始值也可以省略大小;</li><li>优点:<ul><li>内存连续，速度快;</li></ul></li><li>缺点:<ul><li>大小固定;    </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string[] str = new string[]&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125; // string[3]</span><br><span class="line">int[] i = new int[100];</span><br></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote><p>灵活但是相对的性能会对应有所消耗</p></blockquote><ul><li>属于 System.Collections 命令空间</li><li>ArrayList l = new ArrayList();</li><li>操作:<ul><li>添加 Add(数据), 修改[index] = 内容</li><li>删除 RemoveAt(index)</li></ul></li><li>优点:<ul><li>不用固定大小;</li><li>可以存放任意类型;</li></ul></li><li>缺点<blockquote><p>把所有对象都当做Object来处理，读取的时候需要强制转换一下</p><ul><li>由于存放不同类型的数据，导致很多看不见的性能消耗, 多次转换等;</li></ul></blockquote></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List<t></t></h2><ul><li>属于 using System.Collections.Generic; 命令空间</li><li>List<t> l = new List<t>();</t></t></li><li>操作:<ul><li>添加 Add(数据),</li><li>修改[index] = 内容</li><li>删除 RemoveAt(index);</li></ul></li><li>优点:<ul><li>不用固定大小;</li><li>存储的类型是泛型模板，比较灵活, 每个对象实例只能存储一个类型;</li></ul></li></ul><h2 id="字典-Dictionary-lt-K-T-gt"><a href="#字典-Dictionary-lt-K-T-gt" class="headerlink" title="字典 Dictionary&lt;K, T&gt;"></a>字典 Dictionary&lt;K, T&gt;</h2><ul><li>属于 using System.Collections.Generic; 命令空间</li><li>Dictionary&lt;KT, VT&gt; l = new Dictionary&lt;KT, VT&gt;();  key –&gt; value</li><li>操作:<ul><li>添加 Add(数据)</li><li>修改[key] = 内容</li><li>删除 RemoveAt(index);</li></ul></li><li>优点:<ul><li>不用固定大小;</li><li>存储的类型是泛型模板，比较灵活, 每个dict只能存储一个类型;</li><li>key也是泛型 string, int …. </li></ul></li></ul><h2 id="json数据格式"><a href="#json数据格式" class="headerlink" title="json数据格式"></a>json数据格式</h2><ul><li>JSON (JavaScript Object Notation)<br>  随着JavaScript的流行与互联网应用，JavaScript里面最强大的数据类型Object，使用起来极其的方便，为了能更好的做数据交换，设计了JSON协议,能够将JavaScript里面的Object,变成可以阅读的文本数据及JSON数据格式。实现JavaScript里面的Object与JSON的转换，Object对象转换成JSON数据以后，方便传输与存储,JSON变为Object方便对象重建;</li><li>python语言, Lua语言等其它的脚本语言都有类是于JavaScript的Object数据结构，所以JSON数据能在其它的语言里面也非常方便的使用;</li><li>JSON采用完全独立于语言的文本格式(string)，易于阅读与编写以及解析与生成,在很多时候数据交换都采用JSON, 数据—&gt;JSON–&gt;传输,存储—&gt;解码JSON–&gt;数据</li><li>上面的过程又叫序列化与反序列化;</li></ul><h2 id="Json数据格式"><a href="#Json数据格式" class="headerlink" title="Json数据格式"></a>Json数据格式</h2><ul><li>JSON Object {};   里面为key: value;</li><li>value为数字, 11.0, 12, 0, <ul><li>value为bool true, false</li><li>value为数组 [ 值, bool, 数组, Object]</li><li>value 为Object { key: value}</li></ul></li><li>Unity 5.3.x以后自带的Json数据解析器</li><li>Unity 5.3以前可以使用第三方的C#库LitJSon;</li></ul><h2 id="Unity5-3-JSON序列化"><a href="#Unity5-3-JSON序列化" class="headerlink" title="Unity5.3 JSON序列化"></a>Unity5.3 JSON序列化</h2><ul><li>序列化与反序列化:  内存数据–&gt;文件存储介质;   文件存储介质—&gt;内存数据</li><li><p>Unity序列化:  </p><ul><li><p>把要序列化的对象声明称: </p><blockquote><p>只会序列化public的</p><ul><li>[System.Serializable], </li><li>using System; [Serializable]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[System.Serializable]</span><br><span class="line">class my_object&#123;</span><br><span class="line">    public int a = 10;</span><br><span class="line">    public int b = 20;</span><br><span class="line">    public string name = &quot;nihao&quot;;</span><br><span class="line">    // 不是public 又想序列化</span><br><span class="line">    [SerializeField] // 可序列化的字段</span><br><span class="line">    bool is_object = true;</span><br><span class="line">    public int[] int_array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JSON 序列化</span><br><span class="line">my_object obj = new my_object();</span><br><span class="line">obj.int_array = new int[]&#123;1,2,3&#125;;</span><br><span class="line"></span><br><span class="line">// 接收转换过来的json字符串</span><br><span class="line">string json_string = JsonUtility.ToJson(obj);</span><br><span class="line"></span><br><span class="line">// JSON反序列化</span><br><span class="line">my_object new_obj = new my_object();</span><br><span class="line">obj.int_array = new int[]&#123;1,2,3&#125;;</span><br><span class="line">// 把字符串json_string转换为Object并赋值到new_obj</span><br><span class="line">JsonUtility.FromJsonOverwrite(json_string, new_obj);</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>JsonUtility.ToJson(object); // 将对象(object)转成json字符串;</p></li><li>将Json字符串的数据覆盖到对象 JsonUtility.FromJsonOverwrite(json_str, obj);</li><li>当Unity序列化你的脚本的时候，它将仅仅序列化公有域。如果作为附加你也想要Unity去序列化你的一个私有域，你可以添加SerializeField（序列化域）属性给这个域。</li><li>JSON数组:   </li><li>JSON对象:</li></ul></li></ul><h1 id="第六十七课（专题-四-Unity常用目录和代码加载资源）"><a href="#第六十七课（专题-四-Unity常用目录和代码加载资源）" class="headerlink" title="第六十七课（专题(四)Unity常用目录和代码加载资源）"></a>第六十七课（专题(四)Unity常用目录和代码加载资源）</h1><h2 id="编辑器扩展目录（Editor）"><a href="#编辑器扩展目录（Editor）" class="headerlink" title="编辑器扩展目录（Editor）"></a>编辑器扩展目录（Editor）</h2><ul><li>Editor文件夹 <ul><li>Editor文件夹可以在根目录下，也可以在子目录里，夹就可以;</li><li>Editor下面放的所有资源文件或者脚本文件都不会被打进发布包中，并且脚本也只能在编辑时使用;</li><li>一些工具类的脚本放在这里，或者是一些编辑时用的DLL, 类似技能编辑器，那么编辑器的代码放在这里;</li></ul></li><li>Editor Default Resources<ul><li>Editor Default Resources 注意中间是有空格的, 它必须放在Project视图的根目录下</li><li>Editor Default Resources: 把编辑器用到的一些资源放在这里，比如图片、文本文件、等等; 和Editor文件夹一样都不会被打到最终发布包里，仅仅用于开发时使用;<br>EditorGUIUtility.Load来读取该资源:<br>TextAsset text = EditorGUIUtility.Load(“test.txt”) as TextAsset;</li></ul></li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li>Plugins 文件夹:<ul><li>如果做手机游戏开发一般 andoird 或者 ios 要接一些sdk 可以把sdk依赖的库文件 放在这里 比如 .so .jar .a 文件</li><li>该目录下的文件会被打包到安装包里面;</li></ul></li><li>StreamingAssets 文件夹:<ul><li>这个文件夹下的资源会全都打包在.apk或者.ipa</li><li>它不会压缩原封不动的打包进去</li><li>并且它是一个只读的文件夹，就是程序运行时只能读，不能写的</li><li>Application.streamingAssetsPath 它会根据当前的平台选择对应的路径，只可读不可写</li></ul></li></ul><h2 id="Resources目录"><a href="#Resources目录" class="headerlink" title="Resources目录"></a>Resources目录</h2><ul><li>可以在根目录下，也可以在子目录里，只要名子叫Resources就可以。比如目录：/xxx/xxx/Resources</li><li>Resources文件夹下的资源不管你用还是不用都会被打包进.apk或者.ipa,使用代码加载的资源必须放在Resouces目录下</li><li>Resource.Load ：编辑时和运行时都可以通过Resource.Load来直接读取<blockquote><p>尽量不要使用，因为不知道这个资源是否会放在 assetBundle 如果放在这里面那么Resources目录就要移出这个文件，如果移出了，那么使用这个读取到Resources目录下的资源文件不存在就会报错，不利于后期维护，所有我们会自己封装一个资源加载类我们的资源是从Resource目录下读取，还是assetbundle下读取;</p></blockquote></li><li>AssetDatabase.LoadAssetAtPath()：它可以读取Assets目录下的任意文件夹下的资源，它只能在编辑时用。它的路径是”Assets/xx/xx.xxx” 必须是这种路径，并且要带文件的后缀名;<blockquote><p>如果打包了，就不能用了</p></blockquote></li></ul><h2 id="Unity资源管理"><a href="#Unity资源管理" class="headerlink" title="Unity资源管理"></a>Unity资源管理</h2><ul><li>不在代码里面动态加载的，或放到assetBundle里的资源，尽量不要放在Resources文件夹下;</li><li>Resouces文件夹使用和不使用的资源都会被打入包中，所以在打包的时候，要把通过assetbundle来加载的资源或不使用的资源，移出Resources目录，然后再打包;</li><li>必须要封装一个资源加载的类，来封装好从Resource目录下读取，还是assetbundle下读取;</li></ul><h1 id="第六十八课（专题-五-移动的汽船）"><a href="#第六十八课（专题-五-移动的汽船）" class="headerlink" title="第六十八课（专题(五)移动的汽船）"></a>第六十八课（专题(五)移动的汽船）</h1><h2 id="船的虚拟摇杆移动"><a href="#船的虚拟摇杆移动" class="headerlink" title="船的虚拟摇杆移动"></a>船的虚拟摇杆移动</h2><p><img src="unity学习笔记/68_3.png" alt="图片还没有哦"></p><h2 id="船在水中的摇摆"><a href="#船在水中的摇摆" class="headerlink" title="船在水中的摇摆"></a>船在水中的摇摆</h2><p><img src="unity学习笔记/68_1.png" alt="图片还没有哦"></p><blockquote><p>r &gt;= 4 &amp;&amp; r &lt;= 180;左区间  r &lt; (360 - 4) &amp;&amp; r &gt;= 180 右区间</p></blockquote><h2 id="摄像机跟随"><a href="#摄像机跟随" class="headerlink" title="摄像机跟随"></a>摄像机跟随</h2><p><img src="unity学习笔记/68_2.png" alt="图片还没有哦"></p><h1 id="第六十九课（unity-专题-六-Unity道具金币拾取）"><a href="#第六十九课（unity-专题-六-Unity道具金币拾取）" class="headerlink" title="第六十九课（unity_专题(六)Unity道具金币拾取）"></a>第六十九课（unity_专题(六)Unity道具金币拾取）</h1><blockquote><p>分层<br>配置好物体碰撞关系<br>必须有一个是刚体</p></blockquote><h1 id="第七十课（unity-专题-七-音乐音效管理）"><a href="#第七十课（unity-专题-七-音乐音效管理）" class="headerlink" title="第七十课（unity_专题(七)音乐音效管理）"></a>第七十课（unity_专题(七)音乐音效管理）</h1><h2 id="sound-manager"><a href="#sound-manager" class="headerlink" title="sound_manager"></a>sound_manager</h2><ul><li>全局唯一的sound_manager;</li><li>在场景里面创建一个物体(做为声音的根节点)，而且设置这个物体场景切换也不会删除;</li><li>编写接口播放背景音乐play_music;</li><li>编写接口播放背景音效play_effect; // 2D声音</li><li>音乐和音效内部实现都是一样的, 只不过要把url分组管理, 音效为一组，音乐为一组;</li><li>提供开关音效接口set_mute(),并将值写入本地;</li><li>提供开关背景音乐接口switch_music(),并将值写入本地;</li><li>添加一个play_effect接口在指定的坐标出访一个声音, 可以用于3D音效;</li><li>添加一个接口停止掉背景音乐stop_music(url);</li><li>添加一个接口删除掉播放的背景音乐clear_music(url), clear_effect(url);</li><li>声音文件来自Resouce还是assetBundle，可以通过资源管理来封装，目前从Resource里面加载;</li><li>加一个脚本，每隔0.5秒扫描一次已经播放完的声音组件,将它disable;</li></ul><h1 id="第七十一课（unity-专题-八-Unity漩涡特效切换）"><a href="#第七十一课（unity-专题-八-Unity漩涡特效切换）" class="headerlink" title="第七十一课（unity_专题(八)Unity漩涡特效切换）"></a>第七十一课（unity_专题(八)Unity漩涡特效切换）</h1><h2 id="Mesh-材质-Shader"><a href="#Mesh-材质-Shader" class="headerlink" title="Mesh 材质 Shader"></a>Mesh 材质 Shader</h2><ul><li>Mesh 是网格数据;</li><li>Shader渲染算法;</li><li>材质是给渲染算法的输入数据;</li><li>代码修改材质参数,能修改给渲染算法的数据从而获得不同的效果;</li></ul><blockquote><p>纹理会自动对齐到2^N方，如果想要原始大小，可以设置Advance –&gt; Non Power of 2 –&gt; None</p></blockquote><h2 id="旋涡特效"><a href="#旋涡特效" class="headerlink" title="旋涡特效"></a>旋涡特效</h2><ul><li>创建一个Shader: Unlit–&gt;Shader;</li><li>漩涡特效分析:<ul><li>纹理坐标的范围[0, 1];</li><li>扭曲顶点的纹理坐标, 扭曲的角度+波及的半径;</li><li>将扭曲的角度与半径数据绑定到材质;</li><li>设置扭曲的角速度, 随着时间的推移加大扭曲角度;</li><li>设置波及范围的速度，随着时间的推移不断的加大波及半径;</li><li>编写代码来控制参数，实现动态的旋转;</li></ul></li><li><p>扭曲代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 把这个两个参数绑定到编辑器</span><br><span class="line">// shader的输入数据绑定到我们的材质，进行代码动态修改</span><br><span class="line">Properties&#123;</span><br><span class="line">    radius(&quot;Radius&quot;,Float) = 0.0</span><br><span class="line">    angle(&quot;Angle&quot;, Float) = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外面也要定义</span><br><span class="line">float radius;// 扭曲的半径</span><br><span class="line">float angle;// 扭曲的弧度</span><br><span class="line"></span><br><span class="line">// 顶点uv变化</span><br><span class="line">// uv变化 获得顶点的纹理坐标[0，1]</span><br><span class="line">float2 uv = v.uv;</span><br><span class="line"></span><br><span class="line">// 扭曲的半径</span><br><span class="line">radius = 0.5f;  </span><br><span class="line">// 扭曲的弧度</span><br><span class="line">angle = 1.0f;</span><br><span class="line"></span><br><span class="line">// 需要把这个两个参数绑定到编辑器</span><br><span class="line">// radius,angle控制我们扭曲的效果 所有如果想要旋涡动画就得不停的修改这两个参数</span><br><span class="line"></span><br><span class="line">// 改变uv坐标的原点</span><br><span class="line">// 原来是 左下角为原点 0，0 右上角 1，1 改为了中心为原点  左下角-0.5,-0.5 右上角 0.5，0.5</span><br><span class="line">// 因为旋涡是从中间开始的</span><br><span class="line">uv -= float2(0.5, 0.5);</span><br><span class="line"></span><br><span class="line">// 计算当前坐标的长度，当前坐标到纹理中心的距离</span><br><span class="line">float dist = length(uv);</span><br><span class="line">// 计算出距离百分比</span><br><span class="line">float percent = (radius - dist) / radius;</span><br><span class="line">if ( percent &lt; 1.0 &amp;&amp; percent &gt;= 0.0)  &#123; // 在半径范围之内进行扭曲</span><br><span class="line">    // 扭曲算法</span><br><span class="line">float theta = percent * percent * angle * 8.0;</span><br><span class="line">float s = sin(theta);</span><br><span class="line">float c = cos(theta);</span><br><span class="line">uv = float2(dot(uv, float2(c, -s)), dot(uv, float2(s, c)));</span><br><span class="line">&#125;</span><br><span class="line">// 变换回我们的纹理坐标寻址的原点</span><br><span class="line">uv += float2(0.5, 0.5);</span><br><span class="line"></span><br><span class="line">o.uv = uv;</span><br></pre></td></tr></table></figure></li><li><p>旋涡粗糙就扩展顶点就行了</p></li></ul><h1 id="第七十二课（unity-专题-九-Unity场景导出与导入）"><a href="#第七十二课（unity-专题-九-Unity场景导出与导入）" class="headerlink" title="第七十二课（unity_专题(九)Unity场景导出与导入）"></a>第七十二课（unity_专题(九)Unity场景导出与导入）</h1><h2 id="天空盒的位置"><a href="#天空盒的位置" class="headerlink" title="天空盒的位置"></a>天空盒的位置</h2><ul><li>可以挂载摄像机（场景编辑器看不见，但是游戏画面有天空盒）</li><li>可以配置全局（场景编辑器能看到天空盒）</li></ul><h2 id="场景导出案例"><a href="#场景导出案例" class="headerlink" title="场景导出案例"></a>场景导出案例</h2><ul><li>准备好Unity 4.7赛车游戏的赛车场景;</li><li>将属于场景的物体，导出成预制体;</li><li>将预制体导入到自己的场景;</li><li>检查导入后的正确性;<blockquote><p>模型网格如果出现missing(Mesh)说明就没有正确关联到模型网格，需要手动修改</p></blockquote></li><li>导入天空盒;</li><li>如果有雾的话配置好雾;</li><li>打开光源,烘培出静态光照;</li></ul><h1 id="第七十四课（unity-专题-十-Unity-FPS第一人称射击类游戏）"><a href="#第七十四课（unity-专题-十-Unity-FPS第一人称射击类游戏）" class="headerlink" title="第七十四课（unity_专题(十)Unity_FPS第一人称射击类游戏）"></a>第七十四课（unity_专题(十)Unity_FPS第一人称射击类游戏）</h1><h2 id="AudioSource-的两个方法-Play-和-PlayOneShot-有什么区别"><a href="#AudioSource-的两个方法-Play-和-PlayOneShot-有什么区别" class="headerlink" title="AudioSource 的两个方法 Play 和 PlayOneShot 有什么区别"></a>AudioSource 的两个方法 Play 和 PlayOneShot 有什么区别</h2><p>play 和 playOneShot 最大的区别是：</p><ul><li>play 每次只能播放一次，也就是说假如短时间内假如你有播放多次和多种音效的需求时。play 只会把音效打断，然后重新播放指定音效。</li><li>playOneShot 就是为了解决播放多种和多次音效的问题而生的（个人观点），这函数不管你目前有没有正在播放音效，它都会另起炉灶播放指定的音效，并且不会打断当前正在播放的音效（这是重点，谨记！）。还能设置它的音量，不会像 AudioSource 组件里的 Volume 属性那样对音量有限制。<blockquote><p>播放点击枪声的时候，play回造成枪声没播放完就重头开始，效果不佳，playOneShot可以解决这个问题</p></blockquote></li></ul><h1 id="第七十九课（unity-专题-十一-ARPG游戏摇杆控制角色行走）"><a href="#第七十九课（unity-专题-十一-ARPG游戏摇杆控制角色行走）" class="headerlink" title="第七十九课（unity_专题(十一)ARPG游戏摇杆控制角色行走）"></a>第七十九课（unity_专题(十一)ARPG游戏摇杆控制角色行走）</h1><h2 id="人物操作方式"><a href="#人物操作方式" class="headerlink" title="人物操作方式"></a>人物操作方式</h2><ul><li>在ARPG游戏中,主角人物在摇杆下控制行走;</li><li>主角人物遇到障碍物(碰撞器)将不会穿越过去;</li><li>摇杆控制主角人物8个方向的行走;</li><li>CharacterController 角色控制器组件: 让你在受制于碰撞的情况下很容易的进行运动，而不用处理刚体。角色控制器不受力的影响，仅当你调用Move函数时才运动。它执行运动，但是受制于碰撞。 </li><li>调用角色控制器的Move函数移动角色;</li><li>根据摇杆的方向旋转人物动画;</li></ul><h2 id="CharacterController组件-角色控制器"><a href="#CharacterController组件-角色控制器" class="headerlink" title="CharacterController组件(角色控制器)"></a>CharacterController组件(角色控制器)</h2><ul><li>属性面板属性:<ul><li>Slope Limit: 角色碰撞器只能爬比这个指定角度低的斜坡:(degree)</li><li>Step Offset: 上楼梯模式，小于Step Offset 值得台阶，可以直接上去;</li><li>Skin Width: 两个碰撞器可以互相渗透深入皮肤宽度， 建议设置成radius的10%;</li><li>Min Move Distance: 调用Move函数移动的最小移动量,如果移动距离比这个小,将不移动;</li><li>center: 相对与transform的位置角色叫胶囊体中心;</li><li>height: 胶囊体高度;</li><li>Radius: 胶囊体的半径;      </li></ul></li><li>碰撞检测:<blockquote><p>只会和使用了CharacterController组件的物体产生碰撞</p><ul><li>void OnControllerColliderHit(ControllerColliderHit hit) {<br>}</li></ul></blockquote></li><li>重要方法:<ul><li>Move(Vec3 offset): 移动的距离;</li></ul></li></ul><h2 id="弧度-顺时针角度是负的，逆时针角度是正的"><a href="#弧度-顺时针角度是负的，逆时针角度是正的" class="headerlink" title="弧度(顺时针角度是负的，逆时针角度是正的)"></a>弧度(顺时针角度是负的，逆时针角度是正的)</h2><p><img src="unity学习笔记/74_1.png" alt="还没有图片哦"></p><h1 id="unity-安卓打包"><a href="#unity-安卓打包" class="headerlink" title="unity_安卓打包"></a>unity_安卓打包</h1><h2 id="java安装好sdk之后新建两个环境变量"><a href="#java安装好sdk之后新建两个环境变量" class="headerlink" title="java安装好sdk之后新建两个环境变量"></a>java安装好sdk之后新建两个环境变量</h2><ul><li>JAVA_HOME </li><li><p>PATH</p><blockquote><p>目录都选择sdk的目录即可cmd命令窗口输入java或javac即可查看是否配置好如果为出现<code>内部或外部命令，也不是可运行的程序或批处理文件</code>说明已经配置好了</p></blockquote></li><li><p>一般不直接打包apk</p><ul><li>配置好之后点击build即可</li></ul></li><li><p>一般导出一个安卓工程勾选下面的选项然后点击Export即可导出</p><ul><li>Google Android Project</li><li>Development Build</li></ul></li><li><p>Run In Background (如果鼠标移出unity点到其他应用，unity程序就会停止，勾选则就是表示可以在后台运行，打包的时候一般都是勾选这个的)</p></li><li><p>Android Studio打包安卓工程文件</p></li></ul><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><blockquote><p>lua 解释器<br>luac lua字节码编译器 lua代码 –&gt; lua字节码<br>使用</p><ul><li><code>luac o &quot;编译出来的文件名&quot; &quot;需要编译的文件&quot;</code></li></ul></blockquote><h2 id="lua表中的"><a href="#lua表中的" class="headerlink" title="lua表中的"></a>lua表中的</h2><p>返回连续数字索引的长度()</p><blockquote><p><strong>lua数组索引是从1开始的</strong><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">a[<span class="number">11</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(#a); <span class="comment">-- 5  因为连续的数字索引只有5个</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>数组（连续数字索引）</p></blockquote><p>ipairs 遍历lua表中的数组部分(连续的数字索引)<br>pairs 遍历lua表中所有的数据</p><h2 id="table的sort比较函数"><a href="#table的sort比较函数" class="headerlink" title="table的sort比较函数"></a>table的sort比较函数</h2><blockquote><p>lua 排序中的比较函数必须要保证排序是稳定的<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    <span class="comment">--[[ 从大到小 大的返回true</span></span><br><span class="line"><span class="comment">        if a &gt; b then</span></span><br><span class="line"><span class="comment">            return true</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return false</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line">    <span class="comment">--[[ 从小到大 小的返回true</span></span><br><span class="line"><span class="comment">        if a &lt; b then</span></span><br><span class="line"><span class="comment">            return true</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return false</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line">    <span class="comment">--[[ 排序中的比较函数必须要保证排序是稳定的</span></span><br><span class="line"><span class="comment">        if math.random &lt; b then --这样是会报错的 不用这种做随机打乱一个数组数据</span></span><br><span class="line"><span class="comment">            return true</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return false</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="解开数组（unpack）"><a href="#解开数组（unpack）" class="headerlink" title="解开数组（unpack）"></a>解开数组（unpack）</h2><p>a,b,_,c,d,e,f = unpack(“数组”)</p><blockquote><p>把数组里面的值解开到a对应索引1，b为2，后面的同理，不用的用 _ 去接即可</p></blockquote><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="require装载lua脚本（不用加后缀）"><a href="#require装载lua脚本（不用加后缀）" class="headerlink" title="require装载lua脚本（不用加后缀）"></a>require装载lua脚本（不用加后缀）</h3><p>require(“lua_file_name”) 或 require “lua_file_name”</p><blockquote><p>可以用一个返回值来接收,如果装载的lua脚本有return那么这个返回值就是脚本里面return的数据</p></blockquote><blockquote><p>require只会装载执行一次,多次require也只会装载并执行一次lua脚本<br>第二次require的时候，会发现已经装载过了，直接返回第一次装载的返回值</p></blockquote><p>local 关键字的只能在挂载内部使用，如果想在外部使用</p><ul><li>第一种就是不适用local关键字</li><li>第二种就是使用return 返回一个函数名即可使用这个函数</li></ul><blockquote><p>上面的方法需要在使用模块脚本里面，都要使用require来装载，才可以调用得到装载脚本里面的方法，这样相对如果多个脚本使用就比较麻烦</p></blockquote><h3 id="全局模块module（全局包）"><a href="#全局模块module（全局包）" class="headerlink" title="全局模块module（全局包）"></a>全局模块module（全局包）</h3><p>在lua脚本开头写上这个前缀<code>module(&quot;模块名字&quot;, package,seeall)</code>，只要在一个脚本里面使用require装载这个脚本，其他lua脚本无须再装载，也是可以使用这个装载脚本里面的方法的</p><blockquote><p>不过上面再其他脚本使用前需要加上<code>模块名字.xxx</code></p></blockquote><h3 id="dofile装载脚本（需要加后缀）"><a href="#dofile装载脚本（需要加后缀）" class="headerlink" title="dofile装载脚本（需要加后缀）"></a>dofile装载脚本（需要加后缀）</h3><p>dofile会对读入的模块编译执行，每调用dofile一次，都会重新编译执行一次<br><a href="https://blog.csdn.net/lf_2016/article/details/78272558" rel="external nofollow noopener noreferrer" target="_blank">require 和 dofile 的区别</a>require只会执行一次，dofile调用几次执行几次</p><p><a href="https://www.cnblogs.com/luguoshuai/p/10474117.html" rel="external nofollow noopener noreferrer" target="_blank">lua的Module</a></p><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a.test</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"a.test"</span>,self)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a.test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b:test</span><span class="params">()</span></span> <span class="comment">-- 隐士传递self参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"b:test"</span>,self) <span class="comment">-- 可以顺利拿到self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b:test() <span class="comment">-- 调用的是表的实例self 就是这个表的实例 使用 ： 会隐士绑定self</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b.test2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"b:test"</span>,self) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b:test2() <span class="comment">-- 无法正常拿到self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.test(b) -- 显示传递 也是可以拿到的</span></span><br><span class="line">b.test() <span class="comment">-- 无法正常拿到self  即使是：定义的函数，调用函数的时候不使用 ：也是无法正常拿到self的</span></span><br></pre></td></tr></table></figure><h3 id="self机制需要正常运行，需要两个点"><a href="#self机制需要正常运行，需要两个点" class="headerlink" title="self机制需要正常运行，需要两个点"></a>self机制需要正常运行，需要两个点</h3><ul><li>定义的函数必须使用 ： 才会有隐式的传递self</li><li>调用的时候也需要使用：</li><li>显示传递</li></ul><h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mtable = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = &#123;</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(a, mtable) <span class="comment">-- 设置元表 a的元表是mtable 设置mtable为a的元表</span></span><br><span class="line"><span class="built_in">getmetatable</span>(a) <span class="comment">-- 获得a的元表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.a) <span class="comment">-- 打印为100 自己表里面找不到就会去元表的__index表里面去找</span></span><br></pre></td></tr></table></figure><p>元表里面有一个非常重要的key : <strong>index<br><strong>特点</strong>：<br>当我门搜索一个表的key的使用，如果没有搜索得到，lua解释器就会去这个表里面的元表里面的</strong>index这个key锁对应的表里面来查找</p><h2 id="模拟面向对象的语法"><a href="#模拟面向对象的语法" class="headerlink" title="模拟面向对象的语法"></a>模拟面向对象的语法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> base = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:new</span><span class="params">(instant)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> instant <span class="keyword">then</span> <span class="comment">-- 类的实例 没有就创建一个</span></span><br><span class="line">        instant = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instant, &#123;<span class="built_in">__index</span> = self&#125;) <span class="comment">-- 把这个实例的元表设置成 base 这样 这个实例就相当于有了可以访问base的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instant</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = base:new() <span class="comment">-- 这个base表就是new的self(实例)</span></span><br><span class="line"><span class="comment">-- 在new函数里面把新创建的实例表的元表变成了self，这样如果在这个实例里面找不到相关的函数，就会去这个元表的__index表里面去找，相应的就找到了self（也就是base表）</span></span><br><span class="line">b:test() <span class="comment">-- 所有可以用b访问base里面的成员函数 这时候的self对象就是我们的实例b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加数据成员</span></span><br><span class="line"><span class="keyword">local</span> c = base:new(&#123;</span><br><span class="line">    name=<span class="string">"name"</span>,</span><br><span class="line">    age=<span class="number">33</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.name) <span class="comment">-- 实在&#123;name="name",age=33,&#125;这个基础上扩展的元表所有不用加:也是可以的，访问数据成员不需要：</span></span><br></pre></td></tr></table></figure><blockquote><p>总结<br>面向对象的基本步骤</p><ul><li>定义一个表（类） – 相当于定义一个类 class</li><li>定义一个实例的表 – new_instant = class:new();</li><li>为这个实例的表添加一个元表，并且元表__index指向这个定义的表self（这个类）</li><li>利用self机制，表的实例调用函数的时候,隐式的帮我们传递了实例的表为self到函数里面<br>  表的实例(new_instant):表的函数(test)</li></ul></blockquote><h2 id="继承、重载"><a href="#继承、重载" class="headerlink" title="继承、重载"></a>继承、重载</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> base = &#123;&#125; <span class="comment">-- 基类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test2"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test3</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test3"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:new</span><span class="params">(instant)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> instant <span class="keyword">then</span> <span class="comment">-- 类的实例 没有就创建一个</span></span><br><span class="line">        instant = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instant, &#123;<span class="built_in">__index</span> = self&#125;) <span class="comment">-- 把这个实例的元表设置成 base 这样 这个实例就相当于有了可以访问base的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instant</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> man = base:new() <span class="comment">-- 把man实例的元表设置成父类(base)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"man:test"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重载base的test3函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man:test3</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"man:test3"</span>,self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 子类里面调用父类函数</span></span><br><span class="line">    base.test3(self) <span class="comment">-- 显示传递一次self即可</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个new调用的方法其实是base里面的方法因为man的元表__index已经设置成了base</span></span><br><span class="line"><span class="comment">-- 而new里面的self就不再是base的了，而是实例man的self</span></span><br><span class="line"><span class="keyword">local</span> p = man:new() <span class="comment">-- 子类的实例p</span></span><br><span class="line"><span class="comment">-- 下面的self 都是p的</span></span><br><span class="line">p:test() <span class="comment">-- p --&gt; man找到打印 man:test</span></span><br><span class="line">p:test2() <span class="comment">-- p --&gt; man --&gt; base 找到打印 base:test2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--p --&gt; man --&gt; base --&gt;一直找下去直到找到，没有找到那么就会报错</span></span><br><span class="line">p:test3() <span class="comment">-- p里面是没有的接下来去man去找，找到了就返回 所有打印的是 man:test3 这样我们就重载了基类的函数</span></span><br></pre></td></tr></table></figure><h1 id="Lua热更新"><a href="#Lua热更新" class="headerlink" title="Lua热更新"></a>Lua热更新</h1><h2 id="资源管理与lua框架开发基本原则"><a href="#资源管理与lua框架开发基本原则" class="headerlink" title="资源管理与lua框架开发基本原则"></a>资源管理与lua框架开发基本原则</h2><h3 id="全新资源管理模式"><a href="#全新资源管理模式" class="headerlink" title="全新资源管理模式"></a>全新资源管理模式</h3><ol><li>unity资源管理方式阶段（<strong>打完包之后，资源无法更新了</strong>）<ul><li>编辑器编辑资源，我们如果要用代码加载资源就使用Resources.Load来代码加载资源</li><li>用代码加载的资源放在resources目录</li><li>不用代码直接加载资源放在resources以外的文件夹下</li><li>打包的时候，resources的资源，全部会打入发布包</li><li>其他文件下的资源，根据场景依赖或者是resources下的资源依赖进行选择性打包，没有被使用的非resources下的资源就不会被打包进去</li></ul></li><li>虽然外面无法更新代码，我是否有办法更新我的资源呢，再我们不重新安装的情况下 Unity就有了我们的AssetBundle的更新模式<ul><li>安装包里面带了资源 + 下载AssetBundle包的资源</li><li>如果是AB包资源，那么就用ab包模式加载资源，否者就还是走resources模式</li></ul></li><li>随着游戏越来越复杂，包体积越来越大，2G~3G的美术资源 包体就非常的大，所有我们有了空包，空包里面什么资源都没有，启动的时候去加载ab包，其他时候什么都没有，这样安装包就比较小，很多游戏第一次安装完之后，就需要下载一个很大的资源包<ul><li>a 所有资源再也没有放resources里面</li><li>b 放resources里面反倒成了一个负担，打空包的时候，你不希望打资源，但是如果放在resources里面，他还是会全部打包进去</li><li>c 有一些小型游戏(50~60M，资源在包体，渠道出的带宽)，资源在服务器上是自己出带宽，为了节约带宽，希望把这个初始资源包带入安装包，那么还是走assetbundle机制，但是我们会选择把assetbundle放在StreamingAssets文件夹下</li><li>StreamingAssets里面的ab包可以被游戏加载进来，不走三方服务器，只要放在StreamingAssets文件夹下也能加载到游戏资源</li></ul></li><li>你只更新资源，不更新代码，总归不是个事，比如做个营销活动(世界杯),等活动结束，要恢复回来，就需要更新代码<ul><li>热更框架：脚本的模式，游戏里面内置一个脚本解释器，解释执行我们的脚本，我们开发就用这个脚本，脚本资源也会是一种”资源”，也会把代码打包在ab包里面，一般我们会代码单独的打包成ab包。有些可能就区分为(框架的ab包 + 业务逻辑的ab包) 根据自己的情况是否需要把所有脚本代码做成ab</li><li>热更方式：脚本模式，内置一个脚本解释器 + 运行起来（插入版本检测，来更新最新的代码）动态装载脚本代码，在解释执行<ol><li>lua:lua解释器 + lua脚本 —&gt;我们采用的<ul><li>主流使用C#开发，用lua打补丁<blockquote><p>lua打补丁：比如 C#代码set_name有bug，我们就使用lua给这个函数set_name(){lua 代码 不走原来C#的代码了} 进行打补丁，检测到有lua补丁，就不走原来的C#代码直接走lua补丁代码</p></blockquote></li><li>主流全部用纯lua开发，底层的C#的框架代码(采用lua打补丁)，所有的业务逻辑和C#没有关系了，直接使用Lua开发(一般使用这个)</li></ul></li><li>C#：C#解释器(C# light) + C#脚本</li></ol></li></ul></li></ol><h3 id="基本设计的原理原则"><a href="#基本设计的原理原则" class="headerlink" title="基本设计的原理原则"></a>基本设计的原理原则</h3><ol><li>完全取消resources资源加载方式，采用ab包进行加载资源（但是总不可能在日常开发的时候总是从ab包里面进行资源加载）<ul><li>Editor下的一个开发模式，我们编写一些接口，不真正的去加载ab包(调用加载ab包的接口是没有用的，但是我们会走这个流程)<ul><li>加载资源：编辑器模式下运行才有效的函数来装载资源<code>AssetDatabase.LoadAssetAtPath</code>加载ab包的时候什么都不干，所有就可以来正常的开发业务逻辑了</li><li>正式运行模式：从ab包里面进行读取装载资源，就走标准的模式(标准的流程)</li></ul></li></ul></li><li>我们要<strong>支持打空包</strong>，所以这个时候的资源，不能把依赖打包到我们的安卓包里面<ul><li>我们会从场景依赖打入资源，场景里面就不能放任何东西</li><li>resources的依赖，去掉了resources，就不会存在了，打空包就非常方便了</li></ul></li><li>我们会把资源打成单独的包出来，放单独的文件夹下，假设你要把第一个版本的资源打包进行，这时候我们就会编写脚本，直接将这个资源包复制到StreamingAssets文件夹下</li><li>热更新代码，热更资源，普通节点上不带任何代码</li><li>场景只放启动节点代码，启动代码 –&gt; 启动C#框架 –&gt; 加载lua脚本 –&gt; lua代码业务逻辑</li><li>对于我们的lua开发，完全支持C#的开发习惯也用组件开发，也有Update等</li></ol><h3 id="热更与资源管理模块的设计演示"><a href="#热更与资源管理模块的设计演示" class="headerlink" title="热更与资源管理模块的设计演示"></a>热更与资源管理模块的设计演示</h3><ul><li>在我们编辑器上我们会设置模式(这个模式存在Editor本地读写里面)<ul><li>Editor模式</li><li>开发模式</li></ul></li><li>我们打包发布的时候：ab(平台(android、ios) + 渠道(百度、360)) AssetBundles<blockquote><p>ab包是要区分平台和渠道的</p></blockquote></li><li><p>最终我们是要将代码作为资源打包到ab包里面的，我们使用AssetsPackage(资源 + 代码)文件夹来存放资源包 + 代码<br>  打ab包的时候全部打的是AssetsPackage下的资源，和开发就没什么关系了</p><blockquote><p>lua代码不是unity的ab包识别的类型.lua的资源 使用工具 把.lua –&gt;转换 .lya.bytes 类型放在AssetsPackage</p></blockquote></li><li><p>我们指定我们要打包ab包，打包的时候有一个包的数据库管理（根据一个配置文件来打包）</p></li><li>ab包会根据渠道输出到一个单独的路径</li><li>查看打包出来的结果</li><li>打包资源的时候会生成一个文本资源.map映射(哪个资源在哪个ab包，资源的路径，AssetsMap)</li><li>我们会开启一个模式：测试这个资源包</li></ul><h3 id="纯lua开发的注意事项与性能瓶颈"><a href="#纯lua开发的注意事项与性能瓶颈" class="headerlink" title="纯lua开发的注意事项与性能瓶颈"></a>纯lua开发的注意事项与性能瓶颈</h3><ul><li>做游戏开发的时候80%、90%性能开销、渲染都是(底层)C#写好的组件 + 物理引擎 –&gt; lua(20%~10%) –&gt; 性能是可接受的，lua –&gt; 接近C# lua开发怎么都是解释执行，所有性能要低一些</li><li>lua开发编写算法(负载的算法)的时候 –&gt; 尽可能使用C#来做算法，不要使用lua来写（核心算法，不会有很大的改变）<blockquote><p>不用lua写算法，使用C#</p></blockquote></li><li>lua调用C#、C#调用lua 经过漫长的数据交互和函数调用的过程 –&gt;性能开销比较大，尽量减少这个lua和C#的交互<blockquote><p>减少lua和C#的交互</p></blockquote></li></ul><blockquote><p>做一个纯lua框架 + 完整的ab包资源 + 其他功能(自己扩展)</p></blockquote><h2 id="项目创建与Lua启动流程"><a href="#项目创建与Lua启动流程" class="headerlink" title="项目创建与Lua启动流程"></a>项目创建与Lua启动流程</h2><ul><li>创建项目，规范项目目录结构<ul><li>创建一个AssetsPackage文件夹，用来放资源，所有的资源和资源ab打包我们都会放在这个文件夹下</li><li>创建一个Scripts文件夹，用来放C#的代码</li><li>创建一个LuaScripts文件夹，开发的时候我们要存放Lua脚本代码</li><li>Scenes 用来存放场景</li><li>StreamingAssets 用来存放我们的本地的ab包资源，可以加载ab包，同时可以打包到安装包里面去</li><li>Editor 编辑器扩展代码</li><li>做一个启动脚本，用空物体来挂一个脚本</li></ul></li><li>搭建xLua开发环境<ul><li><a href="https://github.com/Tencent/xLua" rel="external nofollow noopener noreferrer" target="_blank">xLua github</a>下载源码</li><li>xLua的Assets文件夹里面的文件copy到untiy项目的Assets文件夹下即可</li></ul></li><li>编写代码启动Lua虚拟机<ul><li>LuaEnv 是lua解释器的上下文的运行环境，lua解释器的运行环境的数据，都会依赖luaenv</li><li>重新添加一个lua代码装载器，到lua解释器，那么它装载lua文件的时候，就会使用这个装载器<blockquote><p>因为开发的时候我们载入的是luascripts的lua代码，在发布的时候我们装载的是被打入assetbundle包的lua代码</p></blockquote></li><li>CustomLoader 一个是编辑器模式 一个是assetbundle模式<blockquote><p>装载lua文件的时候就会调用这个函数</p></blockquote></li></ul></li><li>重载Lua装载器<ul><li>luaEnv.AddLoader</li><li><blockquote><p>参数说明：luaEnv.AddLoader(loader)<br>   loader 类型为 delegate byte[] CustomLoader(ref string filepath)<br>   当一个文件被 require 时，这个 loader 会被回调,其参数就是require的参数<br>   如果该 loader 找到文件，可以将其读进内存，返回一个 byte 数组。<br>   如果需要支持调试的话，而filepath要设置成 IDE 能找到的路径（相对或者绝对都可以）</p></blockquote></li></ul></li><li>编写Lua启动脚本<ul><li>luaEnv.DoString(scriptContent)</li><li><blockquote><p>参数说明：scriptContent 代码文本内容</p></blockquote></li></ul></li></ul><h2 id="lua的组件开发模式"><a href="#lua的组件开发模式" class="headerlink" title="lua的组件开发模式"></a>lua的组件开发模式</h2><h3 id="lua启动脚本开发入口"><a href="#lua启动脚本开发入口" class="headerlink" title="lua启动脚本开发入口"></a>lua启动脚本开发入口</h3><ul><li>Update、FixedUpdate、LateUpdate<blockquote><ul><li>ApplicationQuit</li><li>Update</li><li>FixeUpdate</li><li>LateUpdate</li></ul></blockquote></li></ul><p>main.lua加上这些入口、xLuaMgr 调用这些接口，实现lua拥有Update、FixedUpdate、LateUpdate函数功能</p><h3 id="lua组件化开发模式设计理念"><a href="#lua组件化开发模式设计理念" class="headerlink" title="lua组件化开发模式设计理念"></a>lua组件化开发模式设计理念</h3><blockquote><p>大家都习惯了组件开发<br>lua调用unity的接口，非常方便</p></blockquote><ul><li>组件化<ul><li>组件化 + 真正的在unity添加组件，然后通过组件再转载lua脚本</li><li>组件化 + 不通过unity + 纯lua组件开发的模式<ul><li>我们自己定义lua组件，自己”添加”lua组件到gameObject()</li><li>我们用lua脚本来驱动update、fixedupdate、lateupdate 通过这种方式然后实现组件实例</li></ul></li></ul></li></ul><h3 id="lua组件类基类的设计"><a href="#lua组件类基类的设计" class="headerlink" title="lua组件类基类的设计"></a>lua组件类基类的设计</h3><p>所有的lua组件实例都继承LuaBehaviour<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回一个基类为base的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LuaExtend</span><span class="params">(base)</span></span></span><br><span class="line">    <span class="keyword">return</span> base:new();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> LuaBehaviour = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LuaBehaviour:new</span><span class="params">(instant)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> instant <span class="keyword">then</span></span><br><span class="line">        instant = &#123;&#125; <span class="comment">-- 类的实例</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instant, &#123;<span class="built_in">__index</span> = self&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instant;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 两个成员函数 尽量和unity 习惯保持一致</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LuaBehaviour:init</span><span class="params">(obj)</span></span></span><br><span class="line">    self.transform = obj.transform</span><br><span class="line">    self.gameObject = obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> LuaBehaviour;</span><br></pre></td></tr></table></figure></p><p>新建一个LuaComponentMgr的模块来管理lua的组件实例</p><h2 id="lua调用unity"><a href="#lua调用unity" class="headerlink" title="lua调用unity"></a>lua调用unity</h2><blockquote><p>unity在C#中的名字空间 UnityEngine<br>unity在Lua中的名字空间 CS.UnityEgine</p></blockquote><h3 id="lua调用unity-1"><a href="#lua调用unity-1" class="headerlink" title="lua调用unity"></a>lua调用unity</h3><ul><li>我要获取unity对象里面的数据成员：obj.transform, obj.gameObject, obj.xxxx</li><li>调用unity对象里面的成员函数 obj:xxx()</li></ul><h3 id="AddComponent-unity组件"><a href="#AddComponent-unity组件" class="headerlink" title="AddComponent(unity组件)"></a>AddComponent(unity组件)</h3><blockquote><p>self.gameObject:AddComponent(“填组件名字就行了”) 已废弃<br>self.gameObject:GetComponent(“填要获取组件名字就行了”)</p></blockquote><h3 id="unity导出接口给lua使用"><a href="#unity导出接口给lua使用" class="headerlink" title="unity导出接口给lua使用"></a>unity导出接口给lua使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using XLua;</span><br><span class="line"></span><br><span class="line">// 表示这个文件将要被导出给lua使用</span><br><span class="line">[LuaCallCSharp]</span><br><span class="line">public class ResMgr : UnitySingleton&lt;ResMgr&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public override void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        base.Awake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AssetsBundles打包管理的使用"><a href="#AssetsBundles打包管理的使用" class="headerlink" title="AssetsBundles打包管理的使用"></a>AssetsBundles打包管理的使用</h2><p><a href="unity学习笔记/lua_10_1.png">图片还没有哦</a></p><h2 id="GC与AssetsBundles步骤详解"><a href="#GC与AssetsBundles步骤详解" class="headerlink" title="GC与AssetsBundles步骤详解"></a>GC与AssetsBundles步骤详解</h2><h3 id="Editor-–-gt-XLuaMenu-文件下做的事情"><a href="#Editor-–-gt-XLuaMenu-文件下做的事情" class="headerlink" title="Editor –&gt; XLuaMenu 文件下做的事情"></a>Editor –&gt; XLuaMenu 文件下做的事情</h3><blockquote><p>复制lua文件<br>修改后缀名</p></blockquote><ul><li>AssetsPackage所有的资源部 lua代码也会是一个资源 .lua文件 ab包(需要把.lua转为 .lua.bytes 作为二进制打进去)</li><li>LuaScripts开发模式下的lua代码 拷贝到AssetsPackage 并且将所有.lua转为 .lua.bytes</li></ul><h3 id="不同开关模式的详解（Switch-Model）"><a href="#不同开关模式的详解（Switch-Model）" class="headerlink" title="不同开关模式的详解（Switch Model）"></a>不同开关模式的详解（Switch Model）</h3><blockquote><p>Editor –&gt; AssetBundle –&gt; AssetbundleMenultems.cs 所有的资源管理菜单都在这里</p></blockquote><ul><li>Editor模式 直接重LuaScripts里面加载代码</li><li>切换到模拟模式，我们是从assetbundle里面进行加载资源</li><li>发布模式从assetbundle里面进行加载资源</li></ul><h3 id="渠道和版本管理"><a href="#渠道和版本管理" class="headerlink" title="渠道和版本管理"></a>渠道和版本管理</h3><ul><li>GameChannel.cs 渠道配置文件 项目有哪一些渠道就可以写哪一些渠道</li><li>Editor –&gt; PackageBuild –&gt; PackageTool.cs 文件 负责包版本的管理 Tool菜单功能</li><li>EditorUserBuildSettings 编译目标的一个配置打包时候 unity的配置 activeBuildTarget 当前选择的一个build目标</li><li>获取当前渠道 PackageUtils –&gt; GetCurSelectedChannel</li></ul><h2 id="Assetbundle打包配置与源码详解"><a href="#Assetbundle打包配置与源码详解" class="headerlink" title="Assetbundle打包配置与源码详解"></a>Assetbundle打包配置与源码详解</h2><ul><li><p>AssetBundle打包配置操作</p><ul><li><p>Editor/AssetBundle/Database/AssetsPackage –&gt; Lua.asset(对象数据直接存到文件里面)</p><blockquote><p>.asset文件指定了我们的哪个文件打包哪些文件到我们的assetbundle里面、打包的方式有哪些<br>如果你的文件夹没有被指定打包生成assetbundle，那么在这个文件夹下就会有一个按钮 –&gt; create AssetBundleDipatch</p></blockquote></li><li><p>打包类型：</p><ul><li>root 就是以这个文件夹为根目录，来打包assetbundle; lua.assetbundle 路径/名字.assetbundle</li><li>Children 文件夹下的每个孩子</li><li>Children Folders Only 只会打包文件夹</li><li>Children files Only 只会打包文件</li></ul></li></ul></li><li>Unity ScriptableObject详解生成.asset<br>ScriptableObject C#对象如果你继承自 ScriptableObject 那么你就会很方便的写入数据到.asset文件<br>AssetBundleDispatcherConfig.cs –&gt; 打包的时候的一个配置生成.asset</li><li>按钮扩展在<code>AssetBundleDispatcherInspector.cs</code>里面</li></ul><p>打包的时候，可以做资源检查，Run All Checks 我们就是根据.asset文件来检查我们的资源包下面的文件夹是否都有<br>(1) 运行Lua脚本拷贝，将我们lua脚本拷贝到我们的AssetsPackages文件夹下<br>(2) 清理掉不用的assetbundle的名字 重新创建assetbundle的名字</p><h2 id="AssetBundle打包流程分析"><a href="#AssetBundle打包流程分析" class="headerlink" title="AssetBundle打包流程分析"></a>AssetBundle打包流程分析</h2><h2 id="AssetBundle资源加载"><a href="#AssetBundle资源加载" class="headerlink" title="AssetBundle资源加载"></a>AssetBundle资源加载</h2><ul><li>AssetBundleManager是一个单例，所以要在开始节点上添加这个节点</li></ul><h2 id="lua热更dome"><a href="#lua热更dome" class="headerlink" title="lua热更dome"></a>lua热更dome</h2><h3 id="热更流程"><a href="#热更流程" class="headerlink" title="热更流程"></a>热更流程</h3><ol><li>会从私有数据目录下，来读取我们的版本信息(如果没有读到就会去StreamingAssets文件夹去读取)<blockquote><p>优先从我们的热更的下载目录下读，如果没有再从StreamingAssets目录下读取  </p></blockquote></li><li>提前下载好最新的资源到私有可写目录，那么我们用的加载就是最新的assetbundle</li><li>从本地读取版本信息，就会得到一个版本号</li><li>从服务器读取一个版本信息</li><li>把本地的版本与服务器的版本进行比对，比对完成以后如果要更新，我们就获取这个更新列表</li><li>更新列表：当前的哪些资源变动了，我们可以通过hash值来比较，如果不一样，就放入下载路径，将资源下载下来，下载好了以后就进入游戏，我们游戏里面，从本地加载的ab包是最新的，这样就热更完成了。</li></ol><h4 id="搭建一个简单的webserver"><a href="#搭建一个简单的webserver" class="headerlink" title="搭建一个简单的webserver"></a>搭建一个简单的webserver</h4><ul><li>安装好node.js</li><li>进入命令窗口node-v查看node版本<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建服务器目录--&gt;在目录打开命令窗口安装 npm install express 安装 express</span></span><br><span class="line"><span class="comment">// www_root 放置资源的文件夹</span></span><br><span class="line"><span class="comment">// 创建js文件编写代码进行部署服务器</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 把静态文件路径 设置成服务器路径 http://127.0.0.1:6868/Resources —— www_root/Resources</span></span><br><span class="line">app.use(express.static(path.join(process.cwd(), <span class="string">"www_root"</span>)));</span><br><span class="line"><span class="comment">// 启用监听6868端口</span></span><br><span class="line">app.listen(<span class="number">6868</span>); <span class="comment">// http://127.0.0.1:6868/Resources/lua.assetbundle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在命令窗口执行js脚本</span></span><br><span class="line"><span class="comment">// 使用 http://127.0.0.1:6868/Resources/lua.assetbundle 访问看是否能找到要下载的文件 如果找到了 说明部署成功</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="NGUI"><a href="#NGUI" class="headerlink" title="NGUI"></a>NGUI</h2><p>一般NGUI界面开发流程<br>1）美术设计界面，提供切图，效果图给到程序<br>2）用NGUI搭建静态界面<br>3）将搭建好的静态界面拖到Project视图上—–形成一个预制体prefeb<br>4）通过代码调用 来初始化和显示预先配置好的界面，实现界面的切换</p><h2 id="NGUI-字体"><a href="#NGUI-字体" class="headerlink" title="NGUI - 字体"></a>NGUI - 字体</h2><ul><li>ShrinkContent<ul><li>总是显示所有文字，根据当前的width和height进行缩放</li></ul></li><li>ClampContent<ul><li>一看到Clamp就想起Clamp函数，也就是不管文本多少个字，根据当前的width和height来显示，超出部分 不显示</li></ul></li><li>ResizeFreely<ul><li>会对当前的文字长度和行数来调整，UILabel的width和height，基本上是只在一行显示，超出的部分不显示</li></ul></li><li>ResizeHeight<ul><li>保持宽度不变，必要时增加高度。</li></ul></li></ul><ul><li><p>Spacing</p><ul><li><p>X：设置字与字之间到间隔，可以为负数，设置得当可以反序</p></li><li><p>Y： 设置行与行之间的间隔。</p></li></ul></li><li><p>Gradient ：</p><ul><li>设置 渐变字</li></ul></li><li><p>Max Lines：</p><ul><li>用来控制最多要多少行。用0表示不限制。如果设置成n的话，那么超过n的行的文字将不会显示！</li></ul></li><li><p>可以使用BBCode标记</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[b]Bold[/b]                      粗体</span><br><span class="line">[i]italic[/i]                  斜体</span><br><span class="line">[u]underline[/u]               下划线</span><br><span class="line">[s]strikethrough[/s]         删除线</span><br><span class="line">AA[sub]sub[/sub]               下标</span><br><span class="line">BB[sup]sup[/sup]               上标</span><br><span class="line">[00ff00]设置颜色[-]           设置显示颜色</span><br><span class="line"></span><br><span class="line">[url=http://www.cnblogs.com/mrzivchu/][u]博客[/u][/url] 链接</span><br><span class="line"></span><br><span class="line">例如设置颜色：</span><br><span class="line">UILabel的Text内容为：[99ff00]n[-]gui: tools</span><br></pre></td></tr></table></figure><ul><li>第三方的字体制作工具<ul><li><a href="http://www.angelcode.com/products/bmfont/" rel="external nofollow noopener noreferrer" target="_blank">BMFont</a></li><li><a href="http://childhood.logdown.com/posts/190580/-details-using-shoebox-produce-bitmap-fonts" rel="external nofollow noopener noreferrer" target="_blank">shoebox</a></li></ul></li></ul><h2 id="NGUI-精灵-图集"><a href="#NGUI-精灵-图集" class="headerlink" title="NGUI - 精灵/图集"></a>NGUI - 精灵/图集</h2><ul><li><p>IPanel</p><ul><li>用来收集和管理它下面所有widget的组件。通过widget的geometry创建实际的draw call。</li><li><p>没有panel所有东西都不能够被渲染出来。如果你对Unity熟悉，你可以把UIPanel当做Renderer。</p></li><li><p>所有panel都有一个Depth值，会影响所有它包含的widget。如果你的UI有很多窗口，那么最好每个窗口有一个panel。</p></li><li><p>Panel上的depth权重会远远高于每一个widget的depth权重，所以保证panel不要使用同样的depth。如果使用同样的depth在panel上，那么draw call会被自动拆分来保证渲染顺序，所以会增加更多的draw call。</p></li><li>Alpha属性影响所有在panel下面的widget。所以可以用它来淡出整个窗口。</li><li>如果你的UI需要被灯光影响，需要勾选上Normals。</li><li>如果创建了一个有很多geometry的scrollable panel，你需要勾选Cull选项来减少三角形的数目。这样也可能降低性能，因为widget的可视性需要每次update都检验一次。</li><li><p>勾选Static选项来告诉NGUI这个panel下面的widget不会被移动，这样可以提高性能。NGUI会忽略所有的position/rotation/scale改变。所以在运行时移动widget不会有效——所以小心使用。</p></li><li><p>如果要调试由panel创建的draw calls，Show All选项可能帮助到你。你会看到由panel创建的所有draw call，以渲染顺序排序。每个draw call会包括它使用到material的详细信息，那个widget用的这个material，甚至可以让你关闭某些draw call来让你查询某些问题。</p></li><li><p>Panel会根据dimensions自动Clip所有它的子节点。使用这个功能需要选择Clipping下拉列表中的任意选项，之后调整Scene View中紫色矩形的尺寸，就像调整widget的尺寸一样。通过这样做你可以把一个panel放到Scroll View中，让他轻松的拖拽。</p></li><li><p>注意clipping的panel不能嵌套。每个panel只能clip自己管理的widget，如果一个panel在另外一个panel里面，只有一个会影响到里面的widget。这个限制以后会去掉。</p></li><li><p>默认NGUI中panel的Render Queues从3000开始往上增加。你可以通过Render Q来修改。如果你想在两个panel中间增加粒子，只要修改两个panel的render queue一个高于粒子，一个低于粒子即可。如果想要让所有的draw call使用和NGUI 2.x版本的渲染方式一样，使用z轴而不是depth。</p></li><li>那么给panel的Render Q指定为Explicit。（NGUI 2.x用的是3000）。</li><li>如果你找和Anchors相关的文档，可以看基类——UIRect。</li></ul></li><li><p>小贴士</p><ul><li>一个动力学Rigidbody会自动增加到你的panel上，因为对于Unity来说这样会提升性能。移动静态的collider会有很多消耗性能的操作，但是移动rigidbody就不会。</li></ul></li><li><p>UIPanel 和 uiwidget 工具</p><ul><li>UIPanel会产生drawcall,而widget不会，widget依赖于父节点来产生drawcall</li><li>panel有裁切区域，widget没有</li><li>当panel有裁切区域，Anchors对齐功能才可用，widget不用</li><li>widget下的depth没用，会按它的父panel的depth算，panel下的depth就是自己的</li><li><a href="http://tasharen.com/ngui/docs/class_u_i_panel.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></li></ul></li></ul><h2 id="NGUI-锚点-帧动画-Tween动画-Checkbox复选框-Button事件回调-Slider滑动条"><a href="#NGUI-锚点-帧动画-Tween动画-Checkbox复选框-Button事件回调-Slider滑动条" class="headerlink" title="NGUI_锚点_帧动画_Tween动画_Checkbox复选框_Button事件回调_Slider滑动条"></a>NGUI_锚点_帧动画_Tween动画_Checkbox复选框_Button事件回调_Slider滑动条</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 添加按钮事件</span><br><span class="line">this.GetComponent&lt;UIButton&gt;().onClick.Add(new EventDelegate(this.OnClickButton2));</span><br><span class="line"></span><br><span class="line">// 获得按钮物体，添加事件</span><br><span class="line">UIEventListener.Get(this.gameObject).onClick = OnClickButton3;</span><br><span class="line"></span><br><span class="line">// 添加按钮事件</span><br><span class="line">EventDelegate.Add(GetComponent&lt;UIButton&gt;().onClick, AddOnClick5);</span><br></pre></td></tr></table></figure><h2 id="NGUI-打字机效果Tab商城背包之Scrollview1（基于panel）"><a href="#NGUI-打字机效果Tab商城背包之Scrollview1（基于panel）" class="headerlink" title="NGUI_打字机效果Tab商城背包之Scrollview1（基于panel）"></a>NGUI_打字机效果<em>Tab商城</em>背包之Scrollview1（基于panel）</h2><ul><li>打字机效果<blockquote><p>游戏中的新手引导或人物的对话功能中</p><ul><li>UILabel</li><li>TypewriterEffect</li></ul></blockquote></li><li>Tab功能<blockquote><p>实现商城功能必备</p><ul><li>Toggle</li><li>ToggledObjects + Box Collider</li></ul></blockquote></li><li>ScrollView滚动视图，基于UIPanel实现<blockquote><p>实现商城功能必备</p><ul><li>Drag Scroll View</li><li>Center On Click</li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.tjl-myblog.cn:4455/one.jpg&quot; alt=&quot;图片还没有哦&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>a &amp; (a - 1)的含义</title>
    <link href="http://www.tjl-myblog.cn/a%20&amp;%20(a%20-%201)%E7%9A%84%E5%90%AB%E4%B9%89.html"/>
    <id>http://www.tjl-myblog.cn/a &amp; (a - 1)的含义.html</id>
    <published>2019-12-23T06:30:03.000Z</published>
    <updated>2019-12-23T06:36:14.460Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a><br>可以理解为，将 a 的二进制为 1 的位置为 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">    a = a &amp; (a - <span class="number">1</span>);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时count 为6</span></span><br></pre></td></tr></table></figure><blockquote><p>1000的二进制为<code>‭001111101000‬</code></p></blockquote><p>由上看出1000有6个1，当变为0的时候需要 <code>a &amp; (a - 1)</code>6次，所以上面的count为6</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.tjl-myblog.cn:4455/one.jpg&quot; alt=&quot;图片还没有哦&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TortoiseGit报错</title>
    <link href="http://www.tjl-myblog.cn/TortoiseGit%E6%8A%A5%E9%94%99.html"/>
    <id>http://www.tjl-myblog.cn/TortoiseGit报错.html</id>
    <published>2019-12-22T01:55:25.000Z</published>
    <updated>2019-12-22T01:57:37.949Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="TortoiseGit-报错-No-supported-authentication-methods-available-server-sent-publickey"><a href="#TortoiseGit-报错-No-supported-authentication-methods-available-server-sent-publickey" class="headerlink" title="TortoiseGit 报错 No supported authentication methods available (server sent: publickey)"></a>TortoiseGit 报错 No supported authentication methods available (server sent: publickey)</h2><p>解决方案：<code>修改SSH客户端路径</code></p><ul><li>TortoiseGit设置</li><li>网络</li><li>SSH客户端<br>路径选择为Git安装路径下的<code>usr\bin\ssh.exe</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.tjl-myblog.cn:4455/one.jpg&quot; alt=&quot;图片还没有哦&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git配置设置全局用户名邮箱</title>
    <link href="http://www.tjl-myblog.cn/git%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E7%94%A8%E6%88%B7%E5%90%8D%E9%82%AE%E7%AE%B1.html"/>
    <id>http://www.tjl-myblog.cn/git配置设置全局用户名邮箱.html</id>
    <published>2019-12-22T01:54:24.000Z</published>
    <updated>2019-12-22T01:55:08.673Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="查看git用户名"><a href="#查看git用户名" class="headerlink" title="查看git用户名"></a>查看git用户名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><h2 id="查看git邮箱"><a href="#查看git邮箱" class="headerlink" title="查看git邮箱"></a>查看git邮箱</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h2 id="设置git用户名"><a href="#设置git用户名" class="headerlink" title="设置git用户名"></a>设置git用户名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"name"</span></span><br></pre></td></tr></table></figure><h2 id="设置git邮箱"><a href="#设置git邮箱" class="headerlink" title="设置git邮箱"></a>设置git邮箱</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">"emial"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.tjl-myblog.cn:4455/one.jpg&quot; alt=&quot;图片还没有哦&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VMWare14 安装 Mac OS 系统</title>
    <link href="http://www.tjl-myblog.cn/VMWare14-%E5%AE%89%E8%A3%85-Mac-OS-%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://www.tjl-myblog.cn/VMWare14-安装-Mac-OS-系统.html</id>
    <published>2019-06-04T06:47:21.000Z</published>
    <updated>2019-12-21T11:04:47.923Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://blog.csdn.net/qq_31362105/article/details/80706096" rel="external nofollow noopener noreferrer" target="_blank">下载VMware Workstation 14中文破解版</a><br><a href="https://www.jb51.net/softjc/638971.html" rel="external nofollow noopener noreferrer" target="_blank">下载Unlocker 300</a><br><a href="https://pan.baidu.com/s/13_d-qwWXy_t8rM0js4k5EQ" rel="external nofollow noopener noreferrer" target="_blank">下载OS X 10.13 、OS X 10.14镜像</a> 需要cdr的<br>提取码: cg3e</p><ul><li>安装VMware Workstation 14中文破解版</li><li>安装Unlocker (Vmware虚拟机安装Mac OS破解补丁)</li><li>停止 VMware 服务<ul><li>win+R，输入 services.msc ,打开服务</li><li>停止 VMware 相关服务<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/1.png" alt="图片还没有哦"><br>没有开启软件前可以跳过这一步<ul><li>运行unlocker</li></ul></li><li>解压unlocker到VM安装目录</li><li>以管理员方式运行 Unlocker 文件下 win-install.cmd</li><li>如图下就表示成功了<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/2.png" alt="图片还没有哦"><ul><li>打开 VMware 创建 Mac 虚拟机<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/3.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/4.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/5.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/6.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/7.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/8.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/9.png" alt="图片还没有哦"><br>安装之前先转成iso<a href="https://baijiahao.baidu.com/s?id=1606129764903744804&amp;wfr=spider&amp;for=pc" rel="external nofollow noopener noreferrer" target="_blank">苹果macos dmg文件转换成ISO文件教程</a><br><a href="https://cn.ultraiso.net/xiazai.html" rel="external nofollow noopener noreferrer" target="_blank">免费下载UltraISO软碟通官方中文版</a><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/9.2.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/9.3.png" alt="图片还没有哦"><br>然后等待转换完成就好了完成就好了<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/10.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/11.png" alt="图片还没有哦"></li><li>如果出现错误:找到虚拟机安装目录<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/12.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/13.png" alt="图片还没有哦"></li><li>如果出现蓝屏卡在Boot Manager那可能就是你镜像文件出错,需要从新下载一个<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/14.png" alt="图片还没有哦"></li><li>这样的话就表示镜像阔以用<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/15.png" alt="图片还没有哦"></li><li>进行MAC安装<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/16.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/17.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/18.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/19.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/20.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/21.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/22.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/23.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/24.png" alt="图片还没有哦"></li><li>把之前停止的VMware 服务启动就好(关键点在这,把之前停掉的服务启动) 也可以设置一下网络(正常情况下不用设置就已经可以联网了) 服务没启动可能会链接不上网络<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VMWare14安装MacOS系统/25.png" alt="图片还没有哦"></li></ul></li></ul></li></ul><p>参考：<br><a href="https://jingyan.baidu.com/article/ca2d939d79c9e3eb6c31ce32.html" rel="external nofollow noopener noreferrer" target="_blank">VMWare14 安装 Mac OS 系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.tjl-myblog.cn:4455/one.jpg&quot; alt=&quot;图片还没有哦&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Json转Excel</title>
    <link href="http://www.tjl-myblog.cn/Json%E8%BD%ACExcel.html"/>
    <id>http://www.tjl-myblog.cn/Json转Excel.html</id>
    <published>2019-05-09T09:20:55.000Z</published>
    <updated>2019-12-21T11:04:47.920Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装json2excel模块：npm install json2excel</span></span><br><span class="line"><span class="keyword">var</span> jexcel = <span class="built_in">require</span>(<span class="string">'json2excel'</span>); <span class="comment">//导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    sheets: [&#123;</span><br><span class="line">        header: &#123; <span class="comment">//标头</span></span><br><span class="line">            <span class="string">'author'</span>: <span class="string">'authorName'</span>,</span><br><span class="line">            <span class="string">'title'</span>: <span class="string">'title'</span>,</span><br><span class="line">            <span class="string">'aa'</span>:<span class="string">'备注'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        items: [ <span class="comment">//行 内容</span></span><br><span class="line">        &#123;</span><br><span class="line">            author:<span class="string">'john'</span>,</span><br><span class="line">            title:<span class="string">'how to use this'</span>,</span><br><span class="line">            aa:<span class="string">'cc'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            author:<span class="string">'Bob'</span>,</span><br><span class="line">            title: <span class="string">'so Easy'</span>,</span><br><span class="line">            aa:<span class="string">'dd'</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        ],</span><br><span class="line">        sheetName: <span class="string">'sheet1'</span>, <span class="comment">//表名</span></span><br><span class="line">    &#125;],</span><br><span class="line">    filepath: <span class="string">'j2x.xlsx'</span> <span class="comment">//文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jexcel.j2e(data,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finish'</span>) <span class="comment">//完成打印</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.com/package/json2excel" rel="external nofollow noopener noreferrer" target="_blank">参考</a></p>]]></content>
    
    <summary type="html">
    
      Json转Excel
    
    </summary>
    
      <category term="JSON" scheme="http://www.tjl-myblog.cn/categories/JSON/"/>
    
    
      <category term="JSON" scheme="http://www.tjl-myblog.cn/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>用Xshell连接Ubuntu虚拟机</title>
    <link href="http://www.tjl-myblog.cn/%E7%94%A8Xshell%E8%BF%9E%E6%8E%A5Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA.html"/>
    <id>http://www.tjl-myblog.cn/用Xshell连接Ubuntu虚拟机.html</id>
    <published>2019-05-08T02:00:36.000Z</published>
    <updated>2019-12-21T11:04:47.932Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这里用的虚拟机Ubuntu14<br>远程连接的默认端口为 22</p></blockquote><h2 id="安装好虚拟机"><a href="#安装好虚拟机" class="headerlink" title="安装好虚拟机"></a>安装好虚拟机</h2><ul><li>下载<a href="https://blog.csdn.net/qq_31362105/article/details/80706096" rel="external nofollow noopener noreferrer" target="_blank">VM</a></li><li>下载<a href="https://www.ubuntu.com/download/alternative-downloads" rel="external nofollow noopener noreferrer" target="_blank">Ubuntu镜像</a> 下载bt种子之后用迅雷下载</li><li>安装虚拟机<br>  打开VM开始新建安装<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/1.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/2.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/3.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/4.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/5.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/6.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/7.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/8.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/9.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/10.png" alt="图片还没有哦"></li></ul><h2 id="使用Xshell工具"><a href="#使用Xshell工具" class="headerlink" title="使用Xshell工具"></a>使用Xshell工具</h2><ul><li>下载<a href="http://www.onlinedown.net/soft/36383.htm" rel="external nofollow noopener noreferrer" target="_blank">Xshell工具</a></li><li>查看虚拟机的IP<code>ifconfig -a</code><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/11.png" alt="图片还没有哦"></li><li>安装虚拟机的SSH工具<ul><li>打开终端输入 <code>sudo apt-get update</code> 更新工具包</li><li>然后再输入<code>sudo apt-get install openssh-server -y</code> 安装ssh服务</li><li><code>sudo ps -e |grep ssh</code> 有sshd,说明ssh服务已经启动，如果没有启动，输入<code>sudo service ssh start</code> ssh服务就会启动</li></ul></li><li><p>创建秘钥进行关联</p><ul><li><code>ssh-keygen</code> 创建秘钥对<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/17.png" alt="图片还没有哦"><br>现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</li><li>在服务器上安装公钥<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/18.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/19.png" alt="图片还没有哦"></li><li><p>设置SSH配置文件 打开秘钥连接<br><code>sudo gedit /etc/ssh/sshd_config</code> 打开配置文件<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/20.png" alt="图片还没有哦"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这四项要修改下 具体修改看个人使用情况</span></span><br><span class="line">RSAAuthentication yes <span class="comment"># RSA身份验证</span></span><br><span class="line">PubkeyAuthentication yes <span class="comment"># 是否可以通过秘钥连接</span></span><br><span class="line">PermitRootLogin yes <span class="comment"># 用户能否通过 SSH 登录</span></span><br><span class="line">PasswordAuthentication no <span class="comment"># 是否禁用密码登陆</span></span><br></pre></td></tr></table></figure><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/21.png" alt="图片还没有哦"><br>进入虚拟机 <code>cd .ssh</code> 然后 <code>sudo gedit id_rsa</code> 打开公钥，手动复制公钥带客户机，客户机新建一个文件为 <code>id_rsa</code> 粘贴内容。这个文件后面用Xshell连接虚拟机验证秘钥的时候有用。</p><p>重启ssh服务 <code>service sshd restart 或 /etc/init.d/ssh restart 重启ssh服务</code></p><p><a href="https://blog.csdn.net/permike/article/details/52386868" rel="external nofollow noopener noreferrer" target="_blank">ubuntu设置 SSH 通过密钥登录</a></p></li></ul></li><li><p>使用Xshell工具进行连接<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/11.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/12.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/13.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/14.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/15.png" alt="图片还没有哦"><br>  如果用户名对应不上就会出现 SSH访问拒绝密码访问 或 所选的用户密钥未在远程主机上注册<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/用Xshell连接Ubuntu虚拟机/16.png" alt="图片还没有哦"></p></li><li><p>使用lrzsz上传下载文件<br>  <code>sudo apt-get install lrzsz</code> 安装lrzsz工具包即可使用rz和sz<br>  <a href="http://www.tjl-myblog.cn/使用Xshell连接服务器上传并下载文件.html">使用Xshell连接服务器上传并下载文件</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      用Xshell连接Ubuntu虚拟机
    
    </summary>
    
      <category term="Xshell" scheme="http://www.tjl-myblog.cn/categories/Xshell/"/>
    
    
      <category term="Xshell" scheme="http://www.tjl-myblog.cn/tags/Xshell/"/>
    
  </entry>
  
  <entry>
    <title>使用Xshell连接服务器上传并下载文件</title>
    <link href="http://www.tjl-myblog.cn/%E4%BD%BF%E7%94%A8Xshell%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BC%A0%E5%B9%B6%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html"/>
    <id>http://www.tjl-myblog.cn/使用Xshell连接服务器上传并下载文件.html</id>
    <published>2019-05-07T06:45:40.000Z</published>
    <updated>2019-12-21T11:04:47.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>file_name 表示文件名 远程连接的默认端口为 22</p></blockquote><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ul><li>下载<a href="http://www.onlinedown.net/soft/36383.htm" rel="external nofollow noopener noreferrer" target="_blank">Xshell工具</a></li><li>使用Xshell工具连接好服务器之后在Xshell工具里面下载<a href="https://baike.baidu.com/item/lrzsz/5592701?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">lrzsz</a><ul><li>输入<code>yum install lrzsz -y</code> （<a href="https://baike.baidu.com/item/yum/2835771?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">yum</a>）</li><li>输入<code>rpm -qa | grep lrzsz</code> 检测是否能连接服务器，出现如图的提示，说明连接成功。<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用Xshell连接服务器上传并下载文件/1.png" alt="图片还没有哦"></li></ul></li></ul><h2 id="上传文件rz"><a href="#上传文件rz" class="headerlink" title="上传文件rz"></a>上传文件rz</h2><p>切换到你想要保存文件的目录（想保存到服务器哪个目录 可以新建文件夹<code>mkdir file_name</code>）然后使用 <code>rz</code> 命令之后，选择需要上传的文件即可。</p><h2 id="下载文件sz"><a href="#下载文件sz" class="headerlink" title="下载文件sz"></a>下载文件sz</h2><p>使用 <code>sz file_name</code> 命令之后，选择需要保存文件的路径即可。</p>]]></content>
    
    <summary type="html">
    
      使用Xshell连接服务器上传并下载文件
    
    </summary>
    
      <category term="Xshell" scheme="http://www.tjl-myblog.cn/categories/Xshell/"/>
    
    
      <category term="Xshell" scheme="http://www.tjl-myblog.cn/tags/Xshell/"/>
    
  </entry>
  
  <entry>
    <title>使用CNAME记录的好处</title>
    <link href="http://www.tjl-myblog.cn/%E4%BD%BF%E7%94%A8CNAME%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A5%BD%E5%A4%84.html"/>
    <id>http://www.tjl-myblog.cn/使用CNAME记录的好处.html</id>
    <published>2019-05-06T09:13:58.000Z</published>
    <updated>2020-12-26T03:59:54.864Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>下面会解释道A记录和CNAME记录然后再扩充下NS记录</p></blockquote><p>其实A记录和CNAME记录很相似</p><ul><li>A记录：就是把一个域名解析到一个IP下（通过访问这个域名就访问了这个IP 因为IP有不确定性很容易变 可以理解用域名来管理它）访问这个域名就是访问了这个IP</li><li>CNAME记录：就是把一个域名解析到另一个域名下（通过访问这个别名（子域名、二级域名以及更多级）然后就访问了另一个域名）例子：我给bbb.com（顶级域名）添加一条别名（CNAME）记录 主机记录为aaa 记录值为ccc.com 然后域名的别名就是 aaa.bbb.com 就是别名了 然后当我访问aaa.bbb.com的时候就相当于访问了ccc.com这个域名<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用CNAME记录的好处/1.png" alt="图片还没有哦"></li><li>NS记录：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。你可以理解为，假如我们买了阿里云的域名或腾讯云的域名我们需要用哪一家的DNS服务器来解析它，这个记录是必须的。</li></ul><h2 id="好处1"><a href="#好处1" class="headerlink" title="好处1"></a>好处1</h2><p>例：<br>别名记录(CNAME)：也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”(A记录)。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名(CNAME)：WWW和MAIL。 这两个别名的全称就是“<a href="http://www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。" rel="external nofollow noopener noreferrer" target="_blank">www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。</a></p><p>类推：<br>同样的方法你可以用于当你拥有多个域名需要指向同一服务器IP，此时你可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名到之前的A记录的域名上，那么当你访问这些别名的时候相当于访问了这个服务器IP。同理因为做了A记录所有如果你服务器IP发生了变化，你只需要更改那个A记录的IP就行了，这样就不必麻烦的一个一个域名更改指向。</p><p>虚拟主机:<br>如果你是租用的虚拟主机的话，一般的服务商都会提供一个三级或四级域名给你，那个域名地址的IP理所当然肯定是服务器的最新IP了，所有只需要直接用你的域名做别名记录（CNAME）指向到服务商给你的域名上就行了。</p><h2 id="好处2"><a href="#好处2" class="headerlink" title="好处2"></a>好处2</h2><blockquote><p>这里条好处说实话没怎么理解，没用过，知道的朋友还请留言讨论下。</p></blockquote><p>使用域名的别名记录(CNAME)，让你的域名解析不再蜗牛。<br>　　众所周知，国内很多域名注册机构的DNS服务器解析生效速度很慢，这便给很多人带来了麻烦，当网站需要更换IP或其他必须对域名重新解析的时候，如果存在大量网站，第一麻烦就是多域名的解析问题，我们可以通过第一条技巧轻松解决!但对于生效速度，通过普通的解析估计我们就无法解决了!<br>　　其实，我们可以通过使用域名的别名(CNAME)另类使用，达到加速解析的目的。首先我们最好选择一个主域名如：qqya.com，将该域名转移到国外(推荐：ENom)注册商平台下，解析速度与国内的注册商可不是一个两个等级的差别了，然后将其他的相关域名使用CNAME记录：(<a href="http://www.abc.com" rel="external nofollow noopener noreferrer" target="_blank">www.abc.com</a>. 这里只是一个例子)切记最后有一英文状态下的“句号”!<br>　　OK!以后当需要更换域名解析的时候，只需要变动abc.com，立即解决了所有问题，因为你其他的域名都已经跟随你的abc.com域名了，只要你解析了abc.com，其他也都相应变化，不再担心国内解析慢的问题了!（一对多关联 只需修改一个既可得到所关联的变化 很方便实用）</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul><li>解析域名现在我知道的就是（自身应用过）<ul><li>需要一个域名然后添加两条NS记录用腾讯的或阿里的DNS进行解析</li><li>然后再添加两条A记录分别是<ul><li>WWW记录（假如我们的域名是bbb.com 添加了这个记录，我们就可以使用<a href="http://www.bbb.com来访问了）" rel="external nofollow noopener noreferrer" target="_blank">www.bbb.com来访问了）</a></li><li>@记录（假如我们的域名是bbb.com 添加了这个记录，我们就可以直接使用bbb.com来访问了）</li><li>*记录（泛解析看个人需求）（假如我们的域名是bbb.com 添加了这个记录，我们就可以使用*.bbb.com进行访问 *可以为任意字符，例：a.bbb.com，b.bbb.com，az.bbb.com，… 等都可以进行访问）</li></ul></li><li>再根据自己的需要是否需要子域名（添加CNAME记录即可 上面已经说了CNAME记录的好处 看个人需求）</li></ul></li></ul><p>参考：<br><a href="https://blog.csdn.net/songzhichao4444/article/details/19198707" rel="external nofollow noopener noreferrer" target="_blank">使用CName记录的好处</a></p>]]></content>
    
    <summary type="html">
    
      使用别名记录对于很多网站、多域名来说是一个非常方便管理的方法。特别对于租用虚主机的用户，更是简单：做一个别名记录后，就不用再去管服务器的IP变化了。
    
    </summary>
    
      <category term="域名解析" scheme="http://www.tjl-myblog.cn/categories/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="CNAME记录" scheme="http://www.tjl-myblog.cn/tags/CNAME%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>libuv_TCP服务器搭建</title>
    <link href="http://www.tjl-myblog.cn/libuv-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html"/>
    <id>http://www.tjl-myblog.cn/libuv-TCP服务器搭建.html</id>
    <published>2019-04-29T02:41:18.000Z</published>
    <updated>2019-12-21T11:04:47.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      libuv_TCP服务器搭建
    
    </summary>
    
      <category term="libuv" scheme="http://www.tjl-myblog.cn/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://www.tjl-myblog.cn/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>Boost库的编译使用</title>
    <link href="http://www.tjl-myblog.cn/Boost%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8.html"/>
    <id>http://www.tjl-myblog.cn/Boost库的编译使用.html</id>
    <published>2019-04-26T06:45:37.000Z</published>
    <updated>2019-12-21T11:04:47.913Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>在经历了一天半的时间终于把boost库给编译好了 这里记录一下 如果想学习使用boost库的 可以查看官方文档 由于英语太差的本人只有用翻译了 很苦恼</p></blockquote><h2 id="编译Boost库"><a href="#编译Boost库" class="headerlink" title="编译Boost库"></a>编译Boost库</h2><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><ul><li>Windows7</li><li>Visual Studio 2017</li><li><a href="https://dl.bintray.com/boostorg/release/1.66.0/source/" rel="external nofollow noopener noreferrer" target="_blank">boost_1_66_0</a></li></ul><blockquote><p>提示：下载 <a href="https://dl.bintray.com/boostorg/release/1.66.0/source/" rel="external nofollow noopener noreferrer" target="_blank">boost_1_66_0</a>用 <code>Visual Studio Tools</code> 的 <code>VS_2017的开发人员命令提示符</code> 来编译 别用cmd命令窗口来编译<code>boost</code> 用其他VS版本也是可以的<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/1.png" alt="图片还没有哦"></p></blockquote><h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><p>解压 boost库 使用 <code>VS_2017的开发人员命令提示符</code> 窗口切换到<code>bootstrap.bat</code> 文件目录下 我的是在E盘下 这里做个示范</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d E:\boost_1_66_0   // <span class="built_in">cd</span> /d 表示切换到任意路径下 后面分路径即可</span><br></pre></td></tr></table></figure><p>然后执行 <code>bootstrap.bat</code>（窗口内输入文件名然后回车就是执行了）稍等片刻后就会生成 <code>b2.exe bjam.exe project-config.jam bootstrap.log</code>四个文件。其中<code>b2.exe</code>和<code>bjam.exe</code>两个作用一样，<code>bjam.exe</code>对应的是老版本，<code>b2.exe</code>是<code>bjam.exe</code>的升级版本</p><blockquote><p>这里如果你懒得切换目录也可以直接把 <code>bootstrap.bat</code> 拖进窗口 路径会自动生成 然后回车就会生成文件了</p></blockquote><h3 id="使用bjam-或者b2-编译-Boost"><a href="#使用bjam-或者b2-编译-Boost" class="headerlink" title="使用bjam(或者b2)编译 Boost"></a>使用bjam(或者b2)编译 Boost</h3><h4 id="简便编译方法"><a href="#简便编译方法" class="headerlink" title="简便编译方法"></a>简便编译方法</h4><blockquote><p>其实可以直接 <code>bjam.exe</code> 运行进行编译也可以直接用 但是可能编译出来的版本并不是你想要的 如果你想编译不同的版本 如果你想急于使用可以直接跳到<a href="#use_boost">Boost库的使用</a>但是我还是建议你把它看完 这样你会对编译boost库有个比较完整的理解。</p></blockquote><h4 id="命令编译方法"><a href="#命令编译方法" class="headerlink" title="命令编译方法"></a>命令编译方法</h4><p>生成好编译程序以后，可以使用命令行来编译Boost了。在当前VisualStudio的工具中输入下面示例命令行即可执行编译:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 注意空格 多余空格会报错的</span><br><span class="line">bjam stage --toolset=msvc-<span class="number">14</span>.<span class="number">0</span> --with-thread --stagedir="D:\boost_1_66_1" link=static runtime-link=static runtime-link=shared threading=multi debug release</span><br><span class="line">-- 我用的</span><br><span class="line">bjam stage --toolset=msvc-<span class="number">12</span>.<span class="number">0</span> --without-python --without-mpi --without-wave --without-graph --without-math --without-regex --without-test --without-program_options --without-serialization --without-signals --stagedir="D:\boost_1_66_2" link=static runtime-link=static runtime-link=shared threading=multi debug release</span><br></pre></td></tr></table></figure><p>这里对命令进行说明：</p><h5 id="stage-install"><a href="#stage-install" class="headerlink" title="stage/install"></a>stage/install</h5><p><code>stage</code>表示只生成库（dll和lib）， <code>install</code>还会生成包含头文件的<code>include</code>目录。推荐使用<code>stage</code>，因为<code>install</code>生成的这个<code>include</code>目录实际就是<code>boost</code>安装包解压缩后的<code>boost</code>目录<code>（X:\boost_X_XX_X\boost</code>，只比<code>include</code>目录多几个非hpp文件，都很小），所以可以直接使用，而且不同的IDE都可以使用同一套头文件，这样既节省编译时间，也节省硬盘空间。</p><h5 id="–toolset"><a href="#–toolset" class="headerlink" title="–toolset"></a>–toolset</h5><p>指定编译器，可选的如<code>borland、gcc、msvc（VC6）、msvc-9.0（VS2008msvc-10.0（VS2010）、msvc-11.0（VS2012）、msvc-12.0（VS2013）、msvc-14.0（VS2015）、msvc-14.1（VS2017）</code>等。</p><h5 id="address-model"><a href="#address-model" class="headerlink" title="address-model"></a>address-model</h5><p>表示多少位 address-model=32 address-model=64 默认32/64都编译</p><h5 id="–without-with"><a href="#–without-with" class="headerlink" title="–without/with"></a>–without/with</h5><p>选择不编译/编译哪些库。因为<code>python、mpi</code>等库我都用不着，所以排除之。还有<code>wave、graph、math、regex、test、program_options、serialization、signals</code>这几个库编出的静态lib都非常大，所以不需要的也可以<code>without</code>。这可以根据各人需要进行选择，默认是全部编译。但是需要注意，如果选择编译<code>python</code>的话，是需要<code>python</code>语言支持的，可以到<a href="https://www.python.org/" rel="external nofollow noopener noreferrer" target="_blank">python官方主页</a>下载安装。查看<code>boost</code>包含库的命令是<code>bjam --show-libraries</code>。</p><h5 id="–stagedir-prefix"><a href="#–stagedir-prefix" class="headerlink" title="–stagedir/prefix"></a>–stagedir/prefix</h5><p><code>stage</code>时使用<code>stagedir</code>，<code>install时</code>使用<code>prefix</code>，表示编译生成文件的路径。推荐给不同的IDE指定不同的目录，如VS2017对应的是 <code>x:\boost_1_66_0\lib\msvc-14.1</code>。默认在<code>stage</code>目录下</p><h5 id="build-dir"><a href="#build-dir" class="headerlink" title="build-dir"></a>build-dir</h5><p>编译生成的中间文件的路径。默认就在根目录（X:\boost_X_XX_X\boost）下，目录名为bin.v2，等编译完成后可将这个目录全部删除（没用了），所以不需要去设置。</p><h5 id="–build-type-complete"><a href="#–build-type-complete" class="headerlink" title="–build-type=complete"></a>–build-type=complete</h5><p>表示生成debug release static shared的各种版本</p><h5 id="link"><a href="#link" class="headerlink" title="link"></a>link</h5><p>生成动态链接库/静态链接库。生成动态链接库需使用<code>shared</code>方式，生成静态链接库需使用<code>static</code>方式。一般<code>boost</code>库可能都是以<code>static</code>方式编译，因为最终发布程序带着<code>boost</code>的dll感觉会比较累赘。</p><h5 id="runtime-link"><a href="#runtime-link" class="headerlink" title="runtime-link"></a>runtime-link</h5><p><code>C/C++</code>运行库 动态/静态链接。同样有<code>shared</code>和<code>static</code>两种方式，这样<code>runtime-link</code>和<code>link</code>一共可以产生4种组合方式，各人可以根据自己的需要选择编译。</p><h5 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h5><p>单/多线程编译。一般都写多线程程序，当然要指定<code>multi</code>方式了；如果需要编写单线程程序，那么还需要编译单线程库，可以使用<code>single</code>方式。</p><h5 id="debug-release"><a href="#debug-release" class="headerlink" title="debug/release"></a>debug/release</h5><p>编译debug/release版本。一般都是程序的debug版本对应库的debug版本，所以两个都编译。</p><p><span id="use_boost"><br>    <h2>Boost库的使用</h2><br></span></p><h3 id="通过包含文件路径来使用（绝对路径）"><a href="#通过包含文件路径来使用（绝对路径）" class="headerlink" title="通过包含文件路径来使用（绝对路径）"></a>通过包含文件路径来使用（绝对路径）</h3><p>头文件的链接</p><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/2.png" alt="图片还没有哦"></p><p>静态库的链接</p><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/3.png" alt="图片还没有哦"></p><h3 id="通过设置环境变量来使用（宏链接）"><a href="#通过设置环境变量来使用（宏链接）" class="headerlink" title="通过设置环境变量来使用（宏链接）"></a>通过设置环境变量来使用（宏链接）</h3><blockquote><p>配置好宏之后看看有没有路径 如果没有请重启下IDE<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/3.5.png" alt="图片还没有哦"></p></blockquote><p>boost编译出来非常大，除去bin.v2后文件体积还有2G左右，不适合到处放，新建两个环境变量然后引用就可以了</p><p>添加环境变量<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/4.png" alt="图片还没有哦"></p><p>IDE里面宏引用<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/5.png" alt="图片还没有哦"></p><p>我使用的环境变量：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 变量名 BOOST_ROOT 变量值 D:\boost_1_66_0</span><br><span class="line">$(BOOST_ROOT)=D:\boost_1_66_0</span><br><span class="line">-- 变量名 BOOST_ROOT_LIB 变量值 D:\boost_1_66_0\stage\lib</span><br><span class="line">$(BOOST_ROOT_LIB)=D:\boost_1_66_0\stage\lib</span><br></pre></td></tr></table></figure><h4 id="用绝对路径和使用宏的区别："><a href="#用绝对路径和使用宏的区别：" class="headerlink" title="用绝对路径和使用宏的区别："></a>用绝对路径和使用宏的区别：</h4><ul><li>绝对路径：当在网上下载其他人写的代码的时候，在工程配置中，不会有绝对路径，需要重新配置。</li><li>宏：不需要重新配置了。只要新下载的工程的配置文件中有用宏引用就可以了（前提是有先配置Boost库的环境变量）。</li></ul><p>使用代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"boost/thread.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" hello,thread! "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::function&lt;<span class="keyword">void</span>()&gt; f(mythread);</span><br><span class="line">    boost::<span class="function">thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" thread is over! "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Boost库的编译使用/6.png" alt="图片还没有哦"></p><p>如果你运行成功的话那么你的Boost库就成功的编译了 以后想使用添加到自己的项目里面即可</p><ul><li><p>如果你遇到 编译错误有什么不兼容的 这个一般只会出现在使用简单编译方法</p><p>  原因可能就是：</p><ul><li><p>版本对应不上 出现你需要仔细检查下你的版本</p><p>解决方法：</p></li><li>使用命令编译方法 编译对应的版本</li></ul></li><li><p>如果出现无法打开文件 xxx.lib的请查看你的lib目录下到底有没有那个lib 如果有请查看你的 <code>项目属性 --&gt; C/C++ --&gt; 代码生成 --&gt; 运行库</code> 的类型</p></li></ul><p>bjam参数：<br>命令|说明<br>—|—|—<br>–build-dir=<builddir> | 编译的临时文件会放在builddir里(这样比较好管理，编译完就可以把它删除了)<br>–stagedir=<stagedir> | 存放编译后库文件的路径，默认是stage<br>–build-type=complete | 编译所有版本，不然只会编译一小部分版本（确切地说是相当于:variant=release, threading=multi;link=shared|static;runtime-link=shared）<br>variant=debug|release | 决定编译什么版本(Debug or Release?)<br>link=static|shared | 决定使用静态库还是动态库。<br>threading=single|multi | 决定使用单线程还是多线程库。<br>runtime-link=static|shared | 决定是静态还是动态链接C/C++标准库。<br>–with-<library> | 只编译指定的库，如输入–with-regex就只编译regex库了。<br>–show-libraries | 显示需要编译的库名称</library></stagedir></builddir></p><blockquote><p>你可能并没有这么顺利会遇到很多奇怪的问题 下面我给出些链接希望对你有帮助<br><a href="https://blog.csdn.net/u013700908/article/details/82751159" rel="external nofollow noopener noreferrer" target="_blank">LNK1104 无法打开文件“libboost_system-vc141-mt-gd-x64-1_68.lib</a><br><a href="https://blog.csdn.net/pzhw520hchy/article/details/79998116" rel="external nofollow noopener noreferrer" target="_blank">boost安装提示 Building Boost.Build engine ‘cl’ 不是内部或外部命令，也不是可运行的程序 或批处理文件</a></p></blockquote><p>参考<br><a href="https://www.cnblogs.com/sanghg/p/5475044.html" rel="external nofollow noopener noreferrer" target="_blank">boost编译随笔</a><br><a href="https://blog.csdn.net/wojiuguowei/article/details/53195416" rel="external nofollow noopener noreferrer" target="_blank">配置boost环境变量</a></p>]]></content>
    
    <summary type="html">
    
      Boost库的编译和使用
    
    </summary>
    
      <category term="Boost库" scheme="http://www.tjl-myblog.cn/categories/Boost%E5%BA%93/"/>
    
    
      <category term="Boost库" scheme="http://www.tjl-myblog.cn/tags/Boost%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VS编译libuv</title>
    <link href="http://www.tjl-myblog.cn/VS%E7%BC%96%E8%AF%91libuv.html"/>
    <id>http://www.tjl-myblog.cn/VS编译libuv.html</id>
    <published>2019-04-25T02:45:50.000Z</published>
    <updated>2019-12-21T11:04:47.924Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p><a href="http://docs.libuv.org/en/v1.x/" rel="external nofollow noopener noreferrer" target="_blank">libuv</a> 是 <code>node.js</code>的底层库</p><h2 id="VS编译libuv"><a href="#VS编译libuv" class="headerlink" title="VS编译libuv"></a>VS编译libuv</h2><blockquote><p>在建立工程的时候一定要把路径分明白：一般项目有三个目录 <code>proj.projname</code> 创建新工程后 退出VS然后来到项目路径创建路径 <code>src</code> 工程的源代码 <code>3rd</code> 第三方文件例如 <code>libuv</code> 在项目里面头文件其实是不用加的 因为加了也不会编译头文件 但是一般为了方便我们查看头文件 还是应该加载项目工程下</p></blockquote><ul><li>先在官网把 <code>libuv</code> 的源码下载下来</li><li>新建项目创建好区分好文件夹后 我们把 <code>libuv</code> 里面的 <code>include</code> 和 <code>src</code> 文件拷贝到项目文件的 <code>3rd</code> 下面</li><li>在工程里面我们也区分好创建筛选器进行区分</li><li>包含文件<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VS编译libuv/2.png" alt="图片还没有哦"></li><li>项目包含头文件路径<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VS编译libuv/3.png" alt="图片还没有哦"></li></ul><p><code>libuv</code> 编译需要的 <code>lib（#pragma comment(lib,&quot;libname&quot;)</code> 只对VS有用 所以在项目属性里面用链接器链接）：</p><ul><li>ws2_32.lib</li><li>IPHLPAPI.lib</li><li>Psapi.lib</li><li>Userenv.lib</li></ul><p>VS链接lib<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/VS编译libuv/1.png" alt="图片还没有哦"></p><p><code>libuv</code>编写思想：</p><ul><li>创建一个对象例如socket</li><li>给一个loop管理(事件循环)这个对象</li><li>并指定一个回调函数 当事件发生的时候就调用这个回调函数(callback)</li></ul><p><a href="https://github.com/tangjialang/Exercise/blob/master/VS%E7%BC%96%E8%AF%91libuv.rar" rel="external nofollow noopener noreferrer" target="_blank">项目github地址</a></p>]]></content>
    
    <summary type="html">
    
      VS编译libuv
    
    </summary>
    
      <category term="libuv" scheme="http://www.tjl-myblog.cn/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://www.tjl-myblog.cn/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>C与数据库的交互</title>
    <link href="http://www.tjl-myblog.cn/C%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92.html"/>
    <id>http://www.tjl-myblog.cn/C与数据库的交互.html</id>
    <published>2019-04-22T08:39:16.000Z</published>
    <updated>2019-12-21T11:04:47.914Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p>首先附上百度文库的链接<br><a href="https://wenku.baidu.com/view/b4a11bdabb68a98270fefa2b.html?from=search" rel="external nofollow noopener noreferrer" target="_blank">c语言连接mysql数据库的实现方法</a></p><ul><li>首先要在项目下修改属性<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/C-C++与数据库的交互/3.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/C-C++与数据库的交互/4.png" alt="图片还没有哦"></li></ul><p>这样就设置好了 然后进行代码的书写 写完之后我们编译运行 结果会报一大堆错误<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/C-C++与数据库的交互/1.png" alt="图片还没有哦"></p><p>依照下面改终于还是改好了没有报错了<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/C-C++与数据库的交互/5.png" alt="图片还没有哦"></p><p><a href="https://blog.csdn.net/shujun19941226/article/details/51331468" rel="external nofollow noopener noreferrer" target="_blank">c++ 链接mysql：error LNK2019: 无法解析的外部符号</a></p><p>本以为终于好了 结果又来一个报错<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/C-C++与数据库的交互/2.png" alt="图片还没有哦"></p><p>把安装路径下的<code>MySQL Server 5.7\lib</code>的<code>libmysql.dll</code> 放在x64的项目工程里和exe一个目录下即可解决问题<br><a href="https://blog.csdn.net/hellokandy/article/details/80454038" rel="external nofollow noopener noreferrer" target="_blank">正确解决 应用程序无法正常启动（0xc000007b）的问题</a></p><p>然后就可以使用C脚本进行对数据库的操作了</p><p>附MySQL的API接口：<br>API|作用<br>—|—|—<br>mysql_affected_rows() | 返回被最新的UPDATE, DELETE或INSERT查询影响的行数<br>mysql_close() | 关闭一个服务器连接<br>mysql_connect() | 连接一个MySQL服务器。该函数不推荐；使用mysql_real_connect()代替<br>mysql_change_user() | 改变在一个打开的连接上的用户和数据库<br>mysql_create_db() | 创建一个数据库。该函数不推荐；而使用SQL命令CREATE DATABASE<br>mysql_data_seek() | 在一个查询结果集合中搜寻一任意行<br>mysql_debug() | 用给定字符串做一个DBUG_PUSH<br>mysql_drop_db() | 抛弃一个数据库。该函数不推荐；而使用SQL命令DROP DATABASE<br>mysql_dump_debug_info() | 让服务器将调试信息写入日志文件<br>mysql_eof() | 确定是否已经读到一个结果集合的最后一行。这功能被反对; mysql_errno()或mysql_error()可以相反被使用<br>mysql_errno() | 返回最近被调用的MySQL函数的出错编号<br>mysql_error() | 返回最近被调用的MySQL函数的出错消息<br>mysql_escape_string() | 用在SQL语句中的字符串的转义特殊字符<br>mysql_fetch_field() | 返回下一个表字段的类型<br>mysql_fetch_field_direct () | 返回一个表字段的类型，给出一个字段编号<br>mysql_fetch_fields() | 返回一个所有字段结构的数组<br>mysql_fetch_lengths() | 返回当前行中所有列的长度<br>mysql_fetch_row() | 从结果集合中取得下一行<br>mysql_field_seek() | 把列光标放在一个指定的列上<br>mysql_field_count() | 返回最近查询的结果列的数量<br>mysql_field_tell() | 返回用于最后一个mysql_fetch_field()的字段光标的位置<br>mysql_free_result() | 释放一个结果集合使用的内存<br>mysql_get_client_info() | 返回客户版本信息<br>mysql_get_host_info() | 返回一个描述连接的字符串<br>mysql_get_proto_info() | 返回连接使用的协议版本<br>mysql_get_server_info() | 返回服务器版本号<br>mysql_info() | 返回关于最近执行得查询的信息<br>mysql_init() | 获得或初始化一个MYSQL结构<br>mysql_insert_id() | 返回有前一个查询为一个AUTO_INCREMENT列生成的ID<br>mysql_kill() | 杀死一个给定的线程<br>mysql_list_dbs() | 返回匹配一个简单的正则表达式的数据库名<br>mysql_list_fields() | 返回匹配一个简单的正则表达式的列名<br>mysql_list_processes() | 返回当前服务器线程的一张表<br>mysql_list_tables() | 返回匹配一个简单的正则表达式的表名<br>mysql_num_fields() | 返回一个结果集合重的列的数量<br>mysql_num_rows() | 返回一个结果集合中的行的数量<br>mysql_options() | 设置对mysql_connect()的连接选项<br>mysql_ping() | 检查对服务器的连接是否正在工作，必要时重新连接<br>mysql_query() | 执行指定为一个空结尾的字符串的SQL查询<br>mysql_real_connect() | 连接一个MySQL服务器<br>mysql_real_query() | 执行指定为带计数的字符串的SQL查询<br>mysql_reload() | 告诉服务器重装授权表<br>mysql_row_seek() | 搜索在结果集合中的行，使用从mysql_row_tell()返回的值<br>mysql_row_tell() | 返回行光标位置<br>mysql_select_db() | 连接一个数据库<br>mysql_shutdown() | 关掉数据库服务器<br>mysql_stat() | 返回作为字符串的服务器状态<br>mysql_store_result() | 检索一个完整的结果集合给客户<br>mysql_thread_id() | 返回当前线程的ID<br>mysql_use_result() | 初始化一个一行一行地结果集合的检索</p><p><a href="https://blog.csdn.net/qq_35475767/article/details/52997863" rel="external nofollow noopener noreferrer" target="_blank">C++ 连接Mysql的两种方法–ADO/Mysql api</a><br><a href="https://www.cnblogs.com/yaradish/p/10078640.html" rel="external nofollow noopener noreferrer" target="_blank">查看mysql数据库是否存在某张表及某张表是否存在某个字段</a><br>附上本次例子的代码<br>C_interaction_MySQL.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言与MySQL数据库的交互</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _C_interaction_MySQL_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _C_interaction_MySQL_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_sql</span><span class="params">(<span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql语句 并打印查询结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql_result</span><span class="params">(<span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>C_interaction_MySQL.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"C_interaction_MySQL.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"WinSock2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysql.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一些数据库连接需要的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST_OR_IP <span class="meta-string">"localhost"</span> <span class="comment">//主机名或IP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 3355 <span class="comment">//端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"root"</span> <span class="comment">//用户名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"root"</span> <span class="comment">//密码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATABASE <span class="meta-string">"test"</span> <span class="comment">//连接数据库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_sql</span><span class="params">(<span class="keyword">char</span>* sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MYSQL my_connect; <span class="comment">//数据库的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res; <span class="comment">// 执行sql语句后的返回标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化mysql连接my_connect</span></span><br><span class="line">    mysql_init(&amp;my_connect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接检查是否真的连接成功</span></span><br><span class="line">    <span class="keyword">if</span> (!mysql_real_connect(&amp;my_connect, HOST_OR_IP, USERNAME, PASSWORD, DATABASE, PORT, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"连接失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"连接成功 \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置查询编码为utf8 这个支持中文</span></span><br><span class="line">        mysql_query(&amp;my_connect, <span class="string">"set names utf8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql语句</span></span><br><span class="line">        res = mysql_query(&amp;my_connect, sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            mysql_close(&amp;my_connect);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"执行失败"</span>);</span><br><span class="line">            system(<span class="string">"pause"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"执行成功 \n"</span>);</span><br><span class="line">            <span class="comment">//mysql_affected_rows 返回受影响的行数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d 行受到影响 \n"</span>, mysql_affected_rows(&amp;my_connect));</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            mysql_close(&amp;my_connect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sql_result</span><span class="params">(<span class="keyword">char</span>* sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MYSQL my_connect; <span class="comment">//数据库的连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res; <span class="comment">//执行sql语句后的返回标志</span></span><br><span class="line"></span><br><span class="line">    MYSQL_RES * res_ptr; <span class="comment">//查询结果的指针</span></span><br><span class="line"></span><br><span class="line">    MYSQL_FIELD * field; <span class="comment">// 子段结构体指针</span></span><br><span class="line"></span><br><span class="line">    MYSQL_ROW result_row; <span class="comment">//按行返回的查询信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row, column; <span class="comment">//查询返回的行和列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j; <span class="comment">// 只是控制循环的两个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化连接</span></span><br><span class="line">    mysql_init(&amp;my_connect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接检查是否真的连接成功</span></span><br><span class="line">    <span class="keyword">if</span> (!mysql_real_connect(&amp;my_connect, HOST_OR_IP, USERNAME, PASSWORD, DATABASE, PORT, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"连接失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"连接成功 \n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置查询编码为utf8 这个支持中文</span></span><br><span class="line">        mysql_query(&amp;my_connect, <span class="string">"set names utf8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql语句</span></span><br><span class="line">        res = mysql_query(&amp;my_connect, sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            mysql_close(&amp;my_connect);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"执行失败"</span>);</span><br><span class="line">            system(<span class="string">"pause"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"执行成功 \n"</span>);</span><br><span class="line">            <span class="comment">//mysql_affected_rows 返回受影响的行数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d 行受到影响 \n"</span>, (mysql_affected_rows(&amp;my_connect) == <span class="number">-1</span> ? <span class="number">0</span> : mysql_affected_rows(&amp;my_connect)));</span><br><span class="line"></span><br><span class="line">            res_ptr = mysql_store_result(&amp;my_connect);</span><br><span class="line">            <span class="keyword">if</span> (res_ptr) <span class="comment">//取得结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                column = mysql_num_fields(res_ptr);</span><br><span class="line">                row = mysql_num_rows(res_ptr) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"查询到的 %d 行 \n"</span>, row - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出结果的字段名</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; field = mysql_fetch_field(res_ptr); ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s \t"</span>, field-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                <span class="comment">//按行输出结果</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    result_row = mysql_fetch_row(res_ptr);</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; column; ++j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s \t"</span>, result_row[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            mysql_close(&amp;my_connect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"C_interaction_MySQL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// "select t.table_name from information_schema.TABLES t where t.TABLE_SCHEMA ='test' and t.TABLE_NAME ='tablename';"; //查询一个表是否存在</span></span><br><span class="line">    <span class="keyword">char</span>* aa = <span class="string">"create table test(id INT NOT NULL AUTO_INCREMENT, name VARCHAR(10) NOT NULL, age INT NOT NULL, PRIMARY KEY(id)) ENGINE = InnoDB; "</span>; <span class="comment">//创建表</span></span><br><span class="line">    execute_sql(aa);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* exe_sql = <span class="string">"insert into test(id,name,age) values(null,456,789);"</span>; <span class="comment">//插入一条数据</span></span><br><span class="line">    execute_sql(exe_sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* query = <span class="string">"select * from test where id = 1;"</span>; <span class="comment">//查询数据</span></span><br><span class="line">    query_sql_result(query);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/tangjialang/Exercise/blob/master/C与MySQL的交互(用的lib是5.7.25" rel="external nofollow noopener noreferrer" target="_blank">本次项目github</a>.rar)</p>]]></content>
    
    <summary type="html">
    
      MySQL数据库与C语言的交互
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="MySQL的交互" scheme="http://www.tjl-myblog.cn/tags/MySQL%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>使用ZIP安装包安装MySQL</title>
    <link href="http://www.tjl-myblog.cn/%E4%BD%BF%E7%94%A8ZIP%E5%AE%89%E8%A3%85%E5%8C%85%E5%AE%89%E8%A3%85MySQL.html"/>
    <id>http://www.tjl-myblog.cn/使用ZIP安装包安装MySQL.html</id>
    <published>2019-04-22T02:42:19.000Z</published>
    <updated>2019-12-21T11:04:47.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p>先在<a href="https://dev.mysql.com/downloads/mysql/" rel="external nofollow noopener noreferrer" target="_blank">MySQL的官网下载</a>ZIP安装包 然后解压到计算机目录下 在计算机的环境变量中手动配置系统变量<code>PATH</code>找到解压后的文件包找到bin目录 把路径赋值粘贴到后面即可</p><p><a href="https://www.cnblogs.com/lxlin/p/9635350.html" rel="external nofollow noopener noreferrer" target="_blank">mysql.zip版本的安装教程</a></p>]]></content>
    
    <summary type="html">
    
      使用ZIP安装包安装MySQL
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="安装MySQL" scheme="http://www.tjl-myblog.cn/tags/%E5%AE%89%E8%A3%85MySQL/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode书写Hexo博客文章</title>
    <link href="http://www.tjl-myblog.cn/%E4%BD%BF%E7%94%A8VSCode%E4%B9%A6%E5%86%99Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html"/>
    <id>http://www.tjl-myblog.cn/使用VSCode书写Hexo博客文章.html</id>
    <published>2019-04-20T09:44:14.000Z</published>
    <updated>2019-12-21T11:04:47.929Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p><a href="http://www.tjl-myblog.cn/Markdown基础语法.html">Markdown基础语法</a></p><p>下载好VSCode之后需要的插件：</p><ul><li><code>Chinese (Simplified) Language Pack for Visual Studio Code</code> 中文简体汉化包</li><li><code>Markdown All in One</code> Markdown 语法智能提示</li><li><code>Markdown Preview Enhanced</code> Markdown 书写文章预览</li><li><code>markdownlint</code> Markdown 语法检查</li></ul><p>添加VSCode工作区（方便代码管理）：</p><ul><li>将Hexo目录添加进VSCode(选择你自己的hexo目录)<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/1.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/2.png" alt="图片还没有哦"></li><li>将文件夹保存至工作区<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/3.png" alt="图片还没有哦"></li><li>每次打开保存的工作区即可操作很方便<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/4.png" alt="图片还没有哦"></li></ul><p>通过VSCode的终端控制Hexo</p><ul><li>新建终端<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/5.png" alt="图片还没有哦"></li><li>输入Hexo命令即可这样就不用Git了(目录要对的上 不对自己切换 cd /d 绝对路径名)<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/6.png" alt="图片还没有哦"></li></ul><p>通过VSCode的远程控制管理Hexo代码</p><ul><li>选择提交<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/7.png" alt="图片还没有哦"></li><li>提交文件<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/8.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/9.png" alt="图片还没有哦"></li><li>推送到远程代码库<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/10.png" alt="图片还没有哦"><br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/使用VSCode书写Hexo博客文章/11.png" alt="图片还没有哦"></li></ul>]]></content>
    
    <summary type="html">
    
      书写Markdown需要的插件
    
    </summary>
    
      <category term="VSCode写博客" scheme="http://www.tjl-myblog.cn/categories/VSCode%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="VSCode" scheme="http://www.tjl-myblog.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo写文章创建文件自动打开编辑器VSCode</title>
    <link href="http://www.tjl-myblog.cn/hexo%E5%86%99%E6%96%87%E7%AB%A0%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8VSCode.html"/>
    <id>http://www.tjl-myblog.cn/hexo写文章创建文件自动打开编辑器VSCode.html</id>
    <published>2019-04-20T08:21:57.000Z</published>
    <updated>2019-12-21T11:04:47.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>在hexo创建文章的使用我们都会使用到<code>hexo new &#39;article_name&#39;</code>对吧 然后通过相应的编辑器进行编辑如果你的文章很多呢，我们寻找就很浪费时间对吧 俗话说：一寸光阴一寸金 在寻找的时间我们又阔以多写几个字是吧 咳咳 好了不说了 开始正题吧。</p></blockquote><ul><li>在Hexo的根目录下创建一个新文件夹命名为 <code>Scripts</code> 在这个脚本里面放我们的脚本</li><li><p>上一步进行好了之后再 <code>Scripts</code> 文件夹下面创建一个 <code>auto_open.js</code> js文件 代码如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="comment">// Hexo 2.x 用户复制这段</span></span><br><span class="line"><span class="comment">//hexo.on('new', function(path)&#123;</span></span><br><span class="line"><span class="comment">//  spawn('start  "markdown编辑器绝对路径.exe" ' + path);</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"><span class="comment">//D:\WorkPlace\MarkdownPad\MarkdownPad2.exe 是MakdownPad编辑器在我本地的路径！</span></span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">spawn(<span class="string">'start "C:\Program Files\Microsoft VS Code\Code.exe" '</span> + data.path); <span class="comment">//这里我使用的是VSCode编辑器 这个路径是绝对路径哦</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>然后你就使用git新建hexo文章的时候就会自动打开你新建的文件，你不用去花多余的时间去寻找新建文件了。好了这次记录到这里，这个功能对我还是很有用的希望能帮到你们 我们下次见吧。</p><p>参考链接：<br><a href="https://www.jianshu.com/p/5fbb62791f9b" rel="external nofollow noopener noreferrer" target="_blank">hexo 写文章创建文件自动打开编辑器</a></p>]]></content>
    
    <summary type="html">
    
      自动打开VSCode编辑器
    
    </summary>
    
      <category term="VSCode写博客" scheme="http://www.tjl-myblog.cn/categories/VSCode%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="VSCode" scheme="http://www.tjl-myblog.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Windows机的MySQL5-7-25-0安装</title>
    <link href="http://www.tjl-myblog.cn/Windows%E6%9C%BA%E7%9A%84MySQL5-7-25-0%E5%AE%89%E8%A3%85.html"/>
    <id>http://www.tjl-myblog.cn/Windows机的MySQL5-7-25-0安装.html</id>
    <published>2019-04-20T07:49:52.000Z</published>
    <updated>2019-12-21T11:04:47.924Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>之前使用MySQL-5.6.43 ZIP 进行MySQL的安装（能进行只对MySQL的操作 用来初步学习MySQL用的）在想用C/C++操作数据库的时候遇到了困难 需要连接器什么的 所有这一次就用mis安装包进行一键安装（完整的Mysql功能） 记录一下安装的过程 下一篇会记录如何用C/C++来操作数据库 <a href="https://dev.mysql.com/downloads/mysql/" rel="external nofollow noopener noreferrer" target="_blank">MySQL5.7.25.0安装包</a></p></blockquote><h2 id="选择安装接受协议"><a href="#选择安装接受协议" class="headerlink" title="选择安装接受协议"></a>选择安装接受协议</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/1.png" alt="图片还没有哦"></p><h2 id="选择设置类型"><a href="#选择设置类型" class="headerlink" title="选择设置类型"></a>选择设置类型</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/2.png" alt="图片还没有哦"></p><p>一般我们使用第一个默认安装就行了（这里我使用的就是默认安装功能应该足够用了）也可以自定义或完整的安装 下面只进行两种介绍</p><h3 id="默认安装"><a href="#默认安装" class="headerlink" title="默认安装"></a>默认安装</h3><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/3.1.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/3.2.png" alt="图片还没有哦"></p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/2.1.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/2.2.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/2.3.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/2.4.png" alt="图片还没有哦"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/4.png" alt="图片还没有哦"></p><h2 id="等待安装完毕后进行的相关配置"><a href="#等待安装完毕后进行的相关配置" class="headerlink" title="等待安装完毕后进行的相关配置"></a>等待安装完毕后进行的相关配置</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/5.png" alt="图片还没有哦"></p><h2 id="配置类型和网络"><a href="#配置类型和网络" class="headerlink" title="配置类型和网络"></a>配置类型和网络</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/6.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/6.1.png" alt="图片还没有哦"></p><h2 id="设置管理员密码和添加用户"><a href="#设置管理员密码和添加用户" class="headerlink" title="设置管理员密码和添加用户"></a>设置管理员密码和添加用户</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/7.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/7.1.png" alt="图片还没有哦"></p><h2 id="配置Windows服务"><a href="#配置Windows服务" class="headerlink" title="配置Windows服务"></a>配置Windows服务</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/8.png" alt="图片还没有哦"></p><h2 id="插件和扩展"><a href="#插件和扩展" class="headerlink" title="插件和扩展"></a>插件和扩展</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/9.png" alt="图片还没有哦"></p><h2 id="执行完成安装"><a href="#执行完成安装" class="headerlink" title="执行完成安装"></a>执行完成安装</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Windows机的MySQL5-7-25-0安装/10.png" alt="图片还没有哦"></p>]]></content>
    
    <summary type="html">
    
      MySQL数据库的安装
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="安装MySQL" scheme="http://www.tjl-myblog.cn/tags/%E5%AE%89%E8%A3%85MySQL/"/>
    
  </entry>
  
  <entry>
    <title>手机CPU调速器 超频必备</title>
    <link href="http://www.tjl-myblog.cn/%E6%89%8B%E6%9C%BACPU%E8%B0%83%E9%80%9F%E5%99%A8-%E8%B6%85%E9%A2%91%E5%BF%85%E5%A4%87.html"/>
    <id>http://www.tjl-myblog.cn/手机CPU调速器-超频必备.html</id>
    <published>2019-04-01T08:19:57.000Z</published>
    <updated>2019-12-21T11:04:47.931Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>CPU调速器(CPU Governor)就是为CPU制定的一套行为规则, CPU会按照这个规则运行。另外,既然是简单介绍,所以原理性的东西统统靠边,只在乎作用,只在乎效果。最后还要说明的是, CPU调速器本身没有好坏之分,只有适合或者不适合,所以大家不要纠结什么调速器最好这样的问题,选择合适的即可,如果拿不定主意的话可以换着尝试一下。</p></blockquote><p>以下列出的是常见的CPU调速器:<br><strong>Ondemand</strong>:最常见的CPU调速器,几乎所有的官方内核都默认使用这种调速器。规则很简单,有高需求时迅速跳到最大频率,低需求时迅速降到最小频率。</p><p><strong>Conservative</strong>:很常见的调速器,规则是”慢升快降”,注重省电,当有高需求时逐渐提高频率,当低需求迅速跳至低频率。</p><p><strong>Interactive</strong>:很常见的调速器,规则和Conservation相反,是“快升慢降”,注重响应速度(性能) ,当有高需求时迅速跳到高频率,当低需求时逐渐降低频。</p><p><strong>Lulzactive</strong>:较新的一款调速器,根据负载逐级升高或降低频率,每一级频率有一个限制值,负载高于限制值就提高一级频率,低于限制值就降低一级频率。所以这个调速器在各个频率上的停留时间都很短。这个调速器的特点是在各个频率之间频繁变动,但是运行于最高和最低频的时间最多。</p><p><strong>Minmax</strong>:较新的一款调速器,规则很简单,要么最高要么最低。</p><p><strong>SmartassV2</strong>:因为SmartassV2是Smartass的升级版,所以很多较新内核都直接支持SmartassV2, Smartass主要是较早的内核支持,故这里只介绍V2。SmartassV2会使频率趋近与某一特定的值,使CPU频率大部分维持在这一特定值附近。同时SmartassV2在屏幕开启和关闭时有不同的特定值,以达到省电的目的。</p><p><strong>Lazy</strong>:很少用的调速器,对于频率上升和下降的响应都很迟缓,可以忽略掉部分迅速变化的频率变化,优点是省电。</p><p><strong>Lagfree</strong>:很少用的调速器,简单的描述就是不紧不慢型,无论负载变化快慢与否, CPU都按一定的停顿时间逐级升高或降低频率。</p><p><strong>Userspace</strong>:很常见的调速器,但是这个调速器不包含任何CPU变化规则,所以全靠自己设定,不推荐。</p><p><strong>Powersave</strong>:很常见的调速器,正如其名字一样,很省电,因为它的作用就是把频率锁定在设定范围的最小值,负载再高也不升高频率。</p><p><strong>Performance</strong>:很常见的调速器,性能最好也最费电,因为它将CPU频率锁定在设定范围的最大值,无论有多少负载, CPU都全速运行。</p><p><strong>Wheatley</strong>:较新的一款调速器,它的规则和Ondemand一样,但是响应速度稍慢,比Ondemand省电。</p><p><strong>Hotplug</strong>:基于ondemand的优化版,当有高需求时直接跳到最高频率,当需求见效时逐级降低频率。</p><p><strong>Pegasusq</strong>:源自三星猎户座处理器的一个调速器,可以单独调控单个CPU内核,理论上性能不错也很省电。</p><p><strong>在这里向大家推荐几种CPU设置方案</strong>:<br><strong>注重性能的玩家</strong>: Ondemand, Interactive, MinmaxHotplug<br><strong>注重性能和电量平衡的玩家</strong>: SmartassV2, Lulzactivel<br><strong>注重电量的玩家</strong>: Conservative, Wheatley</p>]]></content>
    
    <summary type="html">
    
      把你手机的CPU发挥到极致
    
    </summary>
    
      <category term="手机" scheme="http://www.tjl-myblog.cn/categories/%E6%89%8B%E6%9C%BA/"/>
    
    
      <category term="超频" scheme="http://www.tjl-myblog.cn/tags/%E8%B6%85%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>个人方便办公的电脑工具</title>
    <link href="http://www.tjl-myblog.cn/%E4%B8%AA%E4%BA%BA%E6%96%B9%E4%BE%BF%E5%8A%9E%E5%85%AC%E7%9A%84%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7.html"/>
    <id>http://www.tjl-myblog.cn/个人方便办公的电脑工具.html</id>
    <published>2019-03-26T06:38:03.000Z</published>
    <updated>2019-12-21T11:04:47.928Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p><a href="https://www.voidtools.com/zh-cn/downloads/" rel="external nofollow noopener noreferrer" target="_blank">Everything</a> 电脑文件搜索神器<br><a href="https://getquicker.net/" rel="external nofollow noopener noreferrer" target="_blank">Quicker</a> 鼠标右键神器 配合Everything简直太好用<br><a href="https://ditto-cp.sourceforge.io/" rel="external nofollow noopener noreferrer" target="_blank">Ditto</a> 复制粘贴记录好帮手<br><a href="https://pc.qq.com/detail/5/detail_23525.html" rel="external nofollow noopener noreferrer" target="_blank">quicklook</a> 预览好帮手 非常好用<br><a href="https://www.snipaste.com/" rel="external nofollow noopener noreferrer" target="_blank">Snipaste</a> 截图神器<br><a href="http://www.faststone.org/" rel="external nofollow noopener noreferrer" target="_blank">FScapture</a> 录制短视频神器 截图神器<br><a href="https://code.visualstudio.com/" rel="external nofollow noopener noreferrer" target="_blank">Visual Studio Code</a> 搬砖神器<br><a href="https://www.3xiazai.com/view/soft_4929.html" rel="external nofollow noopener noreferrer" target="_blank">FastStone Image Viewer</a> 本地看图神器 分类明细<br><a href="https://www.3xiazai.com/soft/medit/111074.html" rel="external nofollow noopener noreferrer" target="_blank">Inpaint</a> 去水印神器<br><a href="http://www.121down.com/article/article_99806.html" rel="external nofollow noopener noreferrer" target="_blank">Inpaint激活码</a><br><a href="http://www.onenote.com/download/" rel="external nofollow noopener noreferrer" target="_blank">OneNote</a> 便签笔记工具<br><a href="https://www.edrawsoft.cn/mindmaster/" rel="external nofollow noopener noreferrer" target="_blank">思维导图1 MindMaster 6.5</a><br><a href="https://www.xmind.net/" rel="external nofollow noopener noreferrer" target="_blank">思维导图2 Xmind</a><br><a href="http://naotu.baidu.com/" rel="external nofollow noopener noreferrer" target="_blank">思维导图3 百度脑图</a><br><a href="https://www.cr173.com/soft/743713.html" rel="external nofollow noopener noreferrer" target="_blank">PremiumSoft</a> 数据库管理工具<br><a href="http://note.youdao.com/" rel="external nofollow noopener noreferrer" target="_blank">有道云笔记</a><br><a href="http://www.vidown.cn/" rel="external nofollow noopener noreferrer" target="_blank">维棠视频</a><br><a href="https://www.apowersoft.cn/video-download-capture" rel="external nofollow noopener noreferrer" target="_blank">视频下载王</a><br><a href="https://www.listary.com/" rel="external nofollow noopener noreferrer" target="_blank">listary 搜索工具</a><br><a href="http://cn.ej" rel="external nofollow noopener noreferrer" target="_blank">clover 三叶草 计算机资源浏览器标签</a><br><a href="http://xlrocket.com/mrotter/?ref=appinn" rel="external nofollow noopener noreferrer" target="_blank">Mr.Otter</a></p>]]></content>
    
    <summary type="html">
    
      办公软件
    
    </summary>
    
      <category term="办公软件" scheme="http://www.tjl-myblog.cn/categories/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="办公软件" scheme="http://www.tjl-myblog.cn/tags/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用命令</title>
    <link href="http://www.tjl-myblog.cn/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://www.tjl-myblog.cn/Mysql常用命令.html</id>
    <published>2019-03-22T07:27:43.000Z</published>
    <updated>2019-12-21T11:04:47.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>需要下载的工具<br><a href="http://dev.mysql.com/downloads" rel="external nofollow noopener noreferrer" target="_blank">MySQL 本地服务器</a><br><a href="https://mysql-administrator.en.softonic.com/" rel="external nofollow noopener noreferrer" target="_blank">MySQL Administrator</a> （MySQL管理器）<br><a href="https://downloads.mysql.com/archives/query/" rel="external nofollow noopener noreferrer" target="_blank">MySQL Query Browser</a> （为一个图形交互客户机）</p><hr><h3 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h3><p>SQL也可能会使用完全限定的名字来引用列（同时使用表名和列字）。请看以下例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> products.prod_nam <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure><p>这条SQL语句在功能上等于本章最开始使用的那一条语句，但这里指输出定了一个完全限定的列名。</p><p>表名也可以是完全限定的，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> products.prod_name <span class="keyword">FROM</span> crashcourse.products;</span><br></pre></td></tr></table></figure><p>这条语句在功能上也等于刚使用的那条语句（当然，假定products表确实位于crashcourse数据库中）。</p><hr><blockquote><p>dataname 数据库的名字<br>tablename 表示表的名字<br>columns 列名</p></blockquote><h3 id="显示查看"><a href="#显示查看" class="headerlink" title="显示查看"></a>显示查看</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>USE dataname;</td><td>选择数据库</td></tr><tr><td>SHOW DATABASES;</td><td>返回可用数据库的一个列表。包含在这个列 表中的可能是MySQL内部使用的数据库</td></tr><tr><td>SHOW TABLES;</td><td>获得一个数据库内的表的列表</td></tr><tr><td>SHOW COLUMNS FROM tablename;</td><td>用来显示表列1</td></tr><tr><td>DESCRIBE tablename;</td><td>用来显示表列2</td></tr><tr><td>SHOW CREATE dataname;</td><td>显示创建特定数据库</td></tr><tr><td>SHOW CREATE tablename;</td><td>显示创建表的MySQL语句</td></tr><tr><td>SHOW STATUS;</td><td>用于显示广泛的服务器状态信息</td></tr><tr><td>SHOW GRANTS;</td><td>用来显示授予用户（所有用户或特定用户）的安全权限</td></tr><tr><td>SHOW ERRORS;</td><td>用来显示服务器错误</td></tr><tr><td>SHOW WARNINGS;</td><td>用来显示服务器警告消息</td></tr></tbody></table><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT * FROM tablename;</td><td>查找表中所有数据</td></tr><tr><td>SELECT columns FROM tablename;</td><td>单列数据查询</td></tr><tr><td>SELECT columns1, columns2 FROM tablename;</td><td>多列数据查询 可搭配as</td></tr><tr><td>SELECT DISTINCT columns FROM tablename;</td><td>DISTINCT去重</td></tr></tbody></table><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><table><thead><tr><th></th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename LIMIT 5;</td><td>返回结果不超过5条</td></tr><tr><td>SELECT columns FROM tablename LIMIT 5,5;</td><td>限制结果 (LIMIT 5,5;第一个数为开始位置，第二个数为要检索的行数)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关于MYSQL的LIMIT使用变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LIMIT ?表示求的结果集的点几行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LIMIT ?,? 表示结果集从第几行到第几行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初识MySql不知道limit后面怎么可以用变量动态的显示需要的记录，后来才发现可以这样做</span></span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`p_span_get_Babao_Furnace_rank`</span>$$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`p_span_get_Babao_Furnace_rank`</span>(_span_serverid <span class="built_in">INT</span>, _limit <span class="built_in">INT</span>)</span><br><span class="line">    <span class="keyword">COMMENT</span> <span class="string">'得到八宝炉副本排行数据的存储过程'</span></span><br><span class="line">_get_rank:<span class="keyword">BEGIN</span> <span class="comment">-- 给个标签</span></span><br><span class="line"><span class="comment">-- SELECT * FROM t_span_rank_babao_furnace WHERE spanserverid = _span_serverid and score != 0 ORDER BY score DESC LIMIT _limit; --  _limit 这里 不能使用变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">PREPARE</span> s1 <span class="keyword">FROM</span> <span class="string">'SELECT * FROM t_span_rank_babao_furnace WHERE spanserverid = ? and score != 0 ORDER BY score DESC LIMIT ?'</span>; <span class="comment">-- _limit 不能用变量 使用 PREPARE 预处理 用下面这个处理就行 预加载一下</span></span><br><span class="line">    <span class="keyword">set</span> @a=_span_serverid;</span><br><span class="line">    <span class="keyword">set</span> @b=_limit;</span><br><span class="line">    <span class="keyword">EXECUTE</span> s1 <span class="keyword">USING</span> @a,@b; <span class="comment">-- 赋予参数值</span></span><br><span class="line">    <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> s1; <span class="comment">-- 销毁预处理</span></span><br><span class="line">    <span class="keyword">END</span> _get_rank$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：需要传参数的地方一定要用"?"号，第一个FRom后面的语句要用''括起。</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th></th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM products ORDER BY columns;</td><td>ORDER BY 按照指定列名进行排序 单指定 升序</td></tr><tr><td>SELECT columns FROM products ORDER BY columns1, columns2;</td><td>ORDER BY 按照指定列名进行排序 多指定 (用逗号隔开即可) 当columns1相同的时候才会选择columns2排序 升序</td></tr><tr><td>SELECT columns FROM products ORDER BY columns DESC;</td><td>DESC 按照指定列名进行排序 单指定 (DESC降序) (ASC 升序 默认的 指不指定都没有影响)</td></tr><tr><td>SELECT columns FROM products ORDER BY columns1 DESC, columns2;</td><td>按columns1降序排序 columns2 升序排序(条件列后面加了DESC的就为降序排序)</td></tr><tr><td>SELECT columns FROM products ORDER BY columns LIMIT 1;</td><td>取出一个最小值 排序配合限制结果 可查找出最大值和最小值</td></tr><tr><td>SELECT columns FROM products ORDER BY columns DESC LIMIT 1;</td><td>取出一个最大值</td></tr></tbody></table><blockquote><p>ORDER BY子句的位置 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息<br>在查数据的时候 如果在最后考虑排序和限定结果 就可以大大避免语句顺序混乱的情况了</p></blockquote><h3 id="条件判断-筛选"><a href="#条件判断-筛选" class="headerlink" title="条件判断-筛选"></a>条件判断-筛选</h3><table><thead><tr><th></th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename WHRER columns = xxx;</td><td>WHRER 指定条件(应该位于FROM之后)返回columns = xxx的选项</td></tr><tr><td>SELECT columns FROM tablename WHRER columns BETWEEN xxx AND xxx;</td><td>返回范围内的值包括起始和结束位置 </td></tr><tr><td>SELECT columns FROM tablename WHRER IS NULL;</td><td>IS NULL 返回列中有NULL值的选项 配合if使用 就是 是否为空 if n_sid is null then end if; 如果 n_sid 为空 就进入循环</td></tr><tr><td>SELECT columns FROM tablename WHRER IS NOT NULL;</td><td>IS NOT NULL 返回列中不为NULL值的选项 配合if使用 就跟 not 一样的效果 if n_sid is not null then end if; 如果 n_sid 不为空 就进入循环</td></tr><tr><td>SELECT columns FROM tablename WHRER IN(xxx,xxx);</td><td>IN 返回xxx和xxx对应的值 可以代替OR(1 or 2 = in(1,2))</td></tr><tr><td>SELECT columns FROM tablename WHRER NOT IN(xxx,xxx);</td><td>NOT(否定判断) 返回xxx和xxx以外所有值</td></tr><tr><td>SELECT columns FROM tablename WHRER EXISTS(select columnsEx from tablenameEx …);</td><td>EXISTS 用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False</td></tr></tbody></table><blockquote><p>EXISTS在两个表中查找是否有一样的值 返回一张虚表<br><a href="https://www.cnblogs.com/xuanhai/p/5810918.html" rel="external nofollow noopener noreferrer" target="_blank">SQL中EXISTS的用法</a></p></blockquote><h3 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h3><table><thead><tr><th></th><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定两个值之间</td></tr></tbody></table><blockquote><p>BETWEEN的使用 位于xxx和xxx两值之间的选项 BETWEEN匹配范围中所有的值，包括指定的开始值和结束值<br>WHERE子句的位置 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误</p></blockquote><h3 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename WHERE name LIKE ‘%xxx’</td><td>% 匹配任意多个字符 只要后面有xxx内容的行就会被返回 如果后面有空格 将匹配不了 最好的方法 就是在后面也加一个%</td></tr><tr><td>SELECT columns FROM tablename WHERE name LIKE ‘xxx%’</td><td>% 匹配任意多个字符 只要前面有xxx内容的行就会被返回</td></tr><tr><td>SELECT columns FROM tablename WHERE name LIKE ‘%xxx%’</td><td>% 匹配任意多个字符 只要中间有xxx内容的行就会被返回</td></tr><tr><td>SELECT columns FROM tablename WHERE name LIKE ‘_xxx’</td><td>_ 匹配任意单个字符</td></tr><tr><td>SELECT columns FROM tablename WHERE name LIKE ‘xxx_’</td><td>_ 匹配任意单个字符</td></tr><tr><td>SELECT columns FROM tablename WHERE name LIKE ‘<em>xxx</em>‘</td><td>_ 匹配任意单个字符</td></tr></tbody></table><blockquote><p>LIKE不能匹配NULL<br>LIKE ‘%xxx’ 后面如果有空格 就会造成失误 最好的方法就是%xxx%</p></blockquote><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘xxx’</td><td>REGEXP xxx输入正则表达式即可</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP BINARY xxx</td><td>BINARY 区分大写写可用此关键字</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘xxx</td><td>yyy’</td><td>xxx和yyy都匹配 相当于OR</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘[123] xxx’</td><td>范围匹配(会匹配1 xxx 2xxx 3xxx)</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘[^1]’</td><td>^ 匹配特定字符1 以外的任何东西 用在[]中才有否定的作用</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘[1-5]’</td><td>匹配1到5 相当于 [1 2 3 4 5] [a-z] 匹配a到z</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘.’</td><td>匹配任意字符</td></tr><tr><td>SELECT columns FROM tablename WHERE name REGEXP ‘\.’</td><td>匹配带有’.’的字符 \转义 .本来是有特殊含义的 用了\之后就变成了普通的字符’.’</td></tr></tbody></table><blockquote><p>SELECT xxx REGEXP ‘yyy’; 可以在不依赖数据库表的情况来测试正则表达式 如果能匹配会返回1 如果不能则返回0<br>SELECT ‘hello’ REGEXP ‘1’; 返回0<br>SELECT ‘hello’ REGEXP ‘h’; 返回1</p></blockquote><h4 id="为更方便工作，可以使用预定义的字符集类"><a href="#为更方便工作，可以使用预定义的字符集类" class="headerlink" title="为更方便工作，可以使用预定义的字符集类"></a>为更方便工作，可以使用预定义的字符集类</h4><table><thead><tr><th>类</th><th>说 明</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>任意字母和数字（同[a-zA-Z0-9]）</td></tr><tr><td>[:alpha:]</td><td>任意字符（同[a-zA-Z]）</td></tr><tr><td>[:blank:]</td><td>空格和制表（同[\t]）</td></tr><tr><td>[:cntrl:]</td><td>ASCII控制字符（ASCII 0到31和127）</td></tr><tr><td>[:digit:]</td><td>任意数字（同[0-9]）</td></tr><tr><td>[:graph:]</td><td>与[:print:]相同，但不包括空格</td></tr><tr><td>[:lower:]</td><td>任意小写字母（同[a-z]）</td></tr><tr><td>[:print:]</td><td>任意可打印字符</td></tr><tr><td>[:punct:]</td><td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td></tr><tr><td>[:space:]</td><td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td></tr><tr><td>[:upper:]</td><td>任意大写字母（同[A-Z]）</td></tr><tr><td>[:xdigit:]</td><td>任意十六进制数字（同[a-fA-F0-9]）</td></tr></tbody></table><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT Concat(xxx, ‘ (‘,xxx,’)’ ) FROM tablename ORDER BY name;</td><td>Concat字符串连接函数 一般sql都用 + 和 双竖 来实现拼接 MySQL中用的是Concat要注意</td></tr><tr><td>SELECT Concat(RTrim(xxx), ‘ (‘,RTrim(xxx),’)’ ) FROM tablename ORDER BY name;</td><td>RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个列都进行了整理。</td></tr><tr><td>SELECT Concat(xxx, ‘ (‘,xxx,’)’ ) AS title_name FROM tablename ORDER BY name;</td><td>连接之后返回的字符串是没有名字的 客户端没有名字的列是不能使用的 这里使用AS关键是别名 即可解决此问题</td></tr></tbody></table><blockquote><p>RTrim 去掉右边所有空格 LTrim() 去掉值右边的所有空格 Trim()去掉左右两边的空格。</p></blockquote><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT aaa, bbb, aaa * bbb AS num FROM tablename;</td><td>aaa <em> bbb 命名别名为 num 表示出来(num就是aaa</em>bbb的结果)</td></tr></tbody></table><blockquote><p>计算支持 + - <em> /<br>SELECT 可用于测试 比如：SELECT 5</em>6; 返回30 SELECT Now() 返回当前时间 SELECT Trim(‘ aaa ‘) 返回aaa</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table><thead><tr><th>文本处理函数命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns, Upper(columns) AS xxx FROM tablename ORDER BY xxx;</td><td>Upper函数将结果转为大写</td></tr><tr><td>SELECT columns FROM tablename WHERE Soundex(columns) = Soundex(‘读音’)</td><td>这里他会返回读音相似的结果值 如果有时候一个串输入错误 例如 (‘Sam’) 和 (‘San’) 这里把n写成了m 就可以用这个函数处理 找出对应的结果</td></tr></tbody></table><h4 id="常用的文本处理函数"><a href="#常用的文本处理函数" class="headerlink" title="常用的文本处理函数"></a>常用的文本处理函数</h4><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/wu920604/article/details/72674577" rel="external nofollow noopener noreferrer" target="_blank">Left()</a></td><td>返回串左边的字符</td></tr><tr><td><a href="https://blog.csdn.net/wu920604/article/details/72674577" rel="external nofollow noopener noreferrer" target="_blank">Right()</a></td><td>返回串右边的字符</td></tr><tr><td><a href="https://blog.csdn.net/weixin_40417658/article/details/81288437" rel="external nofollow noopener noreferrer" target="_blank">Length()</a></td><td>返回串的长度</td></tr><tr><td><a href="https://www.cnblogs.com/mr-wuxiansheng/p/6531315.html" rel="external nofollow noopener noreferrer" target="_blank">Locate()</a></td><td>找出串的一个子串</td></tr><tr><td><a href="https://blog.csdn.net/qq_29741945/article/details/70159705" rel="external nofollow noopener noreferrer" target="_blank">Soundex()</a></td><td>返回串的SOUNDEX值</td></tr><tr><td><a href="https://blog.csdn.net/weixin_42981419/article/details/86162345" rel="external nofollow noopener noreferrer" target="_blank">SubString()</a></td><td>返回子串的字符</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr></tbody></table><h4 id="常用日期和时间处理函数"><a href="#常用日期和时间处理函数" class="headerlink" title="常用日期和时间处理函数"></a>常用日期和时间处理函数</h4><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td><a href="https://www.cnblogs.com/yangchunze/p/6669523.html" rel="external nofollow noopener noreferrer" target="_blank">Date_Format()</a></td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><blockquote><p>基本的日期格式应yyyy-mm-dd</p></blockquote><h4 id="常用数值处理函数"><a href="#常用数值处理函数" class="headerlink" title="常用数值处理函数"></a>常用数值处理函数</h4><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table><h3 id="SQL聚集函数"><a href="#SQL聚集函数" class="headerlink" title="SQL聚集函数"></a>SQL聚集函数</h3><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值 忽略NULL 可搭配DISTINCT使用 AVG(DISTINCT xxx)</td></tr><tr><td>COUNT()</td><td>返回某列的行数 如果COUNT(xxx) 忽略NULL的行 如果是COUNT(*)则不忽略</td></tr><tr><td>MAX()</td><td>返回某列的最大值 忽略NULL</td></tr><tr><td>MIN()</td><td>返回某列的最小值 忽略NULL</td></tr><tr><td>SUM()</td><td>返回某列值之和 忽略NULL SUM(DISTINCT xxx)</td></tr></tbody></table><h3 id="组合-分组"><a href="#组合-分组" class="headerlink" title="组合-分组"></a>组合-分组</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns, COUNT(*) AS num_prods FROM tablename GROUP BY columns</td><td>columns按这个列分组 把每一组的总行数给返回出来(num_prods 每一组的总行数)</td></tr><tr><td>SELECT columns, COUNT(*) AS num_prods FROM tablename GROUP BY columns <a href="https://www.cnblogs.com/phpper/p/9384614.html" rel="external nofollow noopener noreferrer" target="_blank">WITH ROLLUP</a></td><td>WITH ROLLUP：在group分组字段的基础上再进行统计数据</td></tr><tr><td>SELECT columns, COUNT(<em>) FROM tablename GROUP BY columns HAVING COUNT(</em>) &gt;= 2;</td><td>HAVING(过滤分组)支持所有WHERE操作符 进行分组之后 这里只显示返回行数大于等于2的分组</td></tr><tr><td>SELECT columns, COUNT(<em>) FROM tablename WHERE columns2 = xxx GROUP BY columns HAVING COUNT(</em>) &gt;= 2;</td><td>也可以和WHERE 搭配使用</td></tr></tbody></table><h3 id="SELECT子句及其顺序"><a href="#SELECT子句及其顺序" class="headerlink" title="SELECT子句及其顺序"></a>SELECT子句及其顺序</h3><table><thead><tr><th>子 句</th><th>说 明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP</td><td>BY 分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table><h3 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h3><table><thead><tr><th>命令</th><th>说 明</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename WHERE columns IN (SELECT columns2 FROM tablename2 WHERE columns2 = ‘TNT2’)</td><td>把()内的查询结果当做第一条的查询限制(子查询) 如果不这样做就只有分两步查询</td></tr></tbody></table><blockquote><p>子句可嵌套使用(但是如果比较复杂的查询虞姬阅读性较差<br>使用嵌套虽然没有限制 但是在实际使用中会有性能限制 还是少使用为好<br>使用的时候子查询返回的结果一定要与外部语句查询相同数目的列)<br>任何时候只要列名可能有多义性 就要使用完全限定列明</p></blockquote><h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns1, columns2 FROM tablename1, tablename2 WHERE tablename1.xxx = tablename2.xxx;</td><td>连结表 利用表一的键(key)值作为表2的外键(foreign key) 来进行匹配查找结果 tablename表不限量</td></tr><tr><td>SELECT columns1, columns2 FROM tablename1 INNER JOIN tablename2 ON tablename1.zzz = tablename2.zzz;</td><td>INNER JOIN xxx ON yyy 在xxx和yyy两个表中查找zzz的值是否一样 如果一样就返回 和上一条命令是一样的</td></tr></tbody></table><blockquote><p>联结是不限表个数的(可使用多连接查询) 但连结越多性能消耗就越大<br><a href="https://blog.csdn.net/zht666/article/details/8555164" rel="external nofollow noopener noreferrer" target="_blank">SQL语句多表inner join用法</a></p></blockquote><h3 id="高级联结表"><a href="#高级联结表" class="headerlink" title="高级联结表"></a>高级联结表</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns1, columns2 FROM tablename1 AS t1, tablename2 AS t2 WHERE t1.xxx = t2.xxx;</td><td>这里使用了 AS 简短了sql语句</td></tr><tr><td>SELECT t1.*, columns2 FROM tablename1 AS t1, tablename2 AS t2 WHERE t1.xxx = t2.xxx;</td><td>这个语句只有t1使用了通配符 所有其他列明确列出，所以没有重复的列被检索出来</td></tr><tr><td>SELECT tablename1.xxx,tablename2.xxx FROM tablename1 LEFT OUTER JOIN tablename2 ON tablename1.xxx = tablename2.xxx;</td><td>OUTER JOIN外连接 有LEFT(检查左边表所有的值)、RIGHT(检查左边表所有的值)、FULL(全外连接 左右都有)</td></tr></tbody></table><blockquote><p>表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分。应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机<br><a href="https://blog.csdn.net/huoyin/article/details/5788265" rel="external nofollow noopener noreferrer" target="_blank">DB2数据库的外连接(OUTER JOIN)，内连接(INNER JOIN)和交叉连接(CROSS JOIN)区别</a></p></blockquote><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns1 FROM tablename1 WHERE columns1 = xxx UNION SELECT columns2 FROM tablename2 WHERE columns2 = xxx …</td><td>UNION组合查询 可把两条SELECT的结果返回 UNION 默认去除两条SELECT查询到的重复结果 如果需要返回全部 用UNION ALL(返回所有匹配行 包括重复选项)即可</td></tr><tr><td>SELECT columns1 FROM tablename1 WHERE columns1 = xxx UNION SELECT columns2 FROM tablename2 WHERE columns2 = xxx ORDER BY zzz</td><td>组合查询加排序 这个排序只能使用在最后的一条SELECT语句(对组合查询的结果进行排序的)</td></tr></tbody></table><blockquote><p>UNION规则<br>UNION可组合不同的表但是每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。<br>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。<br>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。<br>如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</p></blockquote><h3 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h3><blockquote><p>并非所有引擎都支持全文本搜索 MySQL支持几种基本的数据库引擎。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。如果你的应用中需<br>要全文本搜索功能，应该记住这一点。<br>MyISAM (不支持事务 搜索快) InnoDB(支持事务 搜索相对MyISAM较慢)<br><a href="https://www.cnblogs.com/y-rong/p/8110596.html" rel="external nofollow noopener noreferrer" target="_blank">MyISAM与InnoDB两者之间区别与选择，详细总结，性能对比</a></p></blockquote><p>一、启用全文本搜索支持:在创建表的时候加上(也可以在以后的表 更新表 加上<code>FULLTEXT</code>即可) <code>FULLTEXT(xxx,yyy,...)</code> 对一个列进行索引(这个列就是那个文本) 可使用多个索引。<br>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。</p><blockquote><p>不要在导入数据时使用FULLTEXT 更新索引要花时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后再修改表，定义FULLTEXT。这样有助于更快地导入数据（而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间）</p></blockquote><p>二、在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索，其中<code>Match()</code>指定被搜索的列，<code>Against()</code>指定要使用的搜索表达式</p><h4 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename1 WHERE Match(columns) Against(‘…’);</td><td>使用条件全局搜索 返回行等级不为0的选项(结果排序按行等级来排序) 行等级是由表达式在文本中的先后顺序以及匹配程度来决定的 越前的行等级越高</td></tr><tr><td>SELECT columns Match(columns) Against(‘…’) AS rank FROM tablename1</td><td>使用全局搜索 返回匹配所有的行 行等级为0也会匹配(可以清晰地看出行等级)</td></tr></tbody></table><h4 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h4><p>在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索：</p><ul><li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</li><li>其次，MySQL检查这些匹配行并选择所有有用的词。</li><li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</li><li>利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词</li></ul><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename WHERE Match(columns) Against(‘…’ WITH QUERY EXPANSION);</td><td>WITH QUERY EXPANSION 查询扩展 返回只要包含了表达式的结果 优限级按匹配的数量</td></tr></tbody></table><blockquote><p>使用查询扩展的时候行越多越好 表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好。</p></blockquote><h4 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h4><p>以布尔方式，可以提供关于如下内容的细节：</p><ul><li>要匹配的词；</li><li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li><li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）；</li><li>表达式分组；</li><li>另外一些内容。</li><li>即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）</li></ul><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SELECT columns FROM tablename WHERE Match(columns) Against(‘…’ IN BOOLEAN MODE);</td><td>IN BOOLEAN MODE 布尔文本搜索 排列而不排序行(在布尔方式中，不按等级值降序排序返回的)</td></tr><tr><td>SELECT columns FROM tablename WHERE Match(columns) Against(‘… -xxx*’ IN BOOLEAN MODE);</td><td>排查带有xxx的 (-)排除 (* 截断)词尾通配符</td></tr></tbody></table><h5 id="全文本布尔操作符"><a href="#全文本布尔操作符" class="headerlink" title="全文本布尔操作符"></a>全文本布尔操作符</h5><table><thead><tr><th>布尔操作符</th><th>说 明</th></tr></thead><tbody><tr><td>+</td><td>包含，词必须存在</td></tr><tr><td>-</td><td>排除，词必须不出现</td></tr><tr><td>&gt;</td><td>包含，而且增加等级值</td></tr><tr><td>&lt;</td><td>包含，且减少等级值</td></tr><tr><td>()</td><td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td>~</td><td>取消一个词的排序值</td></tr><tr><td>*</td><td>词尾的通配符</td></tr><tr><td>“”</td><td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table><h5 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">columns</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> <span class="keyword">Match</span>(<span class="keyword">columns</span>) Against(<span class="string">'+aaa +bbb'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"><span class="comment">-- 这个搜索匹配包含词aaa和bbb的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">columns</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> <span class="keyword">Match</span>(<span class="keyword">columns</span>) Against(<span class="string">'aaa bbb'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"><span class="comment">-- 没有指定操作符，这个搜索匹配包含aaa和bbb中的至少一个词的行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">columns</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> <span class="keyword">Match</span>(<span class="keyword">columns</span>) Against(<span class="string">'"aaa bbb"'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"><span class="comment">-- 这个搜索匹配短语aaa bbb而不是匹配两个词aaa和bbb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">columns</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> <span class="keyword">Match</span>(<span class="keyword">columns</span>) Against(<span class="string">'&gt;aaa &lt;bbb'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"><span class="comment">--匹配aaa和bbb，增加前者的等级，降低后者的等级</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">columns</span> <span class="keyword">FROM</span> tablename <span class="keyword">WHERE</span> <span class="keyword">Match</span>(<span class="keyword">columns</span>) Against(<span class="string">'+aaa +(&lt;bbb)'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"><span class="comment">--这个搜索匹配词aaa和bbb，降低后者的等级</span></span><br></pre></td></tr></table></figure><h5 id="全文本搜索的某些重要的说明"><a href="#全文本搜索的某些重要的说明" class="headerlink" title="全文本搜索的某些重要的说明"></a>全文本搜索的某些重要的说明</h5><ul><li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为<br>那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li><li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。</li><li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li><li>忽略词中的单引号。例如，don’t索引为dont。</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li><li>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</li><li><p>没有邻近操作符 邻近搜索是许多全文本搜索支持的一个特性，它能搜索相邻的词（在相同的句子中、相同的段落中或者在特定数目的词的部分中，等等）。MySQL全文本搜索现在还不支持邻近操作符，不过未来的版本有支持这种操作符的计划</p></li><li><p>布尔文本搜索中的 &gt; 升级 和 &lt; 降级有什么用</p></li></ul><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>命令|作用<br>—|—|— (cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)<br>INSERT INTO tablename VALUES(xxx,xxx,…) | 插入数据1 xxx的数据要按列的顺序来的 如果没有值就用NULL(允许NULL的字段) 不安全的<br>INSERT INTO tablename(columns1,columns2,…) VALUES(xxx1,xxx2,…) | 插入数据2 更安全的更繁琐的<br>INSERT INTO tablename(columns1,columns2,…) VALUES(xxx1,xxx2,…),(xxx1,xxx2,…),(xxx1,xxx2,…) | 可以进行多条插入 也可以这样后面的用，隔开（MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快）<br>INSERT INTO tablename(columns1,columns2,…) VALUES(xxx1,xxx2,…) SELECT columns1,columns2,… FROM tablename | 可把查询的结果当做数据插入到相应的表中</p><p>注意事项：</p><ul><li>一般不要使用没有明确给出列的列表的INSERT INTO语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化</li><li><p>不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功</p></li><li><p>(省略列)如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。</p><ul><li>该列定义为允许NULL值（无值或空值）。</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li></ul></li><li><p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功</p></li><li><p>数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。 如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字 <a href="http://www.wuweixin.com/2012/12/18/mysql-low-priority-updates/" rel="external nofollow noopener noreferrer" target="_blank">LOW_PRIORITY</a>，指示MySQL降低INSERT语句的优先级 同样适用于 UPDATE和DELETE</p></li><li><p>INSERT和SELECT语句中不要求列名匹配。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的</p></li><li>INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据</li></ul><h3 id="更新数据-删除数据"><a href="#更新数据-删除数据" class="headerlink" title="更新数据/删除数据"></a>更新数据/删除数据</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>UPDATE tablename SET columns1 = value1,columns2 = value2 WHERE xxx = xxx</td><td>如果没有WHERE 将会对所有的列进行赋值value(是很危险的行为) 更新多个列用，隔开即可</td></tr><tr><td>UPDATE columns a,(SELECT columns1 FROM tablename WHERE cust_id = 10001) b SET a.xxx = b.xxx WHERE a.cust_id = 10003;</td><td>a是tablename的别名 b是这一条查询语句的返回结果集 SET 更新数据 WHERE 在更新数据前进行判断 <a href="https://www.cnblogs.com/007sx/p/7404651.html" rel="external nofollow noopener noreferrer" target="_blank">在UPDATE中使用子查询</a> (a和b都是派生表)</td></tr><tr><td>UPDATE tablename SET columns1 = NULL WHERE xxx = xxx</td><td>删除莫一个值 可以使用UPDATE赋值为NULL来实现 </td></tr></tbody></table><p>DELETE FROM tablename WHERE columns = xxx 删除掉过滤的行(这里是删除行 不是删除列 如果要用删除列 请使用上面的命令)<br>TRUNCATE TABLE tablename | 删除表的所有行</p><p>更新/删除注意事项：</p><ul><li>可使用子查询来当做数据更新 <code>UPDATE tablename SET columns1 = (SELECT ...) WHERE xxx = xxx</code></li><li>IGNORE关键字 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，示例：<code>UPDATE IGNORE customers…</code></li><li>删除表的内容而不是表 DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身。</li><li>如果想从表中删除所有行，不要使用DELETE。可使用<a href="https://www.cnblogs.com/zhoufangcheng04050227/p/7991759.html" rel="external nofollow noopener noreferrer" target="_blank">TRUNCATE TABLE</a>语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</li><li>如果是整理表内部的碎片，可以用truncate跟上<a href="http://blog.itpub.net/27042095/viewspace-768817/" rel="external nofollow noopener noreferrer" target="_blank">reuse stroage</a></li></ul><p>删除的总结：</p><ul><li>DROP删表，表结构将删了，当然数据也不存在了</li><li>TRUNCATE和DELETE删数据，表结构还在</li><li>DELETE可以带条件删除，TRUNCATE是全部删除</li><li>DELETE删除会写日志，TRUNCATE不写</li><li>DELETE效率低，数据可以恢复，TRUNCATE效率高，数据不可恢复</li></ul><p>更新和删除总结：<br>执行UPDATE而不带WHERE子句，则表中每个行都将用新值更新。类似地，如果执行DELETE语句而不带WHERE子句，表的所有数据都将被删除。</p><ul><li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li><li>保证每个表都有主键，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li><li>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li><li>使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。小心使用 MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据</li></ul><h3 id="创建、更改表、删除表"><a href="#创建、更改表、删除表" class="headerlink" title="创建、更改表、删除表"></a>创建、更改表、删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename (columns1 typedef <span class="keyword">value</span> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> ,columns2 typedef <span class="keyword">value</span>,...,PRIMARY <span class="keyword">KEY</span>(<span class="keyword">columns</span>)) <span class="keyword">ENGINE</span>=(<span class="keyword">InnoDB</span>/MyISAM) <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'说明'</span> <span class="comment">--创建表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> <span class="keyword">columns</span> typedef <span class="keyword">value</span> <span class="comment">--添加一个列 修改表结构</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">columns</span> <span class="comment">--删除上面的列 修改表结构</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">add</span> <span class="keyword">constraint</span> primary <span class="keyword">key</span>(<span class="keyword">sid</span>) <span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> primary <span class="keyword">key</span>; <span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tablename <span class="comment">--删除表（删除整个表而不是内容）</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> tablename <span class="keyword">TO</span> newtablename, tablename1 <span class="keyword">TO</span> newtablename1 <span class="comment">--对tablename的重命名 用逗号隔开用于多个表的重命名</span></span><br></pre></td></tr></table></figure><ul><li>PRIMARY KEY 关键字指定（不能为NULL值）可使用组合键(组合起来的必须是唯一的) PRIMARY KEY(columns1,columns2)</li><li>UNIQUE KEY 设置字段的唯一约束（保持字段的唯一性 阔以有多个唯一约束） 保持除主键外值的唯一可用唯一约束 </li><li>typedef 数据类型</li><li>value 是值的属性并不是值(比如：这个值能否为NULL值等) NULL（可以为NULL值） NOT NULL(不能为NULL值) <strong>AUTO_INCREMENT（自动增量）DEFAULT（默认值）</strong> 每个表只允许一个 <strong>AUTO_INCREMENT</strong> 列，而且它必须被索引（如，通过使它成为主键）。 </li><li>在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值。（AUTO_INCREMENT值会被插入的键值给覆盖 如果为NULL则不影响）</li><li>SELECT last_insert_id() 函数获得 AUTO_INCREMENT（自动增量）的值 （仅会在INSERT 和UPDATE语句使用后才可以返回这的自动增量值）</li><li>ENGINE 搜索引擎（请看上面的全文本搜索）<ul><li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理</li></ul></li><li>混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键<br>命令|作用</li><li>ADD 添加一个列</li><li>DROP 删除一个列<br>—|—|—<br>CREATE TABLE tablename (columns1 typedef NOT NULL AUTO_INCREMENT,columns2 typedef NULL DEFAULT 1,…,PRIMARY KEY(columns) ENGINE=(InnoDB/MyISAM) | 创建表<br>ALTER TABLE <code>主表的名字</code> ADD CONSTRAINT <code>外键的名字默认系统定义</code> FOREIGN KEY (<code>外键字段（从表的主键值）</code>) REFERENCES <code>(参考表)从表的表名</code> (<code>参考字段(和从表的主键一样就行了)</code>) ON DELETE CASCADE ON UPDATE CASCADE; | 定义表的外键 CASCADE 就是当关联的表更新后， emp中的dept_id也随着更新。删除表也是选择 CASCADE</li></ul><blockquote><p>外键：主表和从表 (外键是从表的主键值 另一个则就是主表 从表的主键只是主表的一个普通的字段(列))<br><a href="https://www.cnblogs.com/blovedr/p/9211283.html" rel="external nofollow noopener noreferrer" target="_blank">Navicat在MySQL中添加外键详细过程</a><br><a href="https://www.cnblogs.com/yuyu666/p/9823680.html" rel="external nofollow noopener noreferrer" target="_blank">定义外键</a></p></blockquote><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>CREATE VIEW <code>视图name</code> AS <code>SELECT 一条查询语句 把这个结果当做一个视图返回</code></td><td>创建视图 这个视图表可以进行和普通表一样的操作更改查询等</td></tr><tr><td>SHOW CREATE VIEW <code>视图name</code></td><td>查看视图</td></tr><tr><td>DROP VIEW <code>视图name</code></td><td>删除视图</td></tr></tbody></table><ul><li>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</li><li>为什么使用视图<ul><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul></li><li>视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</li><li>如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</li><li>视图对于简化计算字段的使用特别有用。</li><li>视图是根据基表的内容来定的 所有如果表中的数据发生了更改 视图是会更改的。</li><li>更新一个视图将更新其基表（视图本身没有数据 相当于基表和视图的数据是一起的 视图一般不进行更改删除等操作 只进行数据检索）</li><li>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：<ul><li>分组（使用GROUP BY和HAVING）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min()、Count()、Sum()等）；</li><li>DISTINCT；</li><li>导出（计算）列。</li></ul></li><li>这看上去好像是一个严重的限制，但实际上不是，一般视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）</li></ul><blockquote><p>总结：视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据</p></blockquote><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><a href="http://tjl-myblog.cn/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80.html" rel="external nofollow noopener noreferrer" target="_blank">存储过程</a></h3><ul><li>使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个完整的存储过程 要有注释</span></span><br><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters:</span></span><br><span class="line">    <span class="comment">-- onumber = order</span></span><br><span class="line">    <span class="comment">-- numbertaxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line">    <span class="comment">-- ototal = order total variable</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal</span><br><span class="line">(</span><br><span class="line"><span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">IN</span> taxable <span class="built_in">BOOLEAN</span>,</span><br><span class="line"><span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">) <span class="keyword">COMMENT</span> <span class="string">'Obtain order total, optionally adding tax'</span> <span class="comment">-- COMMENT 这个表加注释 用在字段后面就是给字段加注释</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Declare variable for tota?</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="built_in">DECIMAL</span> (<span class="number">8</span>,<span class="number">2</span>); <span class="comment">-- 声明total DECIMAL类型</span></span><br><span class="line">    <span class="comment">-- Declare tax percentage</span></span><br><span class="line">    <span class="keyword">DECLARE</span> taxrate <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>; <span class="comment">-- 声明taxrate为int类型 默认值为6</span></span><br><span class="line">    <span class="comment">-- Get the order total</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity) <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = onumber <span class="keyword">INTO</span> total; <span class="comment">-- 求和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Is this taxable?</span></span><br><span class="line">    IF taxable THEN <span class="comment">-- 是否计算税</span></span><br><span class="line">        <span class="comment">-- Yes, so add taxrate to the total</span></span><br><span class="line">        <span class="keyword">SELECT</span> total+(total/<span class="number">100</span>*taxrate) <span class="keyword">INTO</span> total;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- And finally, save to out variable</span></span><br><span class="line">    <span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal; <span class="comment">-- 保存结果返回出去</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注1：SHOW CREATE PROCEDURE procedure_name; 查看检查一个存储过程</span></span><br><span class="line"><span class="comment">-- 注2：SHOW PROCEDURE STATUS; 查看存储过程列表（何时、由谁创建等详细信息）</span></span><br><span class="line"><span class="comment">-- 注3：SHOW PROCEDURE STATUS LIKE 'ordertotal'; 可使用过滤模式 进行过滤</span></span><br></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- DECLARE local variables</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> o <span class="built_in">INT</span>; <span class="comment">-- 声明局部变量 o</span></span><br><span class="line">    <span class="keyword">DECLARE</span> t <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- DECLARE cursor，</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders; <span class="comment">-- 创建游标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- DECLARE CONTINUE HANDLER 这里的阔以自己设定 这里只是方便遍历到游标的最后而已（这个写法是固定的）</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done = <span class="number">1</span>; <span class="comment">-- 当SQLSTATE为02000时设置done值为1(当fetch游标到了数据库表格最后一行的时候)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals(order_num <span class="built_in">INT</span> , total <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)); <span class="comment">-- 如果没有ordertotals表则创建表</span></span><br><span class="line"></span><br><span class="line">    OPEN ordernumbers; <span class="comment">-- 打开游标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Loop through all rows</span></span><br><span class="line">    REPEAT <span class="comment">-- 循环浏览所有行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- GET order number</span></span><br><span class="line">        FETCH ordernumbers INTO o; <span class="comment">-- 取订单号 赋值给 o</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- GET the total for this order</span></span><br><span class="line">        <span class="keyword">CALL</span> ordertotal(o, <span class="number">1</span>, t); <span class="comment">-- 计算出来的结果给t</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Insert order and total into ordertotals</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ordertotals(order_num, total) <span class="keyword">VALUES</span>(o, t); <span class="comment">-- 将结果存入到新表中</span></span><br><span class="line"></span><br><span class="line">    UNTIL done <span class="comment">-- 循环条件 满足条件退出 当done为1的时候退出 也阔以用 while</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>; <span class="comment">-- 结束循环</span></span><br><span class="line"></span><br><span class="line">    CLOSE ordernumbers; <span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li>存储过程处理完成后，游标就消失（因为它局限于存储过程）。</li><li>游标用OPEN CURSOR语句来打开</li><li>游标用CLOSE CURSOR语句来打开（如果不明确关闭游标，MySQL将会在到达END语句时自动关闭它-BEGIN对应的END）</li><li>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）</li><li>SQLSTATE ‘02000’是一个未找到条件</li><li>如果调用这个存储过程，它将定义几个变量和一个CONTINUE HANDLER，定义并打开一个游标，重复读取所有行，然后关闭游标。</li><li>如果一切正常，你可以在循环内放入任意需要的处理（在FETCH语句之后，循环结束之前）。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ul><li>触发器(事件：比如删除了一个用户 每删除一个用户就保存一个副本的操作 就可以用触发器来完成)</li><li>触发器只能创建在永久表上、临时表上不行、视图也不行</li><li>注意触发器涉及触发表自身的操作时，用before 不然会报错(<code>1442 - Can&#39;t update table &#39;orders&#39; in stored function/trigger because it is already used by statement which invoked this stored function/trigger.</code>)</li><li>每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）</li><li>单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器</li><li>触发器失败 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）</li></ul><p>触发器只支持下面三种操作：</p><ul><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ul><p>触发器经常用于加强数据的完整性约束和业务规则等。 触发器创建语法四要素：</p><ul><li>监视地点(table)</li><li>监视事件(insert/update/delete)</li><li>触发时间(after/before)</li><li>触发事件(insert/update/delete)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CREATE TRIGGER用来创建名为 'newproduct' 的新触发器。触发器</span></span><br><span class="line"><span class="comment">可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，</span></span><br><span class="line"><span class="comment">所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR</span></span><br><span class="line"><span class="comment">EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product</span></span><br><span class="line"><span class="comment">added将对每个插入的行显示一次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> products <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> <span class="string">'Product added'</span>; <span class="comment">-- 这里省略了BEGIN END 因为只有一条语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 触发器SQL语法</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名字</span><br><span class="line"><span class="keyword">AFTER</span>/<span class="keyword">BEFORE</span> <span class="keyword">INSERT</span>/<span class="keyword">UPDATE</span>/<span class="keyword">DELETE</span> <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="comment">-- 这句话在mysql是固定的</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 触发的sql语句;</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li>AFTER 之后操作</li><li>BEFORE 操作之前</li><li>FOR EACH ROW<ul><li>for each row 每行受影响，触发器都执行，叫行级触发器。</li><li>oracle 触发器中分行级触发器和语句级触发器，可不写for each row，无论影响多少行都只执行一次。</li><li>mysql不支持语句触发器，所以必须写for each row</li></ul></li></ul><p>删除触发器：</p><ul><li>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">TRIGGER</span> newprodduct;</span><br></pre></td></tr></table></figure><blockquote><p>触发器中所谓NEW，OLD只是指INSERT DELETE UPDATE操作执行前的表和执行后的表，其实都是触发器所在的那个表。当你执行了一个操作的时候，有BEFORE触发器的时候，会先运行触发器，这个时候表的状态是OLD，你在触发器中可以取OLD的内容，然后也可以指定NEW的内容，而默认NEW的内容是你操作时更新的数据内容，如果没有指定，则还是OLD的内容，最后执行操作，按照NEW的数据更新进表</p></blockquote><p>INSERT触发器：</p><ul><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行</li><li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li><li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.order_num; <span class="comment">-- NEW 是个虚拟表(刚刚插入的值)</span></span><br></pre></td></tr></table></figure><p>DELECT触发器：</p><ul><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li><li>OLD中的值全都是只读的，不能更新。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder <span class="keyword">BEFORE</span> DELECT <span class="keyword">ON</span> orders <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> OLD.order_num; <span class="comment">-- OLD 是个虚拟表(刚刚插入的值)</span></span><br></pre></td></tr></table></figure><p>UPDATE触发器：</p><ul><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值</li><li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）</li><li>OLD中的值全都是只读的，不能更新</li><li>任何数据净化都需要在UPDATE语句之前进行，就像下面这个例子中一样。每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> orders <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.vend_state = <span class="keyword">Upper</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>Before与After区别(如果要操作触发表中的数据 最好用Before 不然应该会报错 用的时候需要注意 最好经过测试再进行)<ul><li>before：(insert、update)可以对new进行修改，after不能对new进行修改，两者都不能修改old数据。</li></ul></li><li>对于INSERT语句, 只有NEW是合法的</li><li>对于DELETE语句，只有OLD才合法</li><li>对于UPDATE语句，NEW、OLD可以同时使用</li><li>after—是在记录操纵之后触发，是先完成数据的增删改，再触发，触发的语句晚于监视的增删改操作，无法影响前面的增删改动作（所以如果要修改当前表的值 都用before 不然会报错 导致更新失败等）</li><li>before—是在记录操纵之前触发，是先完成触发，再增删改，触发的语句先于监视的增删改，我们就有机会判断，修改即将发生的操作，如：我们在触发之前需要判断new值和old值的大小或关系，如果满足要求就触发，不通过就修改再触发；如：表之间定义的有外键，在删除主键时，必须要先删除外键表，这时就有先后之分，这里before相当于设置了断点，我们可以处理删除外键。</li></ul><blockquote><p>用触发器的操作其实都阔以用 存储过程来实现 触发器相当于隐式的存储过程（触发器和存储过程其实都差不多 但是对于一个不熟悉数据库操作系统的人来看的话肯定是有存储过程看着有逻辑关系些更容易懂 如果是触发器的话 太不方便查找 所有还是尽量用存储过程比较好）</p></blockquote><p>参考：<br><a href="https://blog.csdn.net/chl191623691/article/details/79607761?utm_source=blogxgwz2" rel="external nofollow noopener noreferrer" target="_blank">mysql触发器不能对同一张表进行修改操作的总结</a><br><a href="https://www.cnblogs.com/zejin2008/p/4643761.html" rel="external nofollow noopener noreferrer" target="_blank">数据库中触发器before与after认识</a><br><a href="https://www.cnblogs.com/niweiniwei/p/8994240.html" rel="external nofollow noopener noreferrer" target="_blank">MySql中的存储过程和触发器的使用和区别</a><br><a href="https://blog.csdn.net/xx666zz/article/details/79083112" rel="external nofollow noopener noreferrer" target="_blank">关于mysql触发器、存储过程的一点儿小见解</a><br><a href="https://www.cnblogs.com/zhangzhongxian/p/7070277.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL触发器更新和插入操作/存储过程和触发器的区别</a></p><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><blockquote><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。<br>事务处理用来管理INSERT、UPDATE和DELETE语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销</p></blockquote><ul><li>事务（transaction）指一组SQL语句；</li><li>回退（rollback）指撤销指定SQL语句的过程；</li><li>提交（commit）指将未存储的SQL语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。保留点越多，你就越能按自己的意愿灵活地进行回退。</li><li>保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放 也可以用 RELEASESAVEPOINT 明确地释放保留点。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- START TRANSACTION 标识事务的开始 可使用 BEGIN</span></span><br><span class="line"><span class="comment">-- ROLLBACK 回退</span></span><br><span class="line"><span class="comment">-- COMMIT 提交事务</span></span><br><span class="line"><span class="comment">-- SAVEPOINT 保留点（可以理解为备份点 快照）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用ROLLBACK</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals; <span class="comment">-- 检查 ordertotals 是否为空</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>; <span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals; <span class="comment">-- 删除 ordertotals 表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals; <span class="comment">-- 检查表是否为空</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>; <span class="comment">-- 回退操作</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals; <span class="comment">-- 查看表数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用COMMIT</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>; <span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">where</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">where</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 提交事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用SAVEPOINT</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1; <span class="comment">-- delete1 保留点的名字 回退的时候可以明确的退到哪儿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回退到保留点</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改默认的提交行为 这个AUTOCOMMIT标志是针对每个连接而不是服务器的</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">1</span>; <span class="comment">-- 设置提交行为设为 ON 自动</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>; <span class="comment">-- 设置提交行为设为 OFF 不自动 需要手动 COMMIT 不然的话都可回退</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看提交行为</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'autocommit'</span>;</span><br></pre></td></tr></table></figure><ul><li>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句。<br><a href="https://www.cnblogs.com/kerrycode/p/8649101.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL的自动提交模式</a><br><a href="http://www.cnblogs.com/TeyGao/p/7622155.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL–当事务遇到DDL命令</a></li></ul><h3 id="事件-EVENT"><a href="#事件-EVENT" class="headerlink" title="事件(EVENT)"></a>事件(EVENT)</h3><h4 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h4><ul><li>查看mysql事件是否开启：<code>show variables like &#39;%scheduler%&#39;;</code></li><li>开启mysq事件：<code>set global event_scheduler=&#39;on&#39;;</code></li><li>查看定时器信息 <code>SELECT * FROM information_schema.events;</code></li><li>查看事件列表 <code>show events;</code></li></ul><p><a href="https://blog.csdn.net/ow1234/article/details/73231034" rel="external nofollow noopener noreferrer" target="_blank">开启事件/查看事件</a></p><blockquote><p>事件（EVENT）既“时间触发器”，与触发器（TRIGGER）的事件触发不同，EVENT类似与 LINUX CRONTAB 计划任务，用于时间触发。通过单独或调用存储过程使用，在某一特定的时间点，触发相关的SQL语句或存储过程。</p></blockquote><ul><li>对于每隔一段时间就有固定需求的操作，如创建表，删除数据等操作，可以使用EVENT来处理。</li></ul><p>开启定时器：<br>要使event起作用，MySQL的常量 GLOBAL event_scheduler 必须为ON或者是1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看是否开启定时器</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'event_scheduler'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启定时器 0：OFF(关) 1：ON(开)</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> event_scheduler = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建事件 语法</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span></span><br><span class="line">[<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="comment">-- 标注1 如果没有这个时间才创建这个事件</span></span><br><span class="line"></span><br><span class="line">EVENT_NAME <span class="comment">-- 标注2 事件名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> SCHEDULE schedule <span class="comment">-- 标注3 计划任务 多久执行</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">ON</span> COMPLETION [<span class="keyword">NOT</span>] <span class="keyword">PRESERVE</span>] <span class="comment">-- 标注4 当这个事件不会发生的时候会被默认删除drop掉 PRESERVE 这个参数就是保存事件不被drop掉 便于查看事件的具体信息 建议使用这个参数</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">ENABLE</span> | <span class="keyword">DISABLE</span>] <span class="comment">-- 标注5 设定事件状态 ENABLE(系统将执行该事件 启用) DISABLE(系统不执行该事件 禁用) ALTER EVENT event_name ENABLE/DISABLE 可用这个语句进行更新状态 默认系统调用</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">COMMENT</span> <span class="string">'comment'</span>] <span class="comment">-- 标注6 注释 查看定时器信息可见备注</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DO</span> sql_statement <span class="comment">-- 标注7 需要执行的存储过程(也阔以再后面追加存储过程语句)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例 每隔一秒自动调用的e_test存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span></span><br><span class="line"><span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line"></span><br><span class="line">e_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> SCHEDULE EVERY <span class="number">1</span> <span class="keyword">SECOND</span> <span class="comment">-- EVERY 1 SECOND 每一秒执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> COMPLETION <span class="keyword">NOT</span> <span class="keyword">PRESERVE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENABLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'comment'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">SELECT</span> <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> e_test <span class="keyword">ON</span> SCHEDULE EVERY <span class="number">1</span> <span class="keyword">SECOND</span> <span class="keyword">ON</span> COMPLETION <span class="keyword">PRESERVE</span> <span class="keyword">ENABLE</span> <span class="keyword">COMMENT</span> <span class="string">'comment'</span> <span class="keyword">DO</span> <span class="keyword">SELECT</span> <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>请特别注意：当你设定事件计划为0 或OFF，即关闭事件计划进程的时候，不会有新的事件执行，但现有的正在运行的事件会执行到完毕。对于我们线上环境来说，使用EVENT时，注意在主库上开启定时器，从库上关闭定时器，EVENT触发所有操作均会记录日志(BINLOG)进行主从同步，从库上开启定时器很可能造成卡库。切换主库后之后记得将新主库上的定时器打开。</p></blockquote><p>说明标注：</p><ol><li><code>[IF NOT EXISTS]</code><ul><li><strong>使用 IF NOT EXISTS</strong>，只有在同名event不存在时才创建，否则忽略。建议不使用以保证EVENT创建成功。</li></ul></li><li><code>EVENT_NAME</code><ul><li><strong>事件名称</strong> 最大长度可以是64个字节。名字必须是当前<code>Dateabase</code>中唯一的，同一个<br>数据库不能有同名的<code>event</code>。使用<code>event</code>常见的工作是创建表、插入数据、删除<br>数据、清空表、删除表。为了避免命名规范带来的不便，最好让事件名称具有描<br>述整个事件的能力。建议命名规则如下为：动作名称<code>_（INTO/FROM_）</code>表名<code>_TIME</code>。</li><li>例如：<ul><li>每月创建（清空/删除）fans表<br> <code>create(truncate/drop)_table_fans_month;</code></li><li>每天从fans表插入（删除）数据：<br> <code>insert(delete)_into(from)_fans_day;</code></li></ul></li></ul></li><li><p><code>ON SCHEDULE</code></p><ul><li><p><strong>ON SCHEDULE 计划任务，有两种设定计划任务的方式</strong>：</p><ol><li>AT 时间戳，用来完成单次的计划任务。</li><li>EVERY 时间（单位）的数量时间单位[<code>STARTS</code> 时间戳] [<code>ENDS</code> 时间戳]，用 来完成重复的计划任务。</li></ol></li><li><p>在两种计划任务中，时间戳可以是任意的 <code>TIMESTAMP</code> 和 <code>DATETIME</code> 数据类型，<strong>时间戳需要大于当前时间</strong>。在重复的计划任务中，时间（单位）的数量可以是任意非空<code>（Not Null）</code>的整数式，时间单位是关键词：<code>YEAR，MONTH，DAY，HOUR，MINUTE</code> 或者 <code>SECOND</code>。</p></li><li><p>提示：其他的时间单位也是合法的如：<code>QUARTER, WEEK, YEAR_MONTH,DAY_HOUR,DAY_MINUTE,DAY_SECOND,HOUR_MINUTE,HOUR_SECOND, MINUTE_SECOND</code>，不过不建议使用这些不标准的时间单位。</p></li></ul></li><li><p><code>[ON COMPLETION [NOT] PRESERVE]</code></p><ul><li><code>ON COMPLETION</code> 参数表示”当这个事件不会再发生的时候”，即当单次计划任务执行完毕后或当重复性的计划任务执行到了<code>ENDS</code>阶段。而<code>PRESERVE</code>的作用是使事件在执行完毕后不会被<code>Drop</code>掉，建议使用该参数，以便于查看<code>EVENT</code>具体信息</li></ul></li><li><code>[ENABLE | DISABLE]</code><ul><li>参数<code>Enable</code>和<code>Disable</code>表示设定事件的状态。<code>Enable</code>表示系统将执行这个事件。<code>Disable</code>表示系统不执行该事件。可以用如下命令关闭或开启事件：<code>ALTER EVENT event_name ENABLE/DISABLE</code></li></ul></li><li><code>[COMMENT &#39;comment&#39;]</code><ul><li>注释会出现在元数据中，它存储在<code>information_schema</code>表的<code>COMMENT</code>列，最大长度为64个字节。<code>&#39;comment&#39;</code>表示将注释内容放在单引号之间，建议使用注释以表达更全面的信息。</li></ul></li><li><p><code>DO sql_statement</code></p><ul><li><p><code>DO sql_statement</code>字段表示该<code>event</code>需要执行的<code>SQL</code>语句或存储过程。这里的<code>SQL</code>语句可以是复合语句，例如：</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1;//创建表（需要测试一下）</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test2;//删除表</span><br><span class="line"><span class="keyword">CALL</span> proc_test1();//调用存储过程</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>BEGIN</code>和<code>END</code>标识符将复合<code>SQL</code>语句按照执行顺序放在之间。当然SQL语句是有限制的，对它的限制跟函数<code>Function</code>和触发器<code>Trigger</code> 中对<code>SQL</code>语句的限制是一样的，如果你在函数<code>Function</code>和触发器<code>Trigger</code>中不能使用某些<code>SQL</code>，同样的在<code>EVENT</code>中也不能使用。明确的来说有下面几个：</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span></span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">EVENT</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="修改事件"><a href="#修改事件" class="headerlink" title="修改事件"></a>修改事件</h4><p>使用ALTER EVENT 来修改事件，与创建事件的语法类似：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">EVENT</span></span><br><span class="line">event_name <span class="comment">-- 原事件名字</span></span><br><span class="line"><span class="keyword">ON</span> SCHEDULE schedule <span class="comment">-- 任务计划</span></span><br><span class="line">[<span class="keyword">RENAME</span> <span class="keyword">TO</span> new_event_name] <span class="comment">-- 重命名 还能用来移动事件</span></span><br><span class="line">[<span class="keyword">ON</span> COMPLETION [<span class="keyword">NOT</span>] <span class="keyword">PRESERVE</span>] <span class="comment">-- PRESERVE 事件结束可以保存事件信息 方便查看</span></span><br><span class="line">[<span class="keyword">ENABLE</span> | <span class="keyword">DISABLE</span>] <span class="comment">-- 事件状态 ENABLE（启动） DISABLE（禁用）</span></span><br><span class="line">[<span class="keyword">COMMENT</span> <span class="string">'comment'</span>] <span class="comment">-- 注释</span></span><br><span class="line"><span class="keyword">DO</span> sql_statement <span class="comment">-- 存储过程语句</span></span><br></pre></td></tr></table></figure><h4 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h4><p>EVENT使用DROP EVENT来删除已经创建的事件，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">EVENT</span></span><br><span class="line">[<span class="keyword">IF</span> <span class="keyword">EXISTS</span>]</span><br><span class="line">event_name <span class="comment">-- 事件名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">EVENT</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> event_name;</span><br></pre></td></tr></table></figure><p>但当一个事件正在运行中时，删除该事件不会导致事件停止，事件会执行到完毕为止。使用 <code>DROP USER</code> 和 <code>DROP DATABASE</code> 语句同时会将包含其中的事件删除。</p><p>参考：<br><a href="https://www.cnblogs.com/gaogaoxingxing/p/9909970.html" rel="external nofollow noopener noreferrer" target="_blank">mysql的event(事件)用法详解1</a><br><a href="https://blog.csdn.net/lixia755324/article/details/53923856" rel="external nofollow noopener noreferrer" target="_blank">mysql的event(事件)用法详解2</a><br><a href="https://blog.csdn.net/luyaran/article/details/81030851" rel="external nofollow noopener noreferrer" target="_blank">mysql事件之修改事件（ALTER EVENT）&amp;禁用事件（DISABLE）&amp;启用事件（ENABLE）&amp;事件重命名&amp;数据库事件迁移</a></p><h3 id="MySQL的字符集和校对规则"><a href="#MySQL的字符集和校对规则" class="headerlink" title="MySQL的字符集和校对规则"></a>MySQL的字符集和校对规则</h3><ul><li>字符集为字母和符号的集合</li><li>编码为某个字符集成员的内部表示</li><li>校对为规定字符如何比较的指令</li><li>查看所支持的字符集完整列表，可使用 <code>SHOW CHARACTER SET;</code></li><li>查看所支持校对的完整列表，可使用 <code>SHOW COLLATION;</code> 此语句显示所有可用的* 校对，以及它们适用的字符集</li><li>查看当前使用的字符集<code>SHOW VARIABLES LIKE &#39;CHARACTER%&#39;;</code></li><li>查看当前使用的校对表<code>SHOW VARIABLES LIKE &#39;COLLATION%&#39;;</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表的时候就指定字符集和校对表 （校对表必须要与字符集兼容）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename (</span><br><span class="line">    column1 <span class="built_in">INT</span>,</span><br><span class="line">    column2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci; <span class="comment">-- 指定该表的字符集和校对规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 除了对一个表规定 H还可以对当个列使用</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename (</span><br><span class="line">    column1 <span class="built_in">INT</span>,</span><br><span class="line">    column2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    column3 <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci <span class="comment">-- 对单独的列进行指定</span></span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci; <span class="comment">-- 对整个表指定</span></span><br></pre></td></tr></table></figure><blockquote><p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。COLLATE（校对）还可以用于GROUP BY、HAVING、聚集函数、别名等。</p></blockquote><ul><li>如果指定CHARACTER SET和COLLATE两者，则使用这些值。</li><li>如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。</li><li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</li><li>如果绝对需要，串可以在字符集之间进行转换。为此，使用<a href="https://www.cnblogs.com/chenqionghe/p/4675844.html" rel="external nofollow noopener noreferrer" target="_blank">Cast()或Convert()</a>函数(转换数据类型的两个函数)</li></ul><blockquote><p>下面这个链接在mysql中样式是没用的<br><a href="https://blog.csdn.net/zengcong2013/article/details/51235616" rel="external nofollow noopener noreferrer" target="_blank">SQL中的cast和convert的用法和区别</a> convert函数样式</p></blockquote><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><blockquote><p>用户(user_name)定义为 user@host MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。</p></blockquote><ul><li><p>查看数据库的权限</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql; <span class="comment">-- 选择数据库</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> <span class="keyword">user</span>; <span class="comment">-- 查看用户权限</span></span><br></pre></td></tr></table></figure></li><li><p>创建用户账号</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IDENTIFIED BY PASSWORD</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user_name <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'xxx'</span>; <span class="comment">-- IDENTIFIED 给出了一个口令（密码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置口令(密码) 不指定用户则更改的是当前登录用户</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="string">'xxx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置指定用户口令(密码)</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="keyword">user</span>@host = <span class="keyword">password</span>(<span class="string">'新密码'</span>);</span><br></pre></td></tr></table></figure></li><li><p>重命名用户账号</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> old_user_name <span class="keyword">TO</span> new_user_name</span><br></pre></td></tr></table></figure></li><li><p>删除用户账号</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> user_name</span><br></pre></td></tr></table></figure></li><li><p>设置用户权限</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> user_name; <span class="comment">-- 查看用户的权限</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> GRANT：</span></span><br><span class="line"><span class="comment">     1 要授予的权限</span></span><br><span class="line"><span class="comment">     2 被授予访问权限的数据库或表</span></span><br><span class="line"><span class="comment">     3 用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 设置权限</span></span><br><span class="line"> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> user_name; <span class="comment">-- crashcourse 数据库的所有表上授予SELECT访问权限 该用户(user_name)对 crashcourse 数据库中的所有数据具有只读访问权限</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 撤销权限 取消上面的授权 如果撤销的权限没有会报错</span></span><br><span class="line"> <span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">FROM</span> user_name;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> GRANT 和 REVOKE 可在几个层次上控制访问权限：</span></span><br><span class="line"><span class="comment">     * 整个服务器，使用 GRANT ALL 和 REVOKE ALL</span></span><br><span class="line"><span class="comment">     * 整个数据库，使用 ON database.*</span></span><br><span class="line"><span class="comment">     * 特定的表，使用 ON database.table；</span></span><br><span class="line"><span class="comment">     * 特定的列；GRANT UPDATE (columns) ON database.table TO user_name 对columns列给予更行权限</span></span><br><span class="line"><span class="comment">     * 特定的存储过程 ON PROCEDURE `procedure_name` TO 'user_name'</span></span><br><span class="line"><span class="comment">     * 撤销存储过程权限 把GRANT 变为 REVOKE 把 TO 变为 FROM</span></span><br><span class="line"><span class="comment">     * 刷新权限 FLUSH PRIVILEGES;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 可通过列出各权限并用逗号分隔，将多条GRANT语句串在一起，如下所示</span></span><br><span class="line"> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> user_name;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.cnblogs.com/Richardzhu/p/3318595.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL之权限管理</a><br><a href="https://blog.51cto.com/accole/2167905" rel="external nofollow noopener noreferrer" target="_blank">MySQL列权限和程序权限管理</a><br><a href="https://blog.csdn.net/dajiangqingzhou/article/details/83621045" rel="external nofollow noopener noreferrer" target="_blank">MySQL 简单权限控制(授予某个用户执行某一个存储过程的权限</a></p><p>可以授予或撤销的每个权限。</p><table><thead><tr><th>权 限</th><th>说 明</th></tr></thead><tbody><tr><td>ALL</td><td>除GRANT OPTION外的所有权限</td></tr><tr><td>ALTER</td><td>使用ALTER TABLE</td></tr><tr><td>ALTER ROUTINE</td><td>使用ALTER PROCEDURE和DROP PROCEDURE</td></tr><tr><td>CREATE</td><td>使用CREATE TABLE</td></tr><tr><td>CREATE ROUTINE</td><td>使用CREATE PROCEDURE</td></tr><tr><td>CREATE</td><td>TEMPORARY</td></tr><tr><td>TABLES</td><td>使用CREATE TEMPORARY TABLE</td></tr><tr><td>CREATE USER</td><td>使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td></tr><tr><td>CREATE VIEW</td><td>使用CREATE VIEW</td></tr><tr><td>DELETE</td><td>使用DELETE</td></tr><tr><td>DROP</td><td>使用DROP TABLE</td></tr><tr><td>EXECUTE</td><td>使用CALL和存储过程 执行权限</td></tr><tr><td>FILE</td><td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td></tr><tr><td>GRANT OPTION</td><td>使用GRANT和REVOKE</td></tr><tr><td>INDEX</td><td>使用CREATE INDEX和DROP INDEX</td></tr><tr><td>INSERT</td><td>使用INSERT</td></tr><tr><td>LOCK TABLES</td><td>使用LOCK TABLES</td></tr><tr><td>PROCESS</td><td>使用SHOW FULL PROCESSLIST</td></tr><tr><td>RELOAD</td><td>使用FLUSH</td></tr><tr><td>REPLICATION CLIENT</td><td>服务器位置的访问</td></tr><tr><td>REPLICATION SLAVE</td><td>由复制从属使用</td></tr><tr><td>SELECT</td><td>使用SELECT</td></tr><tr><td>SHOW DATABASES</td><td>使用SHOW DATABASES</td></tr><tr><td>SHOW VIEW</td><td>使用SHOW CREATE VIEW</td></tr><tr><td>SHUTDOWN</td><td>使用mysqladmin shutdown（用来关闭MySQL）</td></tr><tr><td>SUPER</td><td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录</td></tr><tr><td>UPDATE</td><td>使用UPDATE</td></tr><tr><td>USAGE</td><td>无访问权限</td></tr></tbody></table><ul><li>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。</li></ul><h3 id="数据库的维护"><a href="#数据库的维护" class="headerlink" title="数据库的维护"></a>数据库的维护</h3><ul><li>数据库的备份<ul><li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li><li>可用命令行实用程序<code>mysqlhotcopy</code>从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。</li><li>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据以用<code>RESTORE TABLE</code>来复原。</li></ul></li><li>首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用<code>FLUSH TABLES</code>语句。</li></ul><p><a href="https://zhidao.baidu.com/question/983448011434445459.html" rel="external nofollow noopener noreferrer" target="_blank">FLUSH TABLES的作用</a></p><ul><li><p>查看数据库正确性和正常运行</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ANALYZE</span> <span class="keyword">TABLE</span> tablename <span class="comment">-- 返回状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tablename <span class="comment">-- 发现和修复问题</span></span><br></pre></td></tr></table></figure></li><li><p>如果<code>MyISAM</code>表访问产生不正确和不一致的结果，可能需要用<code>REPAIR TABLE</code>来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</p></li><li>如果从一个表中删除大量数据，应该使用<code>OPTIMIZE TABLE</code>来收回所用的空间，从而优化表的性能</li><li>在排除系统启动问题时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行mysqld启动。下面是几个重要的mysqld命令行选项：<ul><li>–help显示帮助——一个选项列表</li><li>–safe-mode装载减去某些最佳配置的服务器</li><li>–verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）</li><li>–version显示版本信息然后退出</li></ul></li></ul><p><a href="https://www.cnblogs.com/zhenghongxin/p/5570658.html" rel="external nofollow noopener noreferrer" target="_blank">REPAIR TABLE和OPTIMIZE TABLE</a></p><ul><li>查看日志<ul><li>主要的日志文件有以下几种。<ul><li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。此日志名可用<code>--log-error</code>命令行选项更改。</li><li>查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为<code>hostname.log</code>，位于data目录中。此名字可以用<code>--log</code>命令行选项更改。</li><li>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为<code>hostname-bin</code>，位于data目录内。此名字可以用<code>--log-bin</code>命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。</li><li>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为<code>hostname-slow.log</code> ，位于 data 目录中。此名字可以用<code>--log-slow-queries</code>命令行选项更改。</li></ul></li></ul></li><li>在使用日志时，可用<code>FLUSH LOGS</code>语句来刷新和重新开始所有日志文件。</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。</li><li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用<code>SHOW VARIABLES;</code>和<code>SHOWSTATUS;</code>。）</li><li>MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用<code>SHOW PROCESSLIST</code> 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用<code>KILL</code>命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li><li>总是有不止一种方法编写同一条<code>SELECT</code>语句。应该试验联结、并、子查询等，找出最佳的方法。</li><li>使用EXPLAIN(注释)语句让<code>MySQL</code>解释它将如何执行一条<code>SELECT</code>语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li><li>应该总是使用正确的数据类型。</li><li>决不要检索比需求还要多的数据。换言之，不要用<code>SELECT *</code>（除非你真正需要每个列）。</li><li>有的操作（包括<code>INSERT</code>）支持一个可选的<a href="https://www.jianshu.com/p/b67a01dbdd3b" rel="external nofollow noopener noreferrer" target="_blank">DELAYED</a>(延时插入)关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li><li>在导入数据时，应该关闭自动提交。你可能还想删除索引（包括<code>FULLTEXT</code>索引），然后在导入完成后再重建它们。</li><li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的<code>SELECT</code>语句以找出重复的<code>WHERE</code>和<code>ORDER BY</code>子句。如果一个简单的<code>WHERE</code>子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。</li><li>你的<code>SELECT</code>语句中有一系列复杂的<code>OR</code>条件吗？通过使用多条<code>SELECT</code>语句和连接它们的<code>UNION</code>语句，你能看到极大的性能改进。</li><li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）</li><li><code>LIKE</code>很慢。一般来说，最好是使用<code>FULLTEXT</code>而不是<code>LIKE</code>。</li><li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</li><li>最重要的规则就是，每条规则在某些条件下都会被打破。</li></ul><p><a href="http://dev.mysql.com/doc/" rel="external nofollow noopener noreferrer" target="_blank">MySQL文档</a> 一定要多查看这些非常有价值的资料。</p>]]></content>
    
    <summary type="html">
    
      MySQL一些通用命令
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="MySQL常用命令" scheme="http://www.tjl-myblog.cn/tags/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Excel使用笔记</title>
    <link href="http://www.tjl-myblog.cn/Excel%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.tjl-myblog.cn/Excel使用笔记.html</id>
    <published>2019-03-06T04:07:40.000Z</published>
    <updated>2019-12-21T11:04:47.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><blockquote><p>sumifs(参数1[求和的区域],求和的条件区域1,求和的绝对条件1,求和的条件区域2,求和的绝对条件2)<br><a href="https://baijiahao.baidu.com/s?id=1610046172489107536&amp;wfr=spider&amp;for=pc&amp;isFailFlag=1" rel="external nofollow noopener noreferrer" target="_blank">Excel中多条件求和函数-sumifs</a></p></blockquote><blockquote><p>合并文本 CONCATENATE(“xxx”) xxx表示不变的<br><a href="https://jingyan.baidu.com/article/c45ad29cd8014b051753e20e.html" rel="external nofollow noopener noreferrer" target="_blank">CONCATENATE函数</a></p></blockquote><blockquote><p>筛选求和<br><a href="https://baijiahao.baidu.com/s?id=1613768540901625738&amp;wfr=spider&amp;for=pc" rel="external nofollow noopener noreferrer" target="_blank">Excel SubTotal函数的使用方法，含隐藏筛选和分类汇总实例</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Excel使用
    
    </summary>
    
      <category term="Excel使用" scheme="http://www.tjl-myblog.cn/categories/Excel%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Excel" scheme="http://www.tjl-myblog.cn/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>C/C++注意事项</title>
    <link href="http://www.tjl-myblog.cn/C-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html"/>
    <id>http://www.tjl-myblog.cn/C-注意事项.html</id>
    <published>2019-03-05T09:22:42.000Z</published>
    <updated>2020-12-26T04:55:31.277Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="c-c-不能返回局部对象和局部变量的指针或引用解释"><a href="#c-c-不能返回局部对象和局部变量的指针或引用解释" class="headerlink" title="c/c++不能返回局部对象和局部变量的指针或引用解释"></a>c/c++不能返回局部对象和局部变量的指针或引用解释</h2><p>在编写c/c++代码时，调用函数的书写让程序变得整洁易读，但是调用函数的返回值(局部变量的返回值，变量，结构体，数组等)也有注意事项。c/c++严禁返回局部变量的指针或引用。</p><p>其实函数的返回值的规则非常好记：</p><p>　　函数的返回值可以是数值和全局变量的指针或引用。</p><p>　　函数的返回值不能是局部对象或者是局部变量的指针或引用！！！</p><p>原因：</p><p>　　调用函数的局部变量是存在于栈中的，在执行完调用函数之后会将局部变量的空间释放，也就是调用函数执行后局部变量将不存在与内存中。如果返回的是局部变量的指针或者是引用。返回给接收对象的是局部变量的地址，而这个地址的资源已经被释放了，也就是接受的返回值都将是空值(因为被释放)，会出错。</p><p>补充：局部变量返回指针或引用都是地址，而返回数值是值。(概念不同)</p><p><a href="https://www.cnblogs.com/spring-hailong/p/6135589.html" rel="external nofollow noopener noreferrer" target="_blank">原文</a></p>]]></content>
    
    <summary type="html">
    
      C/C++不能返回局部对象和局部变量的指针或引用解释
    
    </summary>
    
      <category term="C/C++" scheme="http://www.tjl-myblog.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://www.tjl-myblog.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>DIY电脑知识</title>
    <link href="http://www.tjl-myblog.cn/DIY%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86.html"/>
    <id>http://www.tjl-myblog.cn/DIY电脑知识.html</id>
    <published>2019-02-23T10:33:45.000Z</published>
    <updated>2019-12-21T11:04:47.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p><a href="http://www.lotpc.com/zjjc/7016.html" rel="external nofollow noopener noreferrer" target="_blank">XFR技术(我们可以理解为自动超频技术)</a></p><p><a href="http://www.lotpc.com/pzzs/7003.html" rel="external nofollow noopener noreferrer" target="_blank">AMD锐龙Ryzen5 1400配主板</a></p><p>华硕主板 后面的字母含义：这些都是指同芯片组的定位，A的定位最高，扩展口基本是最全的，用料也较好，F属于去掉某些功能的缩水版，K的话还要更精简。也就是A最好，越往后越缩水。</p><p><a href="https://www.pc841.com/wenda/87122.html" rel="external nofollow noopener noreferrer" target="_blank">显卡后面的Ti是什么意思(带Ti表示增强版)</a></p><p><a href="https://product.pconline.com.cn/itbk/software/dnyw/1709/10004749.html" rel="external nofollow noopener noreferrer" target="_blank">电脑主板参数有什么含义</a></p><p><a href="http://www.chachaba.com/news/digi/tsj/20170622_315824.html" rel="external nofollow noopener noreferrer" target="_blank">AMD锐龙5-1400搭配什么主板显卡好</a></p>]]></content>
    
    <summary type="html">
    
      电脑组装技巧
    
    </summary>
    
      <category term="电脑组装技巧" scheme="http://www.tjl-myblog.cn/categories/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="电脑组装技巧" scheme="http://www.tjl-myblog.cn/tags/%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>修改Lua源码实现Lua只读表</title>
    <link href="http://www.tjl-myblog.cn/%E4%BF%AE%E6%94%B9lua%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0lua%E5%8F%AA%E8%AF%BB%E8%A1%A8.html"/>
    <id>http://www.tjl-myblog.cn/修改lua源码实现lua只读表.html</id>
    <published>2019-02-21T10:37:02.000Z</published>
    <updated>2019-12-21T11:04:47.931Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p>首先找到元表枚举</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  TM_INDEX,</span><br><span class="line">  TM_NEWINDEX,</span><br><span class="line">  TM_ASSIGN,</span><br><span class="line">  TM_GC,</span><br><span class="line">  TM_MODE,</span><br><span class="line">  TM_LEN,</span><br><span class="line">  TM_EQ, <span class="comment">/* last tag method with `fast' access */</span></span><br><span class="line">  TM_ADD,</span><br><span class="line">  TM_SUB,</span><br><span class="line">  TM_MUL,</span><br><span class="line">  TM_DIV,</span><br><span class="line">  TM_MOD,</span><br><span class="line">  TM_POW,</span><br><span class="line">  TM_UNM,</span><br><span class="line">  TM_LT,</span><br><span class="line">  TM_LE,</span><br><span class="line">  TM_CONCAT,</span><br><span class="line">  TM_CALL,</span><br><span class="line">  TM_N <span class="comment">/* number of elements in the enum */</span></span><br><span class="line">&#125; TMS;</span><br></pre></td></tr></table></figure><p>在里面添加一个元素 <code>TM_ASSIGN</code></p><p>再找到<code>void luaT_init</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaT_init</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> luaT_eventname[] = &#123;  <span class="comment">/* ORDER TM */</span></span><br><span class="line">    <span class="string">"__index"</span>, <span class="string">"__newindex"</span>,<span class="string">"__assign"</span></span><br><span class="line">    <span class="string">"__gc"</span>, <span class="string">"__mode"</span>, <span class="string">"__len"</span>, <span class="string">"__eq"</span>,</span><br><span class="line">    <span class="string">"__add"</span>, <span class="string">"__sub"</span>, <span class="string">"__mul"</span>, <span class="string">"__div"</span>, <span class="string">"__mod"</span>,</span><br><span class="line">    <span class="string">"__pow"</span>, <span class="string">"__unm"</span>, <span class="string">"__lt"</span>, <span class="string">"__le"</span>,</span><br><span class="line">    <span class="string">"__concat"</span>, <span class="string">"__call"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;TM_N; i++) &#123;</span><br><span class="line">    G(L)-&gt;tmname[i] = luaS_new(L, luaT_eventname[i]);</span><br><span class="line">    luaS_fix(G(L)-&gt;tmname[i]);  <span class="comment">/* never collect these names */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面添加<code>__assign</code></p><p>最后找到<code>void luaV_settable</code>函数</p><blockquote><p>下面这段源码有些函数作用是猜想的 可能并不是很准确 lua5.2.4的函数 可能版本之间有着小差异 但是只要理解了 我想应该都不影响</p></blockquote><p>lua 5.2.4源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaV_settable</span><span class="params">(lua_State *L, <span class="keyword">const</span> TValue *t, TValue *key, StkId val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; MAXTAGLOOP; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> TValue *tm;</span><br><span class="line">        <span class="keyword">if</span> (ttistable(t)) <span class="comment">//判断表是否存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            Table *h = hvalue(t); <span class="comment">//获取表中的值</span></span><br><span class="line">            TValue *oldval = cast(TValue *, luaH_get(h, key)); <span class="comment">//获取旧的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//ttisnil 是否为false  [ ((!ttisnil) 表示当值存在的时候 或者(||) 当 没有__nexindex方法的时候) 并且(&amp;&amp;) 当没有相同值的时候 或者(||) 有新的键值的时候     进入    条件     进行表中的赋值修改操作]</span></span><br><span class="line">            <span class="keyword">if</span> (!ttisnil(oldval) || ((tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX)) == <span class="literal">NULL</span> &amp;&amp; (oldval != luaO_nilobject || (oldval = luaH_newkey(L, h, key)    , <span class="number">1</span>)    )))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当有这个TM__ASSIGN元方法存在（不能对已有的键值 进行修改）</span></span><br><span class="line">                <span class="keyword">if</span> (((tm = fasttm(L, h-&gt;metatable, TM_ASSIGN))))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//当值不存在的时候才阔以写入</span></span><br><span class="line">                    <span class="keyword">if</span> (ttisnil(oldval))</span><br><span class="line">                    &#123;</span><br><span class="line">                        setobj2t(L, oldval, val);</span><br><span class="line">                        invalidateTMcache(h);</span><br><span class="line">                        luaC_barrierback(L, obj2gco(h), val);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    setobj2t(L, oldval, val);</span><br><span class="line">                    invalidateTMcache(h);</span><br><span class="line">                    luaC_barrierback(L, obj2gco(h), val);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX))) <span class="comment">//不是一个表 检查元方法</span></span><br><span class="line">            luaG_typeerror(L, t, <span class="string">"index"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ttisfunction(tm)) <span class="comment">//如果元方法是一个函数 这个应该就是函数回调</span></span><br><span class="line">        &#123;</span><br><span class="line">            callTM(L, tm, t, key, val, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = tm;</span><br><span class="line">    &#125;</span><br><span class="line">    luaG_runerror(L, <span class="string">"loop in settable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的操作 __assign 可以这样使用<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tab = &#123; <span class="comment">--只读元表</span></span><br><span class="line">    __assign = <span class="function"><span class="keyword">function</span><span class="params">(t,k,v)</span></span> <span class="comment">--对已有的key值不能进行操作</span></span><br><span class="line">            <span class="built_in">error</span>(<span class="string">'read only __assign:'</span> .. <span class="built_in">tostring</span>(k).. <span class="string">'__'</span>.. <span class="built_in">tostring</span>(v))</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k,v)</span></span> <span class="comment">--不能进行表的写入</span></span><br><span class="line"><span class="built_in">error</span>(<span class="string">'read only __newindex:'</span> .. <span class="built_in">tostring</span>(k)..<span class="string">'__'</span>.. <span class="built_in">tostring</span>(v))</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果这个表中 新插入的键值是已有的 就会走到这</p><p>lua 5.1.5源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaV_settable</span><span class="params">(lua_State *L, <span class="keyword">const</span> TValue *t, TValue *key, StkId val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loop;</span><br><span class="line">    TValue temp;</span><br><span class="line">    <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; MAXTAGLOOP; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> TValue *tm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (ttistable(t))</span><br><span class="line">        &#123;</span><br><span class="line">            Table *h = hvalue(t);</span><br><span class="line">            TValue *oldval = luaH_set(L, h, key);</span><br><span class="line">            <span class="comment">//当旧值为空 TM_NEWINDEX 为空的时候 把元素添加进原来的表</span></span><br><span class="line">            <span class="keyword">if</span> (ttisnil(oldval) &amp;&amp; (tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX)) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                setobj2t(L, oldval, val);</span><br><span class="line">                h-&gt;flags = <span class="number">0</span>;</span><br><span class="line">                luaC_barriert(L, h, val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当这个值存在 并且 要没有TM_ASSIGN元方法才阔以添加 如果添加不进去</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!ttisnil(oldval) &amp;&amp; (tm = fasttm(L, h-&gt;metatable, TM_ASSIGN)) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                setobj2t(L, oldval, val);</span><br><span class="line">                h-&gt;flags = <span class="number">0</span>;</span><br><span class="line">                luaC_barriert(L, h, val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))</span><br><span class="line">            luaG_typeerror(L, t, <span class="string">"index"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ttisfunction(tm))</span><br><span class="line">        &#123;</span><br><span class="line">            callTM(L, tm, t, key, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* else repeat with `tm' */</span></span><br><span class="line">        setobj(L, &amp;temp, tm);  <span class="comment">/* avoid pointing inside table (may rehash) */</span></span><br><span class="line">        t = &amp;temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    luaG_runerror(L, <span class="string">"loop in settable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>MAXTAGLOOP</code> 如果用元方法继承 层次操作这个值 就会失效 有必要的时候阔以自己调整 (这个是方法链限制 避免循环)</p></blockquote>]]></content>
    
    <summary type="html">
    
      实现Lua只读表
    
    </summary>
    
      <category term="Lua" scheme="http://www.tjl-myblog.cn/categories/Lua/"/>
    
    
      <category term="实现lua只读表" scheme="http://www.tjl-myblog.cn/tags/%E5%AE%9E%E7%8E%B0lua%E5%8F%AA%E8%AF%BB%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MTU</title>
    <link href="http://www.tjl-myblog.cn/MTU.html"/>
    <id>http://www.tjl-myblog.cn/MTU.html</id>
    <published>2019-02-20T08:51:37.000Z</published>
    <updated>2019-12-21T11:04:47.921Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a><br><a href="https://baike.baidu.com/item/mtu/508920?fr=aladdin" rel="external nofollow noopener noreferrer" target="_blank">MTU</a><br><a href="http://www.webkaka.com/info/archives/speedup/2011/04/01839/" rel="external nofollow noopener noreferrer" target="_blank">利用修改主机的mtu和路由的mtu达到最佳网速</a><br><a href="https://jingyan.baidu.com/article/d45ad148e18cf869552b8089.html" rel="external nofollow noopener noreferrer" target="_blank">小米手机修改mtu值 (临时性)</a><br><a href="https://jingyan.baidu.com/article/5bbb5a1b05256c13eba179e6.html" rel="external nofollow noopener noreferrer" target="_blank">设置路由器MTU数值与DNS服务器达到低延迟零丢包</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.tjl-myblog.cn:4455/one.jpg&quot; alt=&quot;图片还没有哦&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MTU" scheme="http://www.tjl-myblog.cn/categories/MTU/"/>
    
    
      <category term="MTU" scheme="http://www.tjl-myblog.cn/tags/MTU/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记</title>
    <link href="http://www.tjl-myblog.cn/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.tjl-myblog.cn/Go学习笔记.html</id>
    <published>2019-02-13T08:48:31.000Z</published>
    <updated>2019-12-21T11:04:47.917Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p><a href="https://www.cnblogs.com/zsy/p/5215336.html" rel="external nofollow noopener noreferrer" target="_blank">Go语言下载、安装、配置</a>(下载之后其实会自动帮你配好环境变量 如果没有配好的可自行配置)</p><h2 id="Go语言标准库常用的包及功能"><a href="#Go语言标准库常用的包及功能" class="headerlink" title="Go语言标准库常用的包及功能"></a>Go语言标准库常用的包及功能</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Go语言标准库包名</th><th style="text-align:center">功  能</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">bufio</td><td style="text-align:center">带缓冲的 I/O 操作</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">bytes</td><td style="text-align:center">实现字节操作</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">container</td><td style="text-align:center">封装堆、列表和环形列表等容器</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">crypto</td><td style="text-align:center">加密算法</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">database</td><td style="text-align:center">数据库驱动和接口</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">debug</td><td style="text-align:center">各种调试文件格式访问及调试功能</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">encoding</td><td style="text-align:center">常见算法如 JSON、XML、Base64 等</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">flag</td><td style="text-align:center">命令行解析</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">fmt</td><td style="text-align:center">格式化操作</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">go</td><td style="text-align:center">Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">html</td><td style="text-align:center">HTML 转义及模板系统</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">image</td><td style="text-align:center">常见图形格式的访问及生成</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">io实现</td><td style="text-align:center">I/O 原始访问接口及访问封装</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">math</td><td style="text-align:center">数学库</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">net</td><td style="text-align:center">网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">os</td><td style="text-align:center">操作系统平台不依赖平台操作封装</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">path</td><td style="text-align:center">兼容各操作系统的路径操作实用函数</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">plugin</td><td style="text-align:center">Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">reflect</td><td style="text-align:center">语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">regexp</td><td style="text-align:center">正则表达式封装</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">runtime</td><td style="text-align:center">运行时接口</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">sort</td><td style="text-align:center">排序接口</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">strings</td><td style="text-align:center">字符串转换、解析及实用函数</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">time</td><td style="text-align:center">时间接口</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">text</td><td style="text-align:center">文本模板及 Token 词法器</td><td></td></tr></tbody></table><h2 id="Go语言的目录结构"><a href="#Go语言的目录结构" class="headerlink" title="Go语言的目录结构"></a>Go语言的目录结构</h2><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Go学习笔记/1.png" alt="图片消失啦"></p><h2 id="一个简单的Go程序"><a href="#一个简单的Go程序" class="headerlink" title="一个简单的Go程序"></a>一个简单的Go程序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello Go"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是代码说明：<br>第 1 行，标记当前文件为 main 包，main 包也是 Go 程序的入口包。<br>第 3 行，导入 fmt 格式化操作包<br>第 6 行，程序执行的入口函数 main()。<br>第 6 行，打印<code>Hello Go</code></p><h2 id="Go语言变量声明"><a href="#Go语言变量声明" class="headerlink" title="Go语言变量声明"></a>Go语言变量声明</h2><h3 id="了解变量"><a href="#了解变量" class="headerlink" title="了解变量"></a>了解变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">e</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第1行，声明一个整型类型的变量，可以保存整数数值。<br>第2行，声明一个字符串类型的变量。<br>第3行，声明一个 32 位浮点<a href="https://www.jb51.net/article/143729.htm" rel="external nofollow noopener noreferrer" target="_blank">切片类型</a>(动态数组)的变量，浮点切片表示由多个浮点类型组成的数据结构。<br>第4行，声明一个返回值为布尔类型的函数变量，这种形式一般用于回调函数，即将函数以变量的形式保存下来，在需要的时候重新调用这个函数。<br>第5行，声明一个结构体类型的变量，这个结构体拥有一个整型的 x 字段。</p><p>上面代码的共性是，以 var 关键字开头，要声明的变量名放在中间，而将其类型放在后面。</p><p>变量的声明有几种形式，通过下面几节进行整理归纳。</p><h3 id="标准变量格式"><a href="#标准变量格式" class="headerlink" title="标准变量格式"></a>标准变量格式</h3><p>var 变量名 变量类型</p><p>变量声明以关键字<code>var</code>开头，后置变量类型，行尾无须分号。</p><h3 id="批量格式"><a href="#批量格式" class="headerlink" title="批量格式"></a>批量格式</h3><p>觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">e</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用关键字var和括号，可以将一组变量定义放在一起。</p><h2 id="Go语言变量的初始化"><a href="#Go语言变量的初始化" class="headerlink" title="Go语言变量的初始化"></a>Go语言变量的初始化</h2><h3 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h3><p><strong>回顾C语言声明变量时</strong><br>在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。</p><p>在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于C/C++中变量默认不初始化。<br>微软的 VC 编译器会将未初始化的栈空间以 16 进制的 <strong>0xCC</strong> 填充，而未初始化的堆空间使用 <strong>0xCD</strong> 填充，而 <strong>0xCCCC</strong> 和 <strong>0xCDCD</strong> 在中文的 <strong>GB2312</strong> 编码中刚好对应“烫”和“屯”字。</p><p>因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。</p><p><strong>Go在声明变量时</strong><br>Go会对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：<br>整型和浮点型变量的默认值为 0。<br>字符串变量的默认值为空字符串。<br>布尔型变量默认为 bool。<br>切片、函数、指针变量的默认为 nil。</p><blockquote><p>当然，依然可以在变量声明时赋予变量一个初始值。</p></blockquote><h3 id="变量初始化的标准格式"><a href="#变量初始化的标准格式" class="headerlink" title="变量初始化的标准格式"></a>变量初始化的标准格式</h3><p>var 变量名 类型 = 表达式</p><h3 id="编译器推导类型的格式"><a href="#编译器推导类型的格式" class="headerlink" title="编译器推导类型的格式"></a>编译器推导类型的格式</h3><p>在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。<br><code>var hp = 100</code><br>等号右边的部分在编译原理里被称做右值（rvalue）。</p><p>下面是编译器根据右值推导变量类型完成初始化的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attack = <span class="number">40</span></span><br><span class="line"><span class="keyword">var</span> defence = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> damageRate <span class="keyword">float32</span> = <span class="number">0.17</span></span><br><span class="line"><span class="keyword">var</span> damage = <span class="keyword">float32</span>(attack-defence) * damageRate</span><br><span class="line">fmt.Println(damage)</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 1 和 2 行，右值为整型 <strong>attack</strong> 和 <strong>defence</strong> 变量的类型为 <strong>int</strong>。<br>第 3 行，表达式的右值中使用了 <strong>0.17</strong>。<strong>Go 语言和C语言一样</strong>，编译器会尽量提高精确度，以避免计算中的精度损失。</p><blockquote><p>默认情况下，如果不指定 <code>damageRate</code> 变量的类型，<code>Go</code>语言编译器会将 <code>damageRate</code> 类型推导为 <code>float64</code> 由于这个例子中不需要 <code>float64</code> 的精度，所以强制指定类型为 <code>float32</code></p></blockquote><p>第 4 行，将 <strong>attack</strong> 和 <strong>defence</strong> 相减后的数值结果依然为整型，使用 <strong>float32()</strong> 将结果转换为 <strong>float32</strong> 类型，再与 <strong>float32</strong> 类型的 <strong>damageRate</strong> 相乘后 <strong>damage</strong> 类型也是 <strong>float32</strong> 类型。</p><blockquote><p>提示：<code>damage</code> 变量的右值是一个复杂的表达式，整个过程既有 <code>attack</code> 和 <code>defence</code> 的运算还有强制类型转换。强制类型转换会在后面的章节中介绍。</p></blockquote><p>第 5 行，输出<strong>damage</strong>的值。<br>以上代码输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go3.4</span><br></pre></td></tr></table></figure><h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p><strong>var</strong> 的变量声明还有一种更为精简的写法，例如：<br><code>hp := 100</code><br>这是 Go 语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。</p><blockquote><p>注意：由于使用了:=，而不是赋值的=，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。</p></blockquote><p>使用了<code>:=</code>就不要使用<strong>var</strong>不然会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax error: unexpected :=, expecting <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>如果 hp 已经被声明过，但依然使用:=时编译器会报错，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 hp 变量</span></span><br><span class="line"><span class="keyword">var</span> hp <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 再次声明并赋值</span></span><br><span class="line">hp := <span class="number">10</span></span><br></pre></td></tr></table></figure><p>编译报错如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no <span class="built_in">new</span> variables on left side of :=</span><br></pre></td></tr></table></figure><p>意思是，在<code>:=</code>的左边没有新变量出现，意思就是<code>:=</code>的左边变量已经被声明了。</p><p>短变量声明的形式在开发中的例子较多，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8080"</span>)</span><br></pre></td></tr></table></figure><p><code>net.Dial</code> 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象，一个是 <code>err</code> 对象。如果是标准格式将会变成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> conn net.Conn</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">conn, err = net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br></pre></td></tr></table></figure><p>因此，短变量声明并初始化的格式在开发中使用比较普遍。</p><blockquote><p>注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错</p></blockquote><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">conn2, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br></pre></td></tr></table></figure><p>上面的代码片段，编译器不会报err重复定义。</p><h2 id="Go语言多个变量同时赋值"><a href="#Go语言多个变量同时赋值" class="headerlink" title="Go语言多个变量同时赋值"></a>Go语言多个变量同时赋值</h2><h3 id="两值之间的交换"><a href="#两值之间的交换" class="headerlink" title="两值之间的交换"></a>两值之间的交换</h3><p>第一种是用位操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可交换两个变量的值</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b) <span class="comment">//结果为 200  100 这里省去了中间值的操作</span></span><br></pre></td></tr></table></figure><p>第二种使用Go的<code>多重赋值</code>特性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br><span class="line">fmt.Println(a, b) <span class="comment">//结果为 200 100</span></span><br></pre></td></tr></table></figure><h2 id="Go语言匿名变量（没有名字的变量）"><a href="#Go语言匿名变量（没有名字的变量）" class="headerlink" title="Go语言匿名变量（没有名字的变量）"></a>Go语言匿名变量（没有名字的变量）</h2><p>在使用多重赋值时，如果不需要在左值中接收变量，可以使用匿名变量（anonymous variable）</p><p>匿名变量的表现是一个下画线_，使用匿名变量时，只需要在变量声明的地方使用下画线替换即可例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line">a, _ := GetData()</span><br><span class="line">_, b := GetData()</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><h2 id="Go语言整型（整数类型）"><a href="#Go语言整型（整数类型）" class="headerlink" title="Go语言整型（整数类型）"></a>Go语言整型（整数类型）</h2><p><strong>Go 语言中有丰富的数据类型</strong> 除了基本的<strong>整型</strong>、<strong>浮点型</strong>、<strong>布尔型</strong>、<strong>字符串外</strong>，还有<strong>切片</strong>、<strong>结构体</strong>、<strong>函数</strong>、<strong>map</strong>、<strong>通道</strong> <code>(channel)</code>等。Go 语言的<strong>基本类型和其他语言大同小异</strong>，<strong>切片类型</strong>有着指针的<strong>便利性</strong>，但比指针更为<strong>安全</strong>，很多高级语言都配有切片进行安全和高效率的内存操作。</p><p>本节我们将介绍最基本的整型。</p><p><strong>整型分为以下两个大类</strong>：</p><p>按长度分为：<strong>int8、int16、int32、int64</strong><br>还有对应的无符号整型：<strong>uint8、uint16、uint32、uint64</strong></p><p>其中，<strong>uint8</strong> 就是我们熟知的 <strong>byt</strong>e 型，<strong>int16</strong> 对应C语言中的 <strong>short</strong> 型，<strong>int64</strong> 对应C语言中的 <strong>long</strong> 型。</p><h3 id="自动匹配平台的-int-和-uint"><a href="#自动匹配平台的-int-和-uint" class="headerlink" title="自动匹配平台的 int 和 uint"></a>自动匹配平台的 int 和 uint</h3><p>Go 语言也有自动匹配特定平台整型长度的类型—— <strong>int</strong> 和 <strong>uint</strong>。</p><p>可以跨平台的编程语言可以运行在多种平台上。平台的字节长度是有差异的。<strong>64位</strong>平台现今已经较为普及，但 <strong>8 位、16位、32</strong> 位的操作系统依旧存在。<strong>16位</strong> 平台上依然可以使用 <strong>64位</strong> 的变量，但运行性能和内存性能上较差。同理，在 <strong>64</strong> 位平台上大量使用 <strong>8位、16位</strong> 等与平台位数不等长的变量时，编译器也是尽量将内存对齐以获得最好的性能。</p><p>不能正确匹配平台字节长度的程序就类似于用轿车运一头牛和用一辆卡车运送一头牛的情形一样。</p><p>在使用 <strong>int 和 uint类型</strong> 时，不能假定它是 <strong>32位</strong> 或 <strong>64位</strong> 的整型，而是考虑 int 和 uint 可能在不同平台上的差异。</p><h3 id="哪些情况下使用-int-和-uint"><a href="#哪些情况下使用-int-和-uint" class="headerlink" title="哪些情况下使用 int 和 uint"></a>哪些情况下使用 int 和 uint</h3><p>逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 <strong>len()</strong> 函数返回，这个长度可以根据不同平台的字节长度进行变化。<strong>实际使用中，切片或 map 的元素数量等都可以用 int 来表示</strong>。</p><p>反之，<strong>在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint</strong>。</p><h2 id="Go语言浮点类型（小数类型）"><a href="#Go语言浮点类型（小数类型）" class="headerlink" title="Go语言浮点类型（小数类型）"></a>Go语言浮点类型（小数类型）</h2><p>Go语言支持两种浮点型数：<strong>float32</strong> 和 <strong>float64</strong>。这两种浮点型数据格式遵循 <strong>IEEE 754 标准</strong>：<br><strong>float32</strong> 的浮点数的最大范围约为 <strong>3.4e38</strong>，可以使用常量定义：<strong>math.MaxFloat32</strong>。<br><strong>float64</strong> 的浮点数的最大范围约为 <strong>1.8e308</strong>，可以使用一个常量定义：<strong>math.MaxFloat64</strong>。</p><p>打印浮点数时，可以使用 <strong>fmt</strong> 包配合动词 %f，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 7 行，按默认宽度和精度输出整型。<br>第 8 行，按默认宽度，2 位精度输出（小数点后的位数）。</p><p>代码运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.141593</span></span><br><span class="line"><span class="number">3.14</span></span><br></pre></td></tr></table></figure><h2 id="Go语言bool类型（布尔类型）"><a href="#Go语言bool类型（布尔类型）" class="headerlink" title="Go语言bool类型（布尔类型）"></a>Go语言bool类型（布尔类型）</h2><p>布尔型数据在 Go 语言中以 <strong>bool</strong> 类型进行声明，布尔型数据只有 <strong>true（真）和 false（假）</strong>两个值。</p><p>Go 语言中不允许将整型强制转换为布尔型，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">bool</span></span><br><span class="line">fmt.Println(<span class="keyword">int</span>(n) * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>编译错误，输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert n (<span class="keyword">type</span> <span class="keyword">bool</span>) to <span class="keyword">type</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p><h3 id="Go语言字符串"><a href="#Go语言字符串" class="headerlink" title="Go语言字符串"></a>Go语言字符串</h3><p>字符串在 Go 语言中以原生数据类型出现，使用字符串就像使用其他原生数据类型（<strong>int、bool、float32、float64 等</strong>）一样。</p><p>提示：在 <strong>C++、C#</strong> 语言中，字符串以类的方式进行封装。</p><p>C# 语言中在使用泛型匹配约束类型时，字符串是以 <strong>Class</strong> 的方式存在，而不是 <strong>String</strong>，因为并没有“字符串”这种原生数据类型。</p><p>在 <strong>C++</strong> 语言中使用模板匹配类型时，为了使字符串与其他原生数据类型一样支持赋值操作，需要对字符串类进行操作符重载。</p><p>字符串的值为双引号中的内容，可以在 Go 语言的源码中直接添加非 <strong>ASCII</strong> 码字符，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line">ch := <span class="string">"中文"</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><p>Go语言的常见转义符</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">转移符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><code>\r</code></td><td style="text-align:center">回车符（返回行首）</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>\n</code></td><td style="text-align:center">换行符（直接跳到下一行的同列位置）</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>\t</code></td><td style="text-align:center">制表符</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>\&#39;</code></td><td style="text-align:center">单引号</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>\&quot;</code></td><td style="text-align:center">双引号</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><code>\\</code></td><td style="text-align:center">反斜杠</td><td></td></tr></tbody></table><p>在 Go 语言源码中使用转义符代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"str := \"c:\\Go\\bin\\go.exe\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"c:\Go\bin\go.exe"</span></span><br></pre></td></tr></table></figure><p>这段代码中将双引号和反斜杠<code>&quot;\&quot;</code>进行转义。</p><h3 id="字符串实现基于-UTF-8-编码"><a href="#字符串实现基于-UTF-8-编码" class="headerlink" title="字符串实现基于 UTF-8 编码"></a>字符串实现基于 UTF-8 编码</h3><p>Go 语言里的字符串的内部实现使用 <strong>UTF-8</strong> 编码。通过 <strong>rune</strong> 类型，可以方便地对每个 <strong>UTF-8</strong> 字符进行访问。当然，Go 语言也支持按传统的 ASCII 码方式进行逐字符访问。</p><p><strong>提示：Python</strong> 语言的 <strong>2.0</strong> 版本不是基于 <strong>UTF-8</strong> 编码设计，到了 <strong>3.0</strong> 版才改为 <strong>UTF-8</strong> 编码设计。因此，使用 <strong>2.0</strong> 版本时，在编码上会出现很多混乱情况。</p><p>同样，C/C++语言的 <strong>std::string</strong> 在使用 <strong>UTF-8</strong> 时，经常因为没有方便的 <strong>UTF-8</strong> 配套封装让编写极为困难。</p><p>关于字符串的 <strong>UTF-8</strong> 字符访问的详细方法，后面内容将会详细介绍。</p><h3 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h3><p>在源码中，将字符串的值以双引号书写的方式是字符串的常见表达方式，被称为字符串字面量（string literal）。这种双引号字面量不能跨行。如果需要在源码中嵌入一个多行字符串时，就必须使用`字符，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">` 第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">\r\n</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>`叫反引号，就是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。</p><p>在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="多行字符串一般用于内嵌源码和内嵌数据等，代码如下："><a href="#多行字符串一般用于内嵌源码和内嵌数据等，代码如下：" class="headerlink" title="多行字符串一般用于内嵌源码和内嵌数据等，代码如下："></a>多行字符串一般用于内嵌源码和内嵌数据等，代码如下：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> codeTemplate = <span class="string">`// Generated by github.com/davyxu/cellnet/</span></span><br><span class="line"><span class="string">protoc-gen-msg</span></span><br><span class="line"><span class="string">// DO NOT EDIT!&#123;&#123;range .Protos&#125;&#125;</span></span><br><span class="line"><span class="string">// Source: &#123;&#123;.Name&#125;&#125;&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">package &#123;&#123;.PackageName&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;if gt .TotalMessages 0&#125;&#125;</span></span><br><span class="line"><span class="string">import (</span></span><br><span class="line"><span class="string">    "github.com/davyxu/cellnet"</span></span><br><span class="line"><span class="string">    "reflect"</span></span><br><span class="line"><span class="string">    _ "github.com/davyxu/cellnet/codec/pb"</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">func init() &#123;</span></span><br><span class="line"><span class="string">    &#123;&#123;range .Protos&#125;&#125;</span></span><br><span class="line"><span class="string">    // &#123;&#123;.Name&#125;&#125;&#123;&#123;range .Messages&#125;&#125;</span></span><br><span class="line"><span class="string">    cellnet.RegisterMessageMeta("pb","&#123;&#123;.FullName&#125;&#125;", reflect.TypeOf((*&#123;&#123;.Name&#125;&#125;)(nil)).Elem(), &#123;&#123;.MsgID&#125;&#125;)    &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>这段代码只定义了一个常量 <strong>codeTemplate</strong>，类型为字符串，使用`定义。字符串的内容为一段代码生成中使用到的 Go 源码格式。</p><p>在`间的所有代码均不会被编译器识别，而只是作为字符串的一部分。</p><h2 id="字符串的常见用法"><a href="#字符串的常见用法" class="headerlink" title="字符串的常见用法"></a>字符串的常见用法</h2><h3 id="Go语言计算字符串长度——len-和RuneCountInString"><a href="#Go语言计算字符串长度——len-和RuneCountInString" class="headerlink" title="Go语言计算字符串长度——len()和RuneCountInString()"></a>Go语言计算字符串长度——len()和RuneCountInString()</h3><p>Go 语言的内建函数 len()，可以用来获取切片、字符串、通道（channel）等的长度。下面的代码可以用 len() 来获取字符串的长度。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tip1 := <span class="string">"genji is a ninja"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(tip1))</span><br><span class="line">tip2 := <span class="string">"忍者"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(tip2))</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>len()</strong> 函数的返回值的类型为 <strong>int</strong>，表示字符串的 <strong>ASCII</strong> 字符个数或字节长度。<br><strong>输出中第一行</strong>的 16 表示 tip1 的字符个数为 16。<br><strong>输出中第二行</strong>的 6 表示 tip2 的字符格式，也就是“忍者”的字符个数是 6，然而根据习惯，“忍者”的字符个数应该是 2。</p><p>这里的差异是由于 Go 语言的字符串都以 <strong>UTF-8</strong> 格式保存，每个中文占用 3 个字节，因此使用 len() 获得两个中文文字对应的 6 个字节。</p><p>如果希望按习惯上的字符个数来计算，就需要使用 Go 语言中 <strong>UTF-8</strong> 包提供的 <strong>RuneCountInString()</strong> 函数，统计 <strong>Uncode</strong> 字符数量。</p><p>下面的代码展示如何计算<strong>UTF-8</strong>的字符个数。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(utf8.RuneCountInString(<span class="string">"忍者"</span>))</span><br><span class="line">fmt.Println(utf8.RuneCountInString(<span class="string">"龙忍出鞘,fight!"</span>))</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>一般游戏中在登录时都需要输入名字，而名字一般有长度限制。考虑到国人习惯使用中文做名字，就需要检测字符串 UTF-8 格式的长度。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>ASCII</strong> 字符串长度使用 <strong>len()</strong> 函数。<br><strong>Unicode</strong> 字符串长度使用 <strong>utf8.RuneCountInString()</strong> 函数。</p><h3 id="Go语言遍历字符串——获取每一个字符串元素"><a href="#Go语言遍历字符串——获取每一个字符串元素" class="headerlink" title="Go语言遍历字符串——获取每一个字符串元素"></a>Go语言遍历字符串——获取每一个字符串元素</h3><p>遍历字符串有下面两种写法。<br>遍历每一个ASCII字符<br>遍历 ASCII 字符使用 for 的数值循环进行遍历，直接取每个字符串的下标获取 ASCII 字符，如下面的例子所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">theme := <span class="string">"狙击 start"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(theme); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"ascii: %c  %d\n"</span>, theme[i], theme[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ascii: ?  <span class="number">231</span></span><br><span class="line">ascii:     <span class="number">139</span></span><br><span class="line">ascii:     <span class="number">153</span></span><br><span class="line">ascii: ?  <span class="number">229</span></span><br><span class="line">ascii:     <span class="number">135</span></span><br><span class="line">ascii: ?  <span class="number">187</span></span><br><span class="line">ascii:    <span class="number">32</span></span><br><span class="line">ascii: s  <span class="number">115</span></span><br><span class="line">ascii: t  <span class="number">116</span></span><br><span class="line">ascii: a  <span class="number">97</span></span><br><span class="line">ascii: r  <span class="number">114</span></span><br><span class="line">ascii: t  <span class="number">116</span></span><br></pre></td></tr></table></figure><p>这种模式下取到的汉字“惨不忍睹”。由于没有使用 <strong>Unicode</strong>，汉字被显示为乱码。<br>按 <strong>Unicode</strong> 字符遍历字符串<br>同样的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">theme := <span class="string">"狙击 start"</span></span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> theme &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Unicode: %c  %d\n"</span>, s, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Unicode: 狙  <span class="number">29401</span></span><br><span class="line">Unicode: 击  <span class="number">20987</span></span><br><span class="line">Unicode:    <span class="number">32</span></span><br><span class="line">Unicode: s  <span class="number">115</span></span><br><span class="line">Unicode: t  <span class="number">116</span></span><br><span class="line">Unicode: a  <span class="number">97</span></span><br><span class="line">Unicode: r  <span class="number">114</span></span><br><span class="line">Unicode: t  <span class="number">116</span></span><br></pre></td></tr></table></figure><p>可以看到，这次汉字可以正常输出了。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>ASCII</strong> 字符串遍历直接使用下标。<br><strong>Unicode</strong> 字符串遍历用 <strong>for range</strong>。</p><h3 id="Go语言字符串截取（获取字符串的某一段字符）"><a href="#Go语言字符串截取（获取字符串的某一段字符）" class="headerlink" title="Go语言字符串截取（获取字符串的某一段字符）"></a>Go语言字符串截取（获取字符串的某一段字符）</h3><p>获取字符串的某一段字符是开发中常见的操作，我们一般将字符串中的某一段字符称做子串（substring）。</p><p>下面例子中使用 strings.Index() 函数在字符串中搜索另外一个子串，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tracer := <span class="string">"死神来了, 死神bye bye"</span></span><br><span class="line">comma := strings.Index(tracer, <span class="string">", "</span>)</span><br><span class="line">pos := strings.Index(tracer[comma:], <span class="string">"死神"</span>)</span><br><span class="line">fmt.Println(comma, pos, tracer[comma+pos:])</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="number">3</span> 死神bye bye</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><p>1) 第 2 行尝试在 tracer 的字符串中搜索中文的逗号，返回的位置存在 comma 变量中，类型是 int，表示从 tracer 字符串开始的 ASCII 码位置。</p><p>strings.Index() 函数并没有像其他语言一样，提供一个从某偏移开始搜索的功能。不过我们可以对字符串进行切片操作来实现这个逻辑。</p><p>2) 第4行中，tracer[comma:] 从 tracer 的 comma 位置开始到 tracer 字符串的结尾构造一个子字符串，返回给 string.Index() 进行再索引。得到的 pos 是相对于 tracer[comma:] 的结果。</p><p>comma 逗号的位置是 12，而 pos 是相对位置，值为 3。我们为了获得第二个“死神”的位置，也就是逗号后面的字符串，就必须让 comma 加上 pos 的相对偏移，计算出 15 的偏移，然后再通过切片 tracer[comma+pos:] 计算出最终的子串，获得最终的结果：“死神bye bye”。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>字符串索引比较常用的有如下几种方法：<br>strings.Index：正向搜索子字符串。<br>strings.LastIndex：反向搜索子字符串。<br>搜索的起始位置可以通过切片偏移制作。</p><h3 id="Go语言修改字符串"><a href="#Go语言修改字符串" class="headerlink" title="Go语言修改字符串"></a>Go语言修改字符串</h3><p>Go 语言的字符串无法直接修改每一个字符元素，只能通过重新构造新的字符串并赋值给原来的字符串变量实现。请参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angel := <span class="string">"Heros never die"</span></span><br><span class="line">angleBytes := []<span class="keyword">byte</span>(angel)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    angleBytes[i] = <span class="string">' '</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(angleBytes))</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heros       die</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>在第 2 行中，将字符串转为字符串数组。<br>第 3～5 行利用循环，将 <strong>never</strong> 单词替换为空格。<br>最后打印结果。</p><p>感觉我们通过代码达成了修改字符串的过程，但真实的情况是：<strong>Go</strong> 语言中的字符串和其他高级语言（Java、C#）一样，默认是不可变的（<strong>immutable</strong>）。</p><p>字符串不可变有很多好处，如天生线程安全，大家使用的都是只读对象，无须加锁；再者，方便内存共享，而不必使用写时复制（<strong>Copy On Writ</strong>e）等技术；字符串 <strong>hash</strong> 值也只需要制作一份。</p><p>所以说，代码中实际修改的是 <strong>[]byte , []byte</strong> 在 <strong>Go</strong> 语言中是可变的，本身就是一个切片。</p><p>在完成了对 <strong>[]byte</strong> 操作后，在第 6 行，使用 <strong>string()</strong> 将 <strong>[]byte</strong> 转为字符串时，重新创造了一个新的字符串。<br>总结<br>Go 语言的字符串是不可变的。<br>修改字符串时，可以将字符串转换为 <strong>[]byte</strong> 进行修改。<br><strong>[]byte</strong> 和 <strong>string</strong> 可以通过强制类型转换互转。</p><h3 id="Go语言字符串拼接（连接）"><a href="#Go语言字符串拼接（连接）" class="headerlink" title="Go语言字符串拼接（连接）"></a>Go语言字符串拼接（连接）</h3><p>连接字符串这么简单，还需要学吗？确实，Go 语言和大多数其他语言一样，使用+对字符串进行连接操作，非常直观。</p><p>但问题来了，好的事物并非完美，简单的东西未必高效。除了加号连接字符串，Go 语言中也有类似于 <strong>StringBuilder</strong> 的机制来进行高效的字符串连接，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hammer := <span class="string">"吃我一锤"</span></span><br><span class="line">sickle := <span class="string">"死吧"</span></span><br><span class="line"><span class="comment">// 声明字节缓冲</span></span><br><span class="line"><span class="keyword">var</span> stringBuilder bytes.Buffer</span><br><span class="line"><span class="comment">// 把字符串写入缓冲</span></span><br><span class="line">stringBuilder.WriteString(hammer)</span><br><span class="line">stringBuilder.WriteString(sickle)</span><br><span class="line"><span class="comment">// 将缓冲以字符串形式输出</span></span><br><span class="line">fmt.Println(stringBuilder.String())</span><br></pre></td></tr></table></figure><p><strong>bytes.Buffer</strong> 是可以缓冲并可以往里面写入各种字节数组的。字符串也是一种字节数组，使用 <strong>WriteString()</strong> 方法进行写入。</p><p>将需要连接的字符串，通过调用 <strong>WriteString()</strong> 方法，写入 <strong>stringBuilder</strong> 中，然后再通过 <strong>stringBuilder.String()</strong> 方法将缓冲转换为字符串。</p><h3 id="Go语言fmt-Sprintf（格式化输出）"><a href="#Go语言fmt-Sprintf（格式化输出）" class="headerlink" title="Go语言fmt.Sprintf（格式化输出）"></a>Go语言fmt.Sprintf（格式化输出）</h3><p>格式化在逻辑中非常常用。使用格式化函数，要注意写法：<br><strong>fmt.Sprintf</strong>(格式化样式, 参数列表…)</p><p>格式化样式：字符串形式，格式化动词以%开头。<br>参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。</p><p>在 Go 语言中，格式化的命名延续C语言风格：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="number">8</span></span><br><span class="line"><span class="comment">// 两参数格式化</span></span><br><span class="line">title := fmt.Sprintf(<span class="string">"已采集%d个药草, 还需要%d个完成任务"</span>, progress, target)</span><br><span class="line">fmt.Println(title)</span><br><span class="line">pi := <span class="number">3.14159</span></span><br><span class="line"><span class="comment">// 按数值本身的格式输出</span></span><br><span class="line">variant := fmt.Sprintf(<span class="string">"%v %v %v"</span>, <span class="string">"月球基地"</span>, pi, <span class="literal">true</span>)</span><br><span class="line">fmt.Println(variant)</span><br><span class="line"><span class="comment">// 匿名结构体声明, 并赋予初值</span></span><br><span class="line">profile := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    HP   <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    Name: <span class="string">"rat"</span>,</span><br><span class="line">    HP:   <span class="number">150</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"使用'%%+v' %+v\n"</span>, profile)</span><br><span class="line">fmt.Printf(<span class="string">"使用'%%#v' %#v\n"</span>, profile)</span><br><span class="line">fmt.Printf(<span class="string">"使用'%%T' %T\n"</span>, profile)</span><br></pre></td></tr></table></figure><p>代码输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已采集<span class="number">2</span>个药草, 还需要<span class="number">8</span>个完成任务</span><br><span class="line"><span class="string">"月球基地"</span> <span class="number">3.14159</span> <span class="literal">true</span></span><br><span class="line">使用<span class="string">'%+v'</span> &amp;&#123;Name:rat HP:<span class="number">150</span>&#125;</span><br><span class="line">使用<span class="string">'%#v'</span> &amp;<span class="keyword">struct</span> &#123; Name <span class="keyword">string</span>; HP <span class="keyword">int</span> &#125;&#123;Name:<span class="string">"rat"</span>, HP:<span class="number">150</span>&#125;</span><br><span class="line">使用<span class="string">'%T'</span> *<span class="keyword">struct</span> &#123; Name <span class="keyword">string</span>; HP <span class="keyword">int</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言中, 使用%d代表整型参数<br>下表中标出了常用的一些格式化样式中的动词及功能。</p></blockquote><p><strong>表：字符串格式化时常用动词及功能</strong><br>|动 词|功  能|<br>|:—:|:—:|:—:|<br>%v    |按值的本来值输出|<br>%+v    |在 %v 基础上，对结构体字段名和值进行展开|<br>%#v    |输出 Go 语言语法格式的值|<br>%T    |输出 Go 语言语法格式的类型和值|<br>%%    |输出 % 本体|<br>%b    |整型以二进制方式显示|<br>%o    |整型以八进制方式显示|<br>%d    |整型以十进制方式显示|<br>%x    |整型以十六进制方式显示|<br>%X    |整型以十六进制、字母大写方式显示|<br>%U    |Unicode 字符|<br>%f    |浮点数|<br>%p    |指针，十六进制方式显示|</p><p><a href="https://blog.csdn.net/zgh0711/article/details/78843361" rel="external nofollow noopener noreferrer" target="_blank">fmt.Println 与 fmt.Printf 的区别，以及 fmt.Printf 的详细用法</a></p><h3 id="Go语言Base64编码——电子邮件的基础编码格式"><a href="#Go语言Base64编码——电子邮件的基础编码格式" class="headerlink" title="Go语言Base64编码——电子邮件的基础编码格式"></a>Go语言Base64编码——电子邮件的基础编码格式</h3><p><strong>Base64</strong> 编码是常见的对 8 比特字节码的编码方式之一。<strong>Base64</strong> 可以使用 64 个可打印字符来表示二进制数据，电子邮件就是使用这种编码。</p><p>Go 语言的标准库自带了 <strong>Base64</strong> 编码算法，通过几行代码就可以对数据进行编码，示例代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要处理的字符串</span></span><br><span class="line">    message := <span class="string">"Away from keyboard. https://golang.org/"</span></span><br><span class="line">    <span class="comment">// 编码消息</span></span><br><span class="line">    encodedMessage := base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span> (message))</span><br><span class="line">    <span class="comment">// 输出编码完成的消息</span></span><br><span class="line">    fmt.Println(encodedMessage)</span><br><span class="line">    <span class="comment">// 解码消息</span></span><br><span class="line">    data, err := base64.StdEncoding.DecodeString(encodedMessage)</span><br><span class="line">    <span class="comment">// 出错处理</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 打印解码完成的数据</span></span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 8 行为需要编码的消息，消息可以是字符串，也可以是二进制数据。<br>第 10 行，<strong>base64</strong> 包有多种编码方法，这里使用 <strong>base64.StdEnoding</strong> 的标准编码方法进行编码。传入的字符串需要转换为字节数组才能供这个函数使用。<br>第 12 行，编码完成后一定会输出字符串类型，打印输出。<br>第 14 行，解码时可能会发生错误，使用 <strong>err</strong> 变量接收错误。<br>第 17 行，出错时，打印错误。<br>第 20 行，正确时，将返回的字节数组（<strong>[]byte</strong>）转换为字符串。</p><h2 id="Go语言字符类型（byte和rune）"><a href="#Go语言字符类型（byte和rune）" class="headerlink" title="Go语言字符类型（byte和rune）"></a>Go语言字符类型（byte和rune）</h2><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p><p>Go 语言的字符有以下两种：<br>一种是 <strong>uint8</strong> 类型，或者叫 <strong>byte</strong> 型，代表了 <strong>ASCII</strong> 码的一个字符。<br>另一种是 <strong>rune</strong> 类型，代表一个 <strong>UTF-8</strong> 字符。当需要处理中文、日文或者其他复合字符时，则需要用到 <strong>rune</strong> <strong>类型。rune</strong> 类型实际是一个 <strong>int32</strong>。</p><p>使用 <strong>fmt.Printf</strong> 中的%T动词可以输出变量的实际类型，使用这个方法可以查看 <strong>byte</strong> 和 <strong>rune</strong> 的本来类型，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, a, a)</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">rune</span> = <span class="string">'你'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, b, b)</span><br></pre></td></tr></table></figure><p>例子输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">97</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="number">20320</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>可以发现，<strong>byte</strong> 类型的 a 变量，实际类型是 <strong>uint8</strong>，其值为 ‘a’，对应的 <strong>ASCII</strong> 编码为 97。</p><p><strong>rune</strong> 类型的 b 变量的实际类型是 <strong>int32</strong>，对应的 <strong>Unicode</strong> 码就是 <strong>20320</strong>。</p><p>Go 使用了特殊的 <strong>rune</strong> 类型来处理 <strong>Unicode</strong>，让基于 <strong>Unicode</strong> 的文本处理更为方便，也可以使用 <strong>byte</strong> 型进行默认字符串处理，性能和扩展性都有照顾。</p><h3 id="UTF-8-和-Unicode-有何区别？"><a href="#UTF-8-和-Unicode-有何区别？" class="headerlink" title="UTF-8 和 Unicode 有何区别？"></a>UTF-8 和 Unicode 有何区别？</h3><p><strong>Unicode</strong> 是字符集，<strong>ASCII</strong> 也是一种字符集。</p><p>字符集为每个字符分配一个唯一的 ID，我们使用到的所有字符在 <strong>Unicode</strong> 字符集中都有唯一的一个 ID 对应，例如上面例子中的 a 在 <strong>Unicode</strong> 与 <strong>ASCII</strong> 中的编码都是 97。“你”在 <strong>Unicode</strong> 中的编码为 <strong>20320</strong>，但是在不同国家的字符集中，“你”的 ID 会不同。而无论任何情况下，<strong>Unicode</strong> 中的字符的 ID 都是不会变化的。</p><p><strong>UTF-8</strong> 是编码规则，将 <strong>Unicode</strong> 中字符的 ID 以某种方式进行编码。<strong>UTF-8</strong> 的是一种变长编码规则，从 1 到 4 个字节不等。编码规则如下：</p><ul><li>0xxxxxx 表示文字符号 0～127，兼容 <strong>ASCII</strong> 字符集。</li><li>从 128 到 0x10ffff 表示其他字符。</li></ul><p>根据这个规则，拉丁文语系的字符编码一般情况下，每个字符依然占用一个字节，而中文每个字符占用 3 个字节。</p><p>广义的 <strong>Unicode</strong> 指一个标准，定义字符集及编码规则，即 <strong>Unicode</strong> 字符集和 <strong>UTF-8、UTF-16</strong> 编码等。</p><h3 id="Go语言数据类型转换"><a href="#Go语言数据类型转换" class="headerlink" title="Go语言数据类型转换"></a>Go语言数据类型转换</h3><p>Go 语言使用类型前置加括号的方式进行类型转换，一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T 代表要转换的类型。表达式包括变量、复杂算子和函数返回值等。</p><p>类型转换时，需要考虑两种类型的关系和范围，是否会发生数值截断等，参见下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 输出各数值范围</span></span><br><span class="line">        fmt.Println(<span class="string">"int8 range:"</span>, math.MinInt8, math.MaxInt8)</span><br><span class="line">        fmt.Println(<span class="string">"int16 range:"</span>, math.MinInt16, math.MaxInt16)</span><br><span class="line">        fmt.Println(<span class="string">"int32 range:"</span>, math.MinInt32, math.MaxInt32)</span><br><span class="line">        fmt.Println(<span class="string">"int64 range:"</span>, math.MinInt64, math.MaxInt64)</span><br><span class="line">        <span class="comment">// 初始化一个32位整型值</span></span><br><span class="line">        <span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">1047483647</span></span><br><span class="line">        <span class="comment">// 输出变量的十六进制形式和十进制值</span></span><br><span class="line">        fmt.Printf(<span class="string">"int32: 0x%x %d\n"</span>, a, a)</span><br><span class="line">        <span class="comment">// 将a变量数值转换为十六进制, 发生数值截断</span></span><br><span class="line">        b := <span class="keyword">int16</span>(a)</span><br><span class="line">        <span class="comment">// 输出变量的十六进制形式和十进制值</span></span><br><span class="line">        fmt.Printf(<span class="string">"int16: 0x%x %d\n"</span>, b, b)</span><br><span class="line">        <span class="comment">// 将常量保存为float32类型</span></span><br><span class="line">        <span class="keyword">var</span> c <span class="keyword">float32</span> = math.Pi</span><br><span class="line">        <span class="comment">// 转换为int类型, 浮点发生精度丢失</span></span><br><span class="line">        fmt.Println(<span class="keyword">int</span>(c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 11～14 行，输出常见整型类型的数值范围。<br>第 17 行，声明 int32 类型的 a 变量并初始化。<br>第 19 行，使用 fmt.Printf 的%x动词将数值以十六进制格式输出。这一行输出 a 在转换前的 32 位的值。<br>第 22 行，将 a 的值转换为 int16 类型，也就是从 32 位有符号整型转换为 16 位有符号整型。由于 16 位变量没有 32 位变量的数值范围大，因此数值会进行截断。<br>第 24 行，输出转换后的 a 变量值，也就是 b 的值。同样以十六进制和十进制两种方式进行打印。<br>第 27 行，math.Pi 是 math 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导。这里 math.Pi 被存到 c 中，类型为 float32。<br>第 29 行，将 float32 转换为 int 类型并输出。</p><p>代码输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int8</span> <span class="keyword">range</span>: <span class="number">-128</span> <span class="number">127</span></span><br><span class="line"><span class="keyword">int16</span> <span class="keyword">range</span>: <span class="number">-32768</span> <span class="number">32767</span></span><br><span class="line"><span class="keyword">int32</span> <span class="keyword">range</span>: <span class="number">-2147483648</span> <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">int64</span> <span class="keyword">range</span>: <span class="number">-9223372036854775808</span> <span class="number">9223372036854775807</span></span><br><span class="line"><span class="keyword">int32</span>: <span class="number">0x3e6f54ff</span> <span class="number">1047483647</span></span><br><span class="line"><span class="keyword">int16</span>: <span class="number">0x54ff</span> <span class="number">21759</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>根据输出结果，16 位有符号整型的范围是 -32768～32767，而 a 变量的 1047483647 不在这个范围内。1047483647 对应的十六进制为 0x3e6f54ff，转为 16 位变量后，长度缩短一半，也就是在十六进制上砍掉一半，变成 0x54ff，对应的十进制值为 21759。</p><p>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</p><p>整型截断在类型转换中发生的较为隐性，有些即为难追查的问题，很小一部分是由整型截断造成。</p><h3 id="Go语言指针详解，看这一篇文章就够了"><a href="#Go语言指针详解，看这一篇文章就够了" class="headerlink" title="Go语言指针详解，看这一篇文章就够了"></a>Go语言指针详解，看这一篇文章就够了</h3><p>指针（pointer）概念在 Go 语言中被拆分为两个核心概念：<br>类型指针，允许对这个指针类型的数据进行修改。传递数据使用指针，而无须拷贝数据。类型指针不能进行偏移和运算。<br>切片，由指向起始元素的原始指针、元素数量和容量组成。</p><p>受益于这样的约束和拆分，Go 语言的指针类型变量拥有指针的高效访问，但又不会发生指针偏移，从而避免非法修改关键性数据问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，更为安全。切片发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。<br>C/C++中的指针<br>说到 C/C++ 中的指针，会让许多人“谈虎色变”，尤其对指针偏移、运算、转换都非常恐惧。</p><p>其实，指针是使 C/C++ 语言有极高性能的根本，在操作大块数据和做偏移时方便又便捷。因此，操作系统依然使用C语言及指针特性进行编写。</p><p>C/C++ 中指针饱受诟病的根本原因是指针运算和内存释放。</p><p>C/C++ 语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统核心区域。我们的计算机操作系统经常需要更新、修复漏洞的本质，是为解决指针越界访问所导致的“缓冲区溢出”。</p><p>要明白指针，需要知道几个概念：指针地址、指针类型和指针取值，下面将展开细说。</p><h4 id="认识指针地址和指针类型"><a href="#认识指针地址和指针类型" class="headerlink" title="认识指针地址和指针类型"></a>认识指针地址和指针类型</h4><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go 语言中使用&amp;作符放在变量前面对变量进行“取地址”操作。</p><p>格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中 v 代表被取地址的变量，被取地址的 v 使用 ptr 变量进行接收，ptr 的类型就为<em> T，称做 T 的指针类型。</em> 代表指针。</p><p>指针实际用法，通过下面的例子了解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cat <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"banana"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p %p"</span>, &amp;cat, &amp;str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc042052088</span> <span class="number">0xc0420461b0</span></span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 6 行，声明整型 cat 变量。<br>第 7 行，声明字符串 str 变量。<br>第 8 行，使用 fmt.Printf 的动词%p输出 cat 和 str 变量取地址后的指针值，指针值带有0x的十六进制前缀。</p><p>输出值在每次运行是不同的，代表 cat 和 str 两个变量在运行时的地址。</p><p>在 32 位平台上，将是 32 位地址；64 位平台上是 64 位地址。</p><p>提示：变量、指针和地址三者的关系是：每个变量都拥有地址，指针的值就是地址。</p><h4 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h4><p>在对普通变量使用&amp;操作符取地址获得这个变量的指针后，可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 准备一个字符串类型</span></span><br><span class="line">    <span class="keyword">var</span> house = <span class="string">"Malibu Point 10880, 90265"</span></span><br><span class="line">    <span class="comment">// 对字符串取地址, ptr类型为*string</span></span><br><span class="line">    ptr := &amp;house</span><br><span class="line">    <span class="comment">// 打印ptr的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"ptr type: %T\n"</span>, ptr)</span><br><span class="line">    <span class="comment">// 打印ptr的指针地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"address: %p\n"</span>, ptr)</span><br><span class="line">    <span class="comment">// 对指针进行取值操作</span></span><br><span class="line">    value := *ptr</span><br><span class="line">    <span class="comment">// 取值后的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"value type: %T\n"</span>, value)</span><br><span class="line">    <span class="comment">// 指针取值后就是指向变量的值</span></span><br><span class="line">    fmt.Printf(<span class="string">"value: %s\n"</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr <span class="keyword">type</span>: *<span class="keyword">string</span></span><br><span class="line">address: <span class="number">0xc0420401b0</span></span><br><span class="line">value <span class="keyword">type</span>: <span class="keyword">string</span></span><br><span class="line">value: Malibu Point <span class="number">10880</span>, <span class="number">90265</span></span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 7 行，准备一个字符串并赋值。<br>第 9 行，对字符串取地址，将指针保存到 ptr 中。<br>第 11 行，打印 ptr 变量的类型，类型为 *string。<br>第 13 行，打印 ptr 的指针地址，每次运行都会发生变化。<br>第 15 行，对 ptr 指针变量进行取值操作，value 变量类型为 string。<br>第 17 行，打印取值后 value 的类型。<br>第 19 行，打印 value 的值。</p><p>取地址操作符&amp;和取值操作符<em> 是一对互补操作符，&amp;取出地址，</em> 根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：<br>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。<br>指针变量的值是指针地址。<br>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。<br>使用指针修改值<br>通过指针不仅可以取值，也可以修改值。</p><p>前面已经使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">    t := *a</span><br><span class="line">    <span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">    *a = *b</span><br><span class="line">    <span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">    *b = t</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="comment">// 交换变量值</span></span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line">    <span class="comment">// 输出变量值</span></span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 4 行，定义一个交换函数，参数为 a、b，类型都为 <em> int，都是指针类型。<br>第 6 行，将 a 指针取值，把值（int类型）赋给 t 变量，t 此时也是 int 类型。<br>第 8 行，取 b 指针值，赋给 a 变量指向的变量。注意，此时 </em> a的意思不是取 a 指针的值，而是“a指向的变量”。<br>第 10 行，将 t 的值赋给 b 指向的变量。<br>第 14 行，准备 x、y 两个变量，赋值 1 和 2，类型为 int。<br>第 16 行，取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。<br>第 18 行，交换完毕时，输出 x 和 y 的值。</p><p>‘<em> 操作符作为右值时，意义是取指针的值；作为左值时，也就是放在赋值操作符的左边时，表示 a 指向的变量。其实归纳起来，</em> 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值；当操作在左值时，就是将值设置给指向的变量。</p><p>如果在 swap() 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p><h4 id="示例：使用指针变量获取命令行的输入信息"><a href="#示例：使用指针变量获取命令行的输入信息" class="headerlink" title="示例：使用指针变量获取命令行的输入信息"></a>示例：使用指针变量获取命令行的输入信息</h4><p>Go 语言的 flag 包中，定义的指令以指针类型返回。通过学习 flag 包，可以深入了解指针变量在设计上的方便之处。</p><p>下面的代码通过提前定义一些命令行指令和对应变量，在运行时，输入对应参数的命令行参数后，经过 flag 包的解析后即可通过定义的变量获取命令行的数据。</p><p>获取命令行输入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 导入系统包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义命令行参数</span></span><br><span class="line"><span class="keyword">var</span> mode = flag.String(<span class="string">"mode"</span>, <span class="string">""</span>, <span class="string">"process mode"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解析命令行参数</span></span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="comment">// 输出命令行参数</span></span><br><span class="line">    fmt.Println(*mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这段代码命名为main.go，然后使用如下命令行运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run flagparse.<span class="keyword">go</span> --mode=fast</span><br></pre></td></tr></table></figure><p>命令行输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fast</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 8 行，通过 flag.String，定义一个 mode 变量，这个变量的类型是 * string。后面 3 个参数分别如下：<br>参数名称：在给应用输入参数时，使用这个名称。<br>参数值的默认值：与 flag 所使用的函数创建变量类型对应，String 对应字符串、Int 对应整型、Bool 对应布尔型等。<br>参数说明：使用 -help 时，会出现在说明中。<br>第 11 行，解析命令行参数，并将结果写入创建的指令变量中，这个例子中就是 mode 变量。<br>第 13 行，打印 mode 指针所指向的变量。</p><p>由于之前使用 flag.String 已经注册了一个 mode 的命令行参数，flag 底层知道怎么解析命令行，并且将值赋给 mode*string 指针。在 Parse 调用完毕后，无须从 flag 获取值，而是通过自己注册的 mode 这个指针，获取到最终的值。代码运行流程如下图所示。</p><p>图：命令行参数与变量的关系<br><img src="..http://image.tjl-myblog.cn:4455/.deploy_git/images/blog_article/GO学习笔记/1.jpg" alt="还没有图片哦"></p><h4 id="创建指针的另一种方法——new-函数"><a href="#创建指针的另一种方法——new-函数" class="headerlink" title="创建指针的另一种方法——new() 函数"></a>创建指针的另一种方法——new() 函数</h4><p>Go 语言还提供了另外一种方法来创建指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(类型)</span><br></pre></td></tr></table></figure><p>一般这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">"ninja"</span></span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></table></figure><p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。</p><h3 id="Go语言变量生命期，Go语言变量逃逸分析"><a href="#Go语言变量生命期，Go语言变量逃逸分析" class="headerlink" title="Go语言变量生命期，Go语言变量逃逸分析"></a>Go语言变量生命期，Go语言变量逃逸分析</h3><p>讨论变量生命期之前，先来了解下计算机组成里两个非常重要的概念：堆和栈。</p><p><strong>什么是栈</strong></p><p>栈（Stack）是一种拥有特殊规则的线性表数据结构。<br>栈只允许往线性表的一端放入数据，之后在这一端取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序，如下图所示。</p><p><img src="..http://image.tjl-myblog.cn:4455/.deploy_git/images/blog_article/GO学习笔记/2.jpg" alt="还没有图片哦"></p><p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p><p>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除栈顶外的成员）进行任何查看和修改操作。</p><p>栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出。</p><p><strong>变量和栈有什么关系</strong></p><p>栈可用于内存分配，栈的分配和回收速度非常快。下面代码展示栈在内存分配上的作用，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    c = a * b</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    x = c * <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 1 行，传入 a、b 两个整型参数。<br>第 2 行，声明 c 整型变量，运行时，c 会分配一段内存用以存储 c 的数值。<br>第 3 行，将 a 和 b 相乘后赋予 c。<br>第 4 行，声明 x 整型变量，x 也会被分配一段内存。<br>第 5 行，让 c 乘以 10 后存储到 x 变量中。<br>第 6 行，返回 x 的值。</p><p>上面的代码在没有任何优化情况下，会进行 c 和 x 变量的分配过程。Go 语言默认情况下会将 c 和 x 分配在栈上，这两个变量在 calc() 函数退出时就不再使用，函数结束时，保存 c 和 x 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p><p><strong>什么是堆</strong></p><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小。分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往空间里摆放家具会存在虽然有足够的空间，但各空间分布在不同的区域，无法有一段连续的空间来摆放家具的问题。此时，内存分配器就需要对这些空间进行调整优化，如下图所示。</p><p><img src="..http://image.tjl-myblog.cn:4455/.deploy_git/images/blog_article/GO学习笔记/3.jpg" alt="还没有图片哦"></p><p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。<br>变量逃逸（Escape Analysis）——自动决定变量分配方式，提高运行效率<br>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 C/C++ 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈；全局变量、结构体成员使用堆分配等。程序员不得不花费很多年的时间在不同的项目中学习、记忆这些概念并加以实践和使用。</p><p>Go 语言将这个过程整合到编译器中，命名为“变量逃逸分析”。这个技术由编译器分析代码的特征和代码生命期，决定应该如何堆还是栈进行内存分配，即使程序员使用 Go 语言完成了整个工程后也不会感受到这个过程。</p><p><strong>逃逸分析</strong></p><p>使用下面的代码来展现 Go 语言如何通过命令行分析变量逃逸，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 本函数测试入口参数和返回值情况</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dummy</span><span class="params">(b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个c赋值进入参数并返回</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    c = b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空函数, 什么也不做</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">void</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明a变量并打印</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 调用void()函数</span></span><br><span class="line">    void()</span><br><span class="line">    <span class="comment">// 打印a变量的值和dummy()函数返回</span></span><br><span class="line">    fmt.Println(a, dummy(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 4 行，dummy() 函数拥有一个参数，返回一个整型值，测试函数参数和返回值分析情况。<br>第 6 行，声明 c 变量，这里演示函数临时变量通过函数返回值返回后的情况。<br>第 11 行，这是一个空函数，测试没有任何参数函数的分析情况。<br>第 15 行，在 main() 中声明 a 变量，测试 main() 中变量的分析情况。<br>第 17 行，调用 void() 函数，没有返回值，测试 void() 调用后的分析情况。<br>第 19 行，打印 a 和 dummy(0) 的返回值，测试函数返回值没有变量接收时的分析情况。</p><p>接着使用如下命令行运行上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run -gcflags <span class="string">"-m -l"</span> main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>使用 go run 运行程序时，-gcflags 参数是编译参数。其中 -m 表示进行内存分配分析，-l 表示避免程序内联，也就是避免进行程序优化。</p><p>运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">29</span>:<span class="number">13</span>: a escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">29</span>:<span class="number">22</span>: dummy(<span class="number">0</span>) escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">29</span>:<span class="number">13</span>: main ... argument does not escape</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>程序运行结果分析如下：<br>输出第 2 行告知“main 的第 29 行的变量 a 逃逸到堆”。<br>第 3 行告知“dummy(0)调用逃逸到堆”。由于 dummy() 函数会返回一个整型值，这个值被 fmt.Println 使用后还是会在其声明后继续在 main() 函数中存在。<br>第 4 行，这句提示是默认的，可以忽略。</p><p>上面例子中变量 c 是整型，其值通过 dummy() 的返回值“逃出”了 dummy() 函数。c 变量值被复制并作为 dummy() 函数返回值返回，即使 c 变量在 dummy() 函数中分配的内存被释放，也不会影响 main() 中使用 dummy() 返回的值。c 变量使用栈分配不会影响结果。</p><p><strong>取地址发生逃逸</strong></p><p>下面的例子使用结构体做数据，了解在堆上分配的情况，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 声明空结构体测试结构体逃逸情况</span></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dummy</span><span class="params">()</span> *<span class="title">Data</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化c为Data类型</span></span><br><span class="line">    <span class="keyword">var</span> c Data</span><br><span class="line">    <span class="comment">//返回函数局部变量地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(dummy())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><p>第 4 行，声明一个空的结构体做结构体逃逸分析。<br>第 6 行，将 dummy() 函数的返回值修改为 *Data 指针类型。<br>第 8 行，将 c 变量声明为 Data 类型，此时 c 的结构体为值类型。<br>第 10 行，取函数局部变量 c 的地址并返回。Go 语言的特性允许这样做。<br>第 13 行，打印 dummy() 函数的返回值。</p><p>执行逃逸分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run -gcflags <span class="string">"-m -l"</span> main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">9</span>: &amp;c escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">12</span>:<span class="number">6</span>: moved to heap: c</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">19</span>: dummy() escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">13</span>: main ... argument does not escape</span><br><span class="line">&amp;&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意第 4 行出现了新的提示：将 c 移到堆中。这句话表示，Go 编译器已经确认如果将 c 变量分配在栈上是无法保证程序最终结果的。如果坚持这样做，dummy() 的返回值将是 Data 结构的一个不可预知的内存地址。这种情况一般是 C/C++ 语言中容易犯错的地方：引用了一个函数局部变量的地址。</p><p>Go 语言最终选择将 c 的 Data 结构分配在堆上。然后由垃圾回收器去回收 c 的内存。</p><p><strong>原则</strong></p><p>在使用 Go 语言进行编程时，Go 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆上的问题。编译器会自动帮助开发者完成这个纠结的选择。但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于 Go 语言，在 Java 等语言的编译器优化上也使用了类似的技术。</p><p>编译器觉得变量应该分配在堆和栈上的原则是：<br>变量是否被取地址。<br>变量是否发生逃逸。</p><p><strong>总结</strong><br>一个局部变量被取地址并返回出去的话就会被分配到堆上，如果只是返回局部变量那么还是会被分配到栈上</p><h3 id="Go语言常量和const关键字"><a href="#Go语言常量和const关键字" class="headerlink" title="Go语言常量和const关键字"></a>Go语言常量和const关键字</h3><p>相对于变量，常量是恒定不变的值，例如圆周率。</p><p>可以在编译时，对常量表达式进行计算求值，并在运行期使用该计算结果，计算结果无法被修改。</p><p>常量表示起来非常简单，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.141592</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.718281</span></span><br></pre></td></tr></table></figure><p>常量的声明和变量声明非常类似，只是把 <strong>var</strong> 换成了 <strong>const</strong>。</p><p>多个变量可以一起声明，类似的，常量也是可以多个一起声明的，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.141592</span></span><br><span class="line">    e = <span class="number">2.718281</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量因为在编译期确定，所以可以用于数组声明，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> arr [size]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h3 id="Go语言模拟枚举（const和iota模拟枚举）"><a href="#Go语言模拟枚举（const和iota模拟枚举）" class="headerlink" title="Go语言模拟枚举（const和iota模拟枚举）"></a>Go语言模拟枚举（const和iota模拟枚举）</h3><p>Go 语言中现阶段没有枚举，可以使用 const 常量配合 iota 模拟枚举，请看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weapon <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">     Arrow Weapon = <span class="literal">iota</span>    <span class="comment">// 开始生成枚举值, 默认为0</span></span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 输出所有枚举值</span></span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"><span class="comment">// 使用枚举类型并赋初值</span></span><br><span class="line"><span class="keyword">var</span> weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre></td></tr></table></figure><p>代码输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 1 行中将 int 定义为 Weapon 类型，就像枚举类型其实本质是一个 int 一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。</p><p>第3行中，将 Array 常量的类型标识为 Weapon，这样标识后，const 下方的常量可以是默认类型的，默认时，默认使用前面指定的类型作为常量类型。该行使用 iota 进行常量值自动生成。iota 起始值为 0，一般情况下也是建议枚举从 0 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。</p><p>一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加。这种模式有点类似于电子表格中的单元格自动填充。只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。</p><p>当然，iota 不仅只生成每次增加 1 的枚举值。我们还可以利用 iota 来做一些强大的枚举常量值生成器。下面的代码可以方便生成标志位常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FlagNone = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">    FlagRed</span><br><span class="line">    FlagGreen</span><br><span class="line">    FlagBlue</span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">"%d %d %d\n"</span>, FlagRed, FlagGreen, FlagBlue)</span><br><span class="line">fmt.Printf(<span class="string">"%b %b %b\n"</span>, FlagRed, FlagGreen, FlagBlue)</span><br></pre></td></tr></table></figure><p>代码输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>在代码中编写一些标志位时，我们往往手动编写常量值，如果常量值特别多时，很容易重复或者写错。因此，使用 ioto 自动生成较为方便。</p><p>代码说明如下：<br>第 2 行中 iota 使用了一个移位操作，每次将上一次的值左移一位，以做出每一位的常量值。<br>第 7 行，将 3 个枚举按照常量输出，分别输出 2、4、8，都是将 1 每次左移一位的结果。<br>第 8 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。</p><h4 id="将枚举值转换为字符串"><a href="#将枚举值转换为字符串" class="headerlink" title="将枚举值转换为字符串"></a>将枚举值转换为字符串</h4><p>枚举在 C# 语言中是一个独立的类型，可以通过枚举值获取值对应的字符串。例如，C# 中 Week 枚举值 Monday 为 1，那么可以通过 Week.Monday.ToString() 函数获得 Monday 字符串。</p><p>Go 语言中也可以实现这一功能，见下面的例子。<br>转换字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 声明芯片类型</span></span><br><span class="line"><span class="keyword">type</span> ChipType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    None ChipType = <span class="literal">iota</span></span><br><span class="line">    CPU    <span class="comment">// 中央处理器</span></span><br><span class="line">    GPU    <span class="comment">// 图形处理器</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ChipType)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> None:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"None"</span></span><br><span class="line">    <span class="keyword">case</span> CPU:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CPU"</span></span><br><span class="line">    <span class="keyword">case</span> GPU:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"GPU"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"N/A"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输出CPU的值并以整型格式显示</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s %d"</span>, CPU, CPU)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU <span class="number">1</span></span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 4 行，将 int 声明为 ChipType 芯片类型。<br>第 6 行，将 const 里定义的一句常量值设为 ChipType 类型，且从 0 开始，每行值加 1。<br>第 10 行，定义 ChipType 类型的方法 String()，返回字符串。<br>第 11~20 行，使用 switch 语句判断当前的 ChitType 类型的值，返回对应的字符串。<br>第 23 行，输出 CPU 的值并按整型格式输出。</p><p>使用 String() 方法的 ChipType 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，Go 语言会自动寻找 String() 方法并进行调用。</p><h3 id="Go语言type关键字（类型别名）"><a href="#Go语言type关键字（类型别名）" class="headerlink" title="Go语言type关键字（类型别名）"></a>Go语言type关键字（类型别名）</h3><p>注意：本节内容涉及 Go 语言新版本的功能。内容上会涉及后续章节讲解的类型定义及结构体嵌入等特性。另外，本节内容适用于对 Go 语言很熟悉且正在关注工程升级、代码重构等问题的读者阅读。</p><p>类型别名是 Go 1.9 版本添加的新功能。主要用于代码升级、迁移中类型的兼容性问题。在 C/C++ 语言中，代码重构升级可以使用宏快速定义新的一段代码。Go 语言中没有选择加入宏，而是将解决重构中最麻烦的类型名变更问题。</p><p>在 Go 1.9 版本之前的内建类型定义的代码是这样写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>而在 Go 1.9 版本之后变为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>这个修改就是配合类型别名而进行的修改。</p><h4 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h4><p>类型别名的写法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>类型别名规定：<strong>TypeAlias</strong> 只是 <strong>Type</strong> 的别名，本质上 <strong>TypeAlias</strong> 与 <strong>Type</strong> 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><p>类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 将NewInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 将int取一个别名叫IntAlias</span></span><br><span class="line"><span class="keyword">type</span> IntAlias = <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将a声明为NewInt类型</span></span><br><span class="line">    <span class="keyword">var</span> a NewInt</span><br><span class="line">    <span class="comment">// 查看a的类型名</span></span><br><span class="line">    fmt.Printf(<span class="string">"a type: %T\n"</span>, a)</span><br><span class="line">    <span class="comment">// 将a2声明为IntAlias类型</span></span><br><span class="line">    <span class="keyword">var</span> a2 IntAlias</span><br><span class="line">    <span class="comment">// 查看a2的类型名</span></span><br><span class="line">    fmt.Printf(<span class="string">"a2 type: %T\n"</span>, a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">type</span>: main.NewInt</span><br><span class="line">a2 <span class="keyword">type</span>: <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 6 行，将 NewInt 定义为 int 类型，这是常见定义类型的方法，通过 type 关键字的定义，NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。<br>第 8 行，将 IntAlias 设置为 int 的一个别名，使用 IntAlias 与 int 等效。<br>第 11 行，将 a 声明为 NewInt 类型，此时若打印，则 a 的值为 0。<br>第 13 行，使用%T格式化参数，显示 a 变量本身的类型。<br>第 15 行，将 a2 声明为 IntAlias 类型，此时打印 a2 的值为 0。<br>第 17 行，显示 a2 变量的类型。</p><p>结果显示a的类型是 main.NewInt，表示 main 包下定义的 NewInt 类型。a2 类型是 int。IntAlias 类型只会在代码中存在，编译完成时，不会有 IntAlias 类型。</p><h4 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h4><p>能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法？参见下面的代码演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义time.Duration的别名为MyDuration</span></span><br><span class="line"><span class="keyword">type</span> MyDuration = time.Duration</span><br><span class="line"><span class="comment">// 为MyDuration添加一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyDuration)</span> <span class="title">EasySet</span><span class="params">(a <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 6 行，使用类型别名为 time.Duration 设定一个别名叫 MyDuration。<br>第 8 行，为这个别名添加一个方法。</p><p>编译上面代码报错，信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot define <span class="built_in">new</span> methods on non-local <span class="keyword">type</span> time.Duration</span><br></pre></td></tr></table></figure><p>编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法。非本地方法指的就是使用 time.Duration 的代码所在的包，也就是 main 包。因为 time.Duration 是在 time 包中定义的，在 main 包中使用。time.Duration 包与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。</p><p>解决这个问题有下面两种方法：<br>将第 6 行修改为 type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型。<br>将 MyDuration 的别名定义放在 time 包中。</p><h4 id="在结构体成员嵌入时使用别名"><a href="#在结构体成员嵌入时使用别名" class="headerlink" title="在结构体成员嵌入时使用别名"></a>在结构体成员嵌入时使用别名</h4><p>当类型别名作为结构体嵌入的成员时会发生什么情况？请参考下面的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义商标结构</span></span><br><span class="line"><span class="keyword">type</span> Brand <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为商标结构添加Show()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Brand)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为Brand定义一个别名FakeBrand</span></span><br><span class="line"><span class="keyword">type</span> FakeBrand = Brand</span><br><span class="line"><span class="comment">// 定义车辆结构</span></span><br><span class="line"><span class="keyword">type</span> Vehicle <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 嵌入两个结构</span></span><br><span class="line">    FakeBrand</span><br><span class="line">    Brand</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明变量a为车辆类型</span></span><br><span class="line">    <span class="keyword">var</span> a Vehicle</span><br><span class="line">    <span class="comment">// 指定调用FakeBrand的Show</span></span><br><span class="line">    a.FakeBrand.Show()</span><br><span class="line">    <span class="comment">// 取a的类型反射对象</span></span><br><span class="line">    ta := reflect.TypeOf(a)</span><br><span class="line">    <span class="comment">// 遍历a的所有成员</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ta.NumField(); i++ &#123;</span><br><span class="line">        <span class="comment">// a的成员信息</span></span><br><span class="line">        f := ta.Field(i)</span><br><span class="line">        <span class="comment">// 打印成员的字段名和类型</span></span><br><span class="line">        fmt.Printf(<span class="string">"FieldName: %v, FieldType: %v\n"</span>, f.Name, f.Type.Name())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FieldName: FakeBrand, FieldType: Brand</span><br><span class="line">FieldName: Brand, FieldType: Brand</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 7 行，定义商标结构。<br>第 13 行，为商标结构添加 Show() 方法。<br>第 10 行，为 Brand 定义一个别名 FakeBrand。<br>第 13~17 行，定义车辆结构 Vehicle，嵌入 FakeBrand 和 Brand 结构。<br>第 22 行，将 Vechicle 实例化为 a。<br>第 24 行，显式调用 Vehicle 中 FakeBrand 的 Show() 方法。<br>第 26 行，使用反射取变量 a 的反射类型对象，以查看其成员类型。<br>第 28～32 行，遍历 a 的结构体成员。<br>第 33 行，打印 Vehicle 类型所有成员的信息。</p><p>这个例子中，FakeBrand 是 Brand 的一个别名。在 Vehicle 中嵌入 FakeBrand 和 Brand 并不意味着嵌入两个 Brand。FakeBrand 的类型会以名字的方式保留在 Vehicle 的成员中。</p><p>如果尝试将第 24 行改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.Show()</span><br></pre></td></tr></table></figure><p>编译器将发生报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambiguous selector a.Show</span><br></pre></td></tr></table></figure><p>在调用 Show() 方法时，因为两个类型都有 Show() 方法，会发生歧义，证明 FakeBrand 的本质确实是 Brand 类型。</p><p>附加链接：<br><a href="https://www.cnblogs.com/pangzhi/p/8228181.html" rel="external nofollow noopener noreferrer" target="_blank">Go结构体与方法</a><br><a href="https://www.jianshu.com/p/59304a59ce5d" rel="external nofollow noopener noreferrer" target="_blank">Go语言type关键字</a><br><a href="https://www.cnblogs.com/craneboos/p/8615476.html" rel="external nofollow noopener noreferrer" target="_blank">Go语言中type的几种使用</a></p><h2 id="Go语言容器（container）"><a href="#Go语言容器（container）" class="headerlink" title="Go语言容器（container）"></a>Go语言容器（container）</h2><p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p><p>在很多语言里，容器是以标准库的方式提供，你可以随时查看这些标准库的代码，了解如何创建，删除，维护内存。</p><p>本章将以实用为目的，详细介绍数组、切片、映射，以及列表的增加、删除、修改和遍历的使用方法。本章既可以作为教程，也可以作为字典，以方便开发者日常的查询和应用。<br><strong>其它语言中的容器</strong><br>C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。<br>C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。<br>C# 语言通过 .NET 框架提供，如 List 对应数组，LinkedList 对应双链表，Dictionary 对应映射。<br>Lua 语言的 table 实现了数组和<br>映射的功能，Lua 语言默认没有双链表支持。</p><h3 id="Go语言数组详解"><a href="#Go语言数组详解" class="headerlink" title="Go语言数组详解"></a>Go语言数组详解</h3><p>数组（Array）是一段固定长度的连续内存区域。</p><p>在 Go 语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。</p><h4 id="C-C-中的数组"><a href="#C-C-中的数组" class="headerlink" title="C/C++ 中的数组"></a>C/C++ 中的数组</h4><p><strong>C语言和 Go 语言中的数组概念完全一致</strong>。C语言的数组也是一段固定长度的内存区域，数组的大小在声明时固定下来。下面演示一段C语言的数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>此时，a 和 b 类型都是 int*，也就是整型指针。而C语言中，也可以使用 malloc() 函数动态地分配一段内存区域。C++ 语言中可以使用 new() 函数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>此时，a 和 b 的类型也是 int*。a 和 b 此时分配内存的方式类似于 Go 语言的切片。</p><p>Go 的数组和切片都是从C语言延续过来的设计。</p><h4 id="Go-语言数组的声明"><a href="#Go-语言数组的声明" class="headerlink" title="Go 语言数组的声明"></a>Go 语言数组的声明</h4><p>数组的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>其中：<br>数组变量名：数组声明及使用时的变量名。<br>元素数量：数组的元素数量。可以是一个表达式，但最终通过编译期计算的结果必须是整型数值。也就是说，元素数量不能含有到运行时才能确认大小的数值。<br>T 可以是任意基本类型，包括 T 为数组本身。但类型为数组本身时，可以实现多维数组。</p><p>下面是一段数组的演示例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team [<span class="number">3</span>]<span class="keyword">string</span></span><br><span class="line">team[<span class="number">0</span>] = <span class="string">"hammer"</span></span><br><span class="line">team[<span class="number">1</span>] = <span class="string">"soldier"</span></span><br><span class="line">team[<span class="number">2</span>] = <span class="string">"mum"</span></span><br><span class="line">fmt.Println(team)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hammer soldier mum]</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 1 行，将 team 声明为包含 3 个元素的字符串数组。<br>第 2～4 行，为 team 的元素赋值。</p><h4 id="Go语言数组的初始化"><a href="#Go语言数组的初始化" class="headerlink" title="Go语言数组的初始化"></a>Go语言数组的初始化</h4><p>数组可以在声明时使用初始化列表进行元素设置，参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"hammer"</span>, <span class="string">"soldier"</span>, <span class="string">"mum"</span>&#125;</span><br></pre></td></tr></table></figure><p>这种方式编写时，需要保证大括号后面的元素数量与数组的大小一致。但一般情况下，这个过程可以交给编译器，让编译器在编译时，根据元素个数确定数组大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"hammer"</span>, <span class="string">"soldier"</span>, <span class="string">"mum"</span>&#125;</span><br></pre></td></tr></table></figure><p>…表示让编译器确定数组大小。上面例子中，编译器会自动为这个数组设置元素个数为 3。</p><h4 id="遍历数组——访问每一个数组元素"><a href="#遍历数组——访问每一个数组元素" class="headerlink" title="遍历数组——访问每一个数组元素"></a>遍历数组——访问每一个数组元素</h4><p>遍历数组也和遍历切片类似，看下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team [<span class="number">3</span>]<span class="keyword">string</span></span><br><span class="line">team[<span class="number">0</span>] = <span class="string">"hammer"</span></span><br><span class="line">team[<span class="number">1</span>] = <span class="string">"soldier"</span></span><br><span class="line">team[<span class="number">2</span>] = <span class="string">"mum"</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> team &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hammer</span><br><span class="line">soldier</span><br><span class="line">mum</span><br></pre></td></tr></table></figure><p>代码说明如下：<br>第 5 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。<br>第 6 行，将每个键值打印出来。</p><h3 id="Go语言切片详解"><a href="#Go语言切片详解" class="headerlink" title="Go语言切片详解"></a>Go语言切片详解</h3><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。Go 语言切片的内部结构包含地址、大小和容量。切片一般用于快速地操作一块数据集合。如果将数据集合比作切糕的话，切片就是你要的“那一块”。切的过程包含从哪里开始（这个就是切片的地址）及切多大（这个就是切片的大小）。容量可以理解为装切片的口袋大小，如下图所示。</p><p><img src="..http://image.tjl-myblog.cn:4455/.deploy_git/images/blog_article/GO学习笔记/4.jpg" alt="图片消失啦"><br>切片结构和内存分配</p><h4 id="从数组或切片生成新的切片"><a href="#从数组或切片生成新的切片" class="headerlink" title="从数组或切片生成新的切片"></a>从数组或切片生成新的切片</h4><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。</p><p>从连续内存区域生成切片是常见的操作，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice [开始位置:结束位置]</span><br></pre></td></tr></table></figure><p>slice 表示目标切片对象。<br>开始位置对应目标切片对象的索引。<br>结束位置对应目标切片的结束索引。</p><p>从数组生成切片，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a, a[<span class="number">1</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>a 是一个拥有 3 个整型元素的数组，被初始化数值 1 到 3。使用 a[1:2] 可以生成一个新的切片。代码运行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>[2] 就是 a[1:2] 切片操作的结果。</p><p>从数组或切片生成新的切片拥有如下特性：<br>取出的元素数量为：结束位置-开始位置。<br>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取。<br>当缺省开始位置时，表示从连续区域开头到结束位置。<br>当缺省结束位置时，表示从开始位置到整个连续区域末尾。<br>两者同时缺省时，与切片本身等效。<br>两者同时为0时，等效于空切片，一般用于切片复位。</p><p>根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误。生成切片时，结束位置可以填写 len(slice) 但不会报错。</p><p>下面在具体的例子中熟悉切片的特性。<br>1) 从指定范围中生成切片<br>切片和数组密不可分。如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者。出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> highRiseBuilding [<span class="number">30</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">30</span>; i++ &#123;</span><br><span class="line">        highRiseBuilding[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间</span></span><br><span class="line">fmt.Println(highRiseBuilding[<span class="number">10</span>:<span class="number">15</span>])</span><br><span class="line"><span class="comment">// 中间到尾部的所有元素</span></span><br><span class="line">fmt.Println(highRiseBuilding[<span class="number">20</span>:])</span><br><span class="line"><span class="comment">// 开头到中间的所有元素</span></span><br><span class="line">fmt.Println(highRiseBuilding[:<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>代码输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line">[<span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>代码中构建了一个 30 层的高层建筑。数组的元素值从 1 到 30，分别代表不同的独立楼层。输出的结果是不同租售方案。</p><p>代码说明如下：<br>第 8 行，尝试出租一个区间楼层。<br>第 11 行，出租 20 层以上。<br>第 14 行，出租 2 层以下，一般是商用铺面。</p><p>切片有点像C语言里的指针。指针可以做运算，但代价是内存操作越界。切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。<br>2) 表示原有的切片<br>生成切片的格式中，当开始和结束都范围都被忽略，则生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上是一致的，代码如下：<br>a := []int{1, 2, 3}<br>fmt.Println(a[:])<br>a 是一个拥有 3 个元素的切片。将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下：<br>[1 2 3]</p><p>3) 重置切片，清空拥有的元素<br>把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下：<br>a := []int{1, 2, 3}<br>fmt.Println(a[0:0])<br>代码输出如下：<br>[]</p><p>直接声明新的切片<br>除了可以从原有的数组或者切片中生成切片，你也可以声明一个新的切片。每一种类型都可以拥有其切片类型，表示多个类型元素的连续集合。因此切片类型也可以被声明。切片类型声明格式如下：<br>var name []T</p><p>name 表示切片类型的变量名。<br>T 表示切片类型对应的元素类型。</p><p>下面代码展示了切片声明的使用过程：<br>// 声明字符串切片<br>var strList []string<br>// 声明整型切片<br>var numList []int<br>// 声明一个空切片<br>var numListEmpty = []int{}<br>// 输出3个切片<br>fmt.Println(strList, numList, numListEmpty)<br>// 输出3个切片大小<br>fmt.Println(len(strList), len(numList), len(numListEmpty))<br>// 切片判定空的结果<br>fmt.Println(strList == nil)<br>fmt.Println(numList == nil)<br>fmt.Println(numListEmpty == nil)<br>代码输出结果：<br>[] [] []<br>0 0 0<br>true<br>true<br>false</p><p>代码说明如下：<br>第 2 行，声明一个字符串切片，切片中拥有多个字符串。<br>第 5 行，声明一个整型切片，切片中拥有多个整型数值。<br>第 8 行，将 numListEmpty 声明为一个整型切片。本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的。但此时 numListEmpty 已经被分配了内存，但没有元素。<br>第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。<br>第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。<br>第 17 行和第 18 行，声明但未使用的切片的默认值是 nil。strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。<br>第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。</p><p>切片是动态结构，只能与nil判定相等，不能互相判等时。</p><p>声明新的切片后，可以使用 append() 函数来添加元素。<br>使用 make() 函数构造切片<br>如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：<br>make( []T, size, cap )</p><p>T：切片的元素类型。<br>size：就是为这个类型分配多少个元素。<br>cap：预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</p><p>示例如下：<br>a := make([]int, 2)<br>b := make([]int, 2, 10)<br>fmt.Println(a, b)<br>fmt.Println(len(a), len(b))<br>代码输出如下：<br>[0 0] [0 0]<br>2 2</p><p>a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。</p><p>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。<br>温馨提示<br>使用 make() 函数生成的切片一定发生了内存分配操作。但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p><p>切片不一定必须经过 make() 函数才能使用。生成切片、声明后使用 append() 函数均可以正常使用切片。</p><h1 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h1><hr>]]></content>
    
    <summary type="html">
    
      Go学习的记录过程
    
    </summary>
    
      <category term="Go" scheme="http://www.tjl-myblog.cn/categories/Go/"/>
    
    
      <category term="学习笔记" scheme="http://www.tjl-myblog.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题Next-优化整理</title>
    <link href="http://www.tjl-myblog.cn/Hexo%E4%B8%BB%E9%A2%98Next-%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86.html"/>
    <id>http://www.tjl-myblog.cn/Hexo主题Next-优化整理.html</id>
    <published>2019-01-23T04:15:02.000Z</published>
    <updated>2020-12-26T04:55:25.852Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h2><h3 id="默认目录结构："><a href="#默认目录结构：" class="headerlink" title="默认目录结构："></a>默认目录结构：</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">├──</span> <span class="string">.deploy</span></span><br><span class="line"><span class="string">├──</span> <span class="string">public</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scaffolds</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scripts</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source</span></span><br><span class="line"><span class="string">|   ├── _drafts</span></span><br><span class="line"><span class="string">|   └── _posts</span></span><br><span class="line"><span class="string">├── themes</span></span><br><span class="line"><span class="string">├── _config.yml</span></span><br><span class="line"><span class="string">└── package.json</span></span><br><span class="line"><span class="string">deploy：执行hexo deploy命令部署到GitHub上的内容目录</span></span><br><span class="line"><span class="string">public：执行hexo generate命令，输出的静态网页内容目录</span></span><br><span class="line"><span class="string">scaffolds：layout模板文件目录，其中的md文件可以添加编辑</span></span><br><span class="line"><span class="string">scripts：扩展脚本目录，这里可以自定义一些javascript脚本</span></span><br><span class="line"><span class="string">source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</span></span><br><span class="line"><span class="string">drafts：草稿文章</span></span><br><span class="line"><span class="string">posts：发布文章</span></span><br><span class="line"><span class="string">themes：主题文件目录</span></span><br><span class="line"><span class="string">_config.yml：全局配置文件，大多数的设置都在这里</span></span><br><span class="line"><span class="string">package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</span></span><br></pre></td></tr></table></figure><h3 id="next主题："><a href="#next主题：" class="headerlink" title="next主题："></a>next主题：</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">├──</span> <span class="string">.github</span>            <span class="comment">#git信息</span></span><br><span class="line"><span class="string">├──</span> <span class="string">languages</span>          <span class="comment">#多语言</span></span><br><span class="line"><span class="string">|   ├── default.yml    #默认语言</span></span><br><span class="line"><span class="string">|   └── zh-Hans.yml      #简体中文</span></span><br><span class="line"><span class="string">|   └── zh-tw.yml      #繁体中文</span></span><br><span class="line"><span class="string">├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</span></span><br><span class="line"><span class="string">|   ├── _custom        #可以自己修改的模板，覆盖原有模板</span></span><br><span class="line"><span class="string">|   |   ├── _header.swig    #头部样式</span></span><br><span class="line"><span class="string">|   |   ├── _sidebar.swig   #侧边栏样式</span></span><br><span class="line"><span class="string">|   ├── _macro        #可以自己修改的模板，覆盖原有模板</span></span><br><span class="line"><span class="string">|   |   ├── post.swig    #文章模板</span></span><br><span class="line"><span class="string">|   |   ├── reward.swig    #打赏模板</span></span><br><span class="line"><span class="string">|   |   ├── sidebar.swig   #侧边栏模板</span></span><br><span class="line"><span class="string">|   ├── _partial       #局部的布局</span></span><br><span class="line"><span class="string">|   |   ├── head       #头部模板</span></span><br><span class="line"><span class="string">|   |   ├── search     #搜索模板</span></span><br><span class="line"><span class="string">|   |   ├── share      #分享模板</span></span><br><span class="line"><span class="string">|   ├── _script        #局部的布局</span></span><br><span class="line"><span class="string">|   ├── _third-party   #第三方模板</span></span><br><span class="line"><span class="string">|   ├── _layout.swig   #主页面模板</span></span><br><span class="line"><span class="string">|   ├── index.swig     #主页面模板</span></span><br><span class="line"><span class="string">|   ├── page           #页面模板</span></span><br><span class="line"><span class="string">|   └── tag.swig       #tag模板</span></span><br><span class="line"><span class="string">├── scripts            #script源码</span></span><br><span class="line"><span class="string">|   ├── tags           #tags的script源码</span></span><br><span class="line"><span class="string">|   ├── marge.js       #页面模板</span></span><br><span class="line"><span class="string">├── source             #源码</span></span><br><span class="line"><span class="string">|   ├── css            #css源码</span></span><br><span class="line"><span class="string">|   |   ├── _common    #*.styl基础css</span></span><br><span class="line"><span class="string">|   |   ├── _custom    #*.styl局部css</span></span><br><span class="line"><span class="string">|   |   └── _mixins    #mixins的css</span></span><br><span class="line"><span class="string">|   ├── fonts          #字体</span></span><br><span class="line"><span class="string">|   ├── images         #图片</span></span><br><span class="line"><span class="string">|   ├── uploads        #添加的文件</span></span><br><span class="line"><span class="string">|   └── js             #javascript源代码</span></span><br><span class="line"><span class="string">├── _config.yml        #主题配置文件</span></span><br><span class="line"><span class="string">└── README.md          #用GitHub的都知道</span></span><br></pre></td></tr></table></figure><h2 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">TJL的博客</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">学习笔记、知识笔记</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">游戏人生</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客名字</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">副标题(有的主题会显示有的不会)</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">主要用于SEO，建议包含网站关键词。</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">语言会对应的解析正在应用的主题中的languages文件夹下的不同语言文件。所以这里的名称要和languages文件夹下的语言文件名称一致</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">时区(可不管)</span> <span class="string">地区/城市(例：亚洲/北京</span> <span class="string">用英文)</span></span><br></pre></td></tr></table></figure><h3 id="链接设置"><a href="#链接设置" class="headerlink" title="链接设置"></a>链接设置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">http://www.tjl-myblog.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="string">"url"</span><span class="string">：填写自己的站点链接。</span></span><br><span class="line"><span class="string">"root"</span><span class="string">：设置根目录的位置。如果你的网站存放在子目录中，例如</span> <span class="attr">http://yoursite.com/tjl-blog，则应该将你的</span> <span class="string">url</span> <span class="string">设为http://yoursite.com/tjl-blog</span> <span class="string">并把</span> <span class="string">root</span> <span class="string">设为</span> <span class="string">/tjl-blog/。</span></span><br><span class="line"><span class="string">"permalink"</span><span class="string">：生成的链接的格式。可以改成自己喜欢的格式。规则也比较简单，标签前面要加英文冒号。</span></span><br><span class="line"><span class="attr">"permalink_defaults":</span>  <span class="string">生成链接部分默认值</span></span><br></pre></td></tr></table></figure><h3 id="目录设置"><a href="#目录设置" class="headerlink" title="目录设置"></a>目录设置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="string">目录不动即可</span></span><br></pre></td></tr></table></figure><h3 id="书写相关配置"><a href="#书写相关配置" class="headerlink" title="书写相关配置"></a>书写相关配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="string">"new_post_name"</span><span class="string">：新的博文的文件名</span></span><br><span class="line"><span class="string">"default_layout:"</span> <span class="string">默认布局</span></span><br><span class="line"><span class="string">"external_link："</span> <span class="string">在新选项卡中打开外部链接</span></span><br><span class="line"><span class="string">"filename_case: 0"</span> <span class="comment">#把文件名称转换为 (1) 小写或 (2) 大写</span></span><br><span class="line"><span class="string">"render_drafts: false"</span> <span class="string">是否显示草稿</span></span><br><span class="line"><span class="string">"post_asset_folder: false"</span> <span class="comment">#是否启动资源文件夹</span></span><br><span class="line"><span class="string">"relative_link: false"</span> <span class="comment">#把链接改为与根目录的相对位址</span></span><br><span class="line"><span class="string">"future: true "</span> <span class="string">不知道干什么的</span> <span class="string">默认即可</span></span><br><span class="line"><span class="string">"highlight:"</span> <span class="comment">#代码块的设置，Hexo自带的代码高亮插件</span></span><br></pre></td></tr></table></figure><h3 id="分类标签设置"><a href="#分类标签设置" class="headerlink" title="分类标签设置"></a>分类标签设置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="string">"default_category"</span><span class="string">：如果没有设置分类，默认的分类选择。</span></span><br><span class="line"><span class="string">"category_map"</span><span class="string">：用于映射分类的别名。</span></span><br><span class="line"><span class="string">"tag_map"</span><span class="string">：用法和分类别名是一样</span></span><br></pre></td></tr></table></figure><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="string">这里使用的是next主题</span> <span class="string">当然也有其他主题</span></span><br><span class="line"></span><br><span class="line"><span class="string">theme</span> <span class="string">选择什么主题</span> <span class="string">next有三种样式在主题配置里可修改</span> <span class="string">`站点根目录/themes/next/_config.yml`</span> <span class="string">这里我使用的是Pisces</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes  # NexT 主题提供四种布局</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#表示注释的意思</span></span><br></pre></td></tr></table></figure><h3 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">git@github.com:tangjialang/tangjialang.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"><span class="attr">repo:</span></span><br><span class="line"></span><br><span class="line"><span class="string">"deploy"</span><span class="string">：部署方式</span></span><br><span class="line"><span class="string">"repository"</span><span class="string">：远程仓库</span></span><br><span class="line"><span class="string">"branch"</span><span class="string">：分支</span></span><br><span class="line"></span><br><span class="line"><span class="string">两个部署方式</span> <span class="string">有一个是推送百度链接的</span> <span class="string">后面文章会讲到</span></span><br></pre></td></tr></table></figure><h2 id="实用性优化"><a href="#实用性优化" class="headerlink" title="实用性优化"></a>实用性优化</h2><h3 id="浏览页面的时候显示当前浏览进度"><a href="#浏览页面的时候显示当前浏览进度" class="headerlink" title="浏览页面的时候显示当前浏览进度"></a>浏览页面的时候显示当前浏览进度</h3><p>打开<code>themes/next/_config.yml</code>搜索关键字<code>scrollpercent</code>把<code>false</code>对划线<code>true</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果想把<code>top</code>按钮放在侧边栏，打开<code>themes/next/_config.yml</code>搜索关键字<code>b2t</code>，把<code>false</code>对划线<code>true</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Back to top in sidebar</span></span><br><span class="line"><span class="attr">b2t:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="添加标签、分类等页面"><a href="#添加标签、分类等页面" class="headerlink" title="添加标签、分类等页面"></a>添加标签、分类等页面</h3><p>修改主题配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">/</span> <span class="comment">#首页</span></span><br><span class="line"><span class="attr">archives:</span> <span class="string">/archives/</span> <span class="comment">#档案</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">/tags/</span> <span class="comment">#标签</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">/categories/</span> <span class="comment">#分类</span></span><br><span class="line"><span class="attr">about:</span> <span class="string">/about/</span> <span class="comment">#关于</span></span><br><span class="line"><span class="comment">#sitemap: /sitemap.xml #站点地图</span></span><br><span class="line"><span class="comment">#commonweal: /404/ #公益</span></span><br></pre></td></tr></table></figure><p>可根据自己的喜欢来设置显示哪一些 第一次设置需要新建一些页面</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">tags</span> <span class="string">新建标签页面</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">categories</span> <span class="string">新建分类页面</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">about</span> <span class="string">新建关于页面</span></span><br></pre></td></tr></table></figure><p>新建之后要对<code>站点根目录/source/categories</code>和<code>站点根目录/source/tags</code>的<code>index.md</code>标签和分类页面进行进行一些修改 不修改的话 后面文章在生成静态网页的时候标签和分类会出现问题 看不到的情况</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">分类页面</span> <span class="string">类型要改为`type:</span> <span class="string">"categories"</span><span class="string">`</span></span><br><span class="line"><span class="string">标签页面</span> <span class="string">类型要改为`type:</span> <span class="string">'tags'</span><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h3><p><a href="https://www.leiue.com/what-is-rss-feed" rel="external nofollow noopener noreferrer" target="_blank">什么是RSS</a></p><p>首先安装 <code>hexo-generator-feed</code>插件。<br>再到站点根目录右键打开Git Bash，安装插件：<code>$ npm install --save hexo-generator-feed</code></p><p>修改站点配置文件，在最后添加以下代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span> <span class="comment"># RSS订阅插件</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br></pre></td></tr></table></figure><p>修改主题配置文件如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure><p>实现效果：<img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/1.jpg" alt="图片消失啦"></p><h3 id="设置网站icon"><a href="#设置网站icon" class="headerlink" title="设置网站icon"></a>设置网站icon</h3><p>主题配置文件中第一行代码就是网站icon设置，这里需要找到你喜欢的logo把它制作成ico格式然后改名favicon.ico，放到<code>/themes/next/source/images</code>下面即可。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Put your favicon.ico into `hexo-site/source/` directory.</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span> <span class="comment"># 网站logo</span></span><br></pre></td></tr></table></figure><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><h4 id="增加打赏配置"><a href="#增加打赏配置" class="headerlink" title="增加打赏配置"></a>增加打赏配置</h4><p>准备支付宝二维码<code>alipay.jpg</code>和微信二维码<code>wechatpay.jpg</code><br>把两张图片放入<code>themes/next/source/images</code>中</p><h4 id="修改next主题配置-config-yml"><a href="#修改next主题配置-config-yml" class="headerlink" title="修改next主题配置_config.yml"></a>修改next主题配置_config.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.jpg</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br></pre></td></tr></table></figure><h4 id="修复煽动bug"><a href="#修复煽动bug" class="headerlink" title="修复煽动bug"></a>修复煽动bug</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/*</span> <span class="string">注释文字闪动函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#wechat:hover p&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    animation:</span> <span class="string">roll</span> <span class="number">0.1</span><span class="string">s</span> <span class="string">infinite</span> <span class="string">linear;</span></span><br><span class="line"><span class="attr">    -webkit-animation:</span> <span class="string">roll</span> <span class="number">0.1</span><span class="string">s</span> <span class="string">infinite</span> <span class="string">linear;</span></span><br><span class="line"><span class="attr">    -moz-animation:</span> <span class="string">roll</span> <span class="number">0.1</span><span class="string">s</span> <span class="string">infinite</span> <span class="string">linear;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#alipay:hover p&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    animation:</span> <span class="string">roll</span> <span class="number">0.1</span><span class="string">s</span> <span class="string">infinite</span> <span class="string">linear;</span></span><br><span class="line"><span class="attr">    -webkit-animation:</span> <span class="string">roll</span> <span class="number">0.1</span><span class="string">s</span> <span class="string">infinite</span> <span class="string">linear;</span></span><br><span class="line"><span class="attr">    -moz-animation:</span> <span class="string">roll</span> <span class="number">0.1</span><span class="string">s</span> <span class="string">infinite</span> <span class="string">linear;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure><p>修改 <code>next/source/css/_common/components/post/post-reward.styl</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">注释:wechat:hover和alipay:hover</span></span><br></pre></td></tr></table></figure><h3 id="博客文章宽度优化"><a href="#博客文章宽度优化" class="headerlink" title="博客文章宽度优化"></a>博客文章宽度优化</h3><h4 id="Next-Mist-宽度优化"><a href="#Next-Mist-宽度优化" class="headerlink" title="Next.Mist 宽度优化"></a>Next.Mist 宽度优化</h4><p>打开 <code>\themes\next\source\css\_common\components\post\post-expand.styl</code> 文件，找到</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (max-width: <span class="number">767px</span>)</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (max-width: <span class="number">1080px</span>)</span><br></pre></td></tr></table></figure><p>打开 \themes\next\source\css\ _variables\base.styl 文件，找到</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$main-desktop                   = 960px</span><br><span class="line">$main-desktop-large             = 1200px</span><br><span class="line">$content-desktop                = 700px</span><br></pre></td></tr></table></figure><p>修改 $main-desktop 和 $content-desktop 的数值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$main-desktop                   = 1080px</span><br><span class="line">$main-desktop-large             = 1200px</span><br><span class="line">$content-desktop                = 810px</span><br></pre></td></tr></table></figure><h4 id="Next-Pisces宽度优化"><a href="#Next-Pisces宽度优化" class="headerlink" title="Next.Pisces宽度优化"></a>Next.Pisces宽度优化</h4><p><del>Next.Pisces宽度优化是在Next.Mist 宽度优化设置的前提下进行改动的</del><br>打开 <code>\themes\next\source\css\_schemes\Pisces\_layout.styl</code> 文件，将第 4 行的 width改为1080px ，修改后如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">1080px</span>;</span><br></pre></td></tr></table></figure><h4 id="NexT-Gemini宽度优化"><a href="#NexT-Gemini宽度优化" class="headerlink" title="NexT.Gemini宽度优化"></a>NexT.Gemini宽度优化</h4><p><del>6.0 版新版 NexT.Gemini主题，可以在主题配置文件中设置max_content_width: 65%即可设置宽度。</del></p><p>在<code>\next\source\css\_variables custom.styl</code> 文件里添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$content-desktop              = 'calc(100% - %s)' % unit($content-desktop-padding / 2, 'px')</span><br><span class="line">$content-desktop-large        = 1160px</span><br><span class="line">$content-desktop-largest      = 65%</span><br></pre></td></tr></table></figure><h3 id="添加侧边栏社交链接"><a href="#添加侧边栏社交链接" class="headerlink" title="添加侧边栏社交链接"></a>添加侧边栏社交链接</h3><p>修改主题配置文件的社交链接和对应图标：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span>  <span class="comment"># 添加你的社交账号链接</span></span><br><span class="line"><span class="attr">    GitHub:</span> <span class="attr">https://github.com/tangjialang</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">    E-Mail:</span> <span class="attr">mailto:1522848509t@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line"><span class="attr">    Google:</span> <span class="attr">https://plus.google.com/1522848509t</span> <span class="string">||</span> <span class="string">google</span></span><br><span class="line"><span class="attr">    YouTube:</span> <span class="attr">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">youtube</span></span><br><span class="line"><span class="attr">    Twitter:</span> <span class="attr">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">twitter</span></span><br><span class="line"><span class="attr">    CSDN:</span> <span class="attr">https://blog.csdn.net/weixin</span> <span class="string">||</span> <span class="string">superpowers</span></span><br><span class="line">    <span class="string">简书:</span> <span class="attr">https://www.jianshu.com/u/89024bda3356</span> <span class="string">||</span> <span class="string">book</span></span><br><span class="line"><span class="attr">social_icons:</span> <span class="comment"># 社交账号图标</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    icons_only:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    transition:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    GitHub:</span> <span class="string">github</span></span><br><span class="line"><span class="attr">    Twitter:</span> <span class="string">twitter</span></span><br><span class="line"><span class="attr">    CSDN:</span> <span class="string">superpowers</span></span><br><span class="line">    <span class="string">简书:</span> <span class="string">book</span></span><br><span class="line">    <span class="string">微博:</span> <span class="string">weibo</span></span><br><span class="line">    <span class="string">知乎:</span> <span class="string">zhihu</span></span><br></pre></td></tr></table></figure><p><a href="https://fontawesome.com/icons?d=gallery" rel="external nofollow noopener noreferrer" target="_blank">图标库</a><br>在库里面找到复制名字添加到后面即可<br>效果：<img src="../images/blog_article/Hexo主题Next-优化整理/2.jpg" alt="图片消失啦"></p><h3 id="添加侧边栏友情链接"><a href="#添加侧边栏友情链接" class="headerlink" title="添加侧边栏友情链接"></a>添加侧边栏友情链接</h3><p>修改主题配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span> <span class="comment">#图标库图标</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">推荐阅读</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span> <span class="comment">#布局方式</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">    <span class="string">Web前端导航:</span> <span class="attr">http://www.alloyteam.com/nav/</span></span><br><span class="line">    <span class="string">创造狮导航:</span> <span class="attr">http://www.chuangzaoshi.com/code</span></span><br><span class="line">    <span class="string">前端书籍资料:</span> <span class="attr">http://www.36zhen.com/t?id=3448</span></span><br><span class="line">    <span class="string">掘金酱:</span> <span class="attr">http://e.xitu.io/</span></span><br><span class="line"><span class="attr">    V2EX:</span> <span class="attr">https://www.v2ex.com/</span></span><br><span class="line">    <span class="string">印记中文:</span> <span class="attr">https://www.v2ex.com/</span></span><br></pre></td></tr></table></figure><p>效果：<img src="../images/blog_article/Hexo主题Next-优化整理/3.jpg" alt="图片消失啦"></p><h3 id="底部显示建站时间和图标修改"><a href="#底部显示建站时间和图标修改" class="headerlink" title="底部显示建站时间和图标修改"></a>底部显示建站时间和图标修改</h3><p>修改主题配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2018</span> <span class="comment"># 建站年份</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># icon between year and author @Footer</span></span><br><span class="line"><span class="attr">icon:</span> <span class="string">heart</span> <span class="string">图标库图标</span></span><br></pre></td></tr></table></figure><p>效果：<img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/4.jpg" alt="图片消失啦"></p><h3 id="设置第三方JS库"><a href="#设置第三方JS库" class="headerlink" title="设置第三方JS库"></a>设置第三方JS库</h3><p>在主题配置文件中设定成合适的 CDN 地址，此特性可以加速静态资源（JavaScript 第三方库）的加载</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Script Vendors.</span></span><br><span class="line"><span class="comment"># Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment">#    jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span></span><br><span class="line"><span class="comment"># Be aware that you should use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Please use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line"><span class="comment"># Internal path prefix. Please do not edit it.</span></span><br><span class="line"><span class="attr">_internal:</span> <span class="string">lib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 2.1.3</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 2.1.5</span></span><br><span class="line"><span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="string">//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js</span></span><br><span class="line"><span class="attr">fancybox_css:</span> <span class="string">//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.6</span></span><br><span class="line"><span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line"><span class="attr">fastclick:</span> <span class="string">//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.9.7</span></span><br><span class="line"><span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="string">//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.2.1</span></span><br><span class="line"><span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">velocity:</span> <span class="string">//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.2.1</span></span><br><span class="line"><span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">velocity_ui:</span> <span class="string">//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 0.7.9</span></span><br><span class="line"><span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line"><span class="attr">ua_parser:</span> <span class="string">//cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 4.6.2</span></span><br><span class="line"><span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1</span></span><br><span class="line"><span class="comment"># https://www.algolia.com</span></span><br><span class="line"><span class="attr">algolia_instant_js:</span></span><br><span class="line"><span class="attr">algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.2</span></span><br><span class="line"><span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line"><span class="comment"># Or use direct links below:</span></span><br><span class="line"><span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"><span class="attr">pace:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="attr">pace_css:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.0</span></span><br><span class="line"><span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="string">//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js</span></span><br></pre></td></tr></table></figure><h3 id="追加评论功能"><a href="#追加评论功能" class="headerlink" title="追加评论功能"></a>追加评论功能</h3><p>NexT支持的第三方的评论系统有很多，不过不少已经关闭不再可用了，而且对于国内来说比较友好的现在应该就只有来必力，当然喜欢折腾的小伙伴可以尝试一下其他的或者自建评论系统。最简单可行的方案，也就是来必力。<br>获取<a href="https://www.livere.com/" rel="external nofollow noopener noreferrer" target="_blank">来必力</a>id：</p><p>登陆 来必力 注册获取。（这里要注意，这个韩国的系统注册啥的真的太慢了，所以要记住不要耐不住关闭页面或者狂刷新，耐心等待就好。闲慢的朋友可以自行备梯子哦 后面会更新相关梯子的教程）<br>注册后点击导航上边的安装，选择免费的city版本：点击现在安装后填入网站的一些信息就可以获取到安装代码，框中的就是你的来必力id：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/5.jpg" alt="图片消失啦"><br>复制上边的id，在主题配置文件里面搜索livere_uid，在后面添加来必力id即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="string">你的来必力id</span></span><br></pre></td></tr></table></figure><p>另外可以点击用户头像进入管理界面个性化你的评论系统<br>效果：<img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/6.jpg" alt="图片消失啦"></p><blockquote><p>这里添加了之后要注意每篇文章的开头记得添加comments： 设置为true 表示开启评论功能 后面会讲到怎么利用 Hexo new 命令快捷创建文章格式</p></blockquote><h3 id="文章字数统计-阅读时长-文章访问量"><a href="#文章字数统计-阅读时长-文章访问量" class="headerlink" title="文章字数统计 阅读时长 文章访问量"></a>文章字数统计 阅读时长 文章访问量</h3><p>在主题配置文件中，搜索wordcount，设置为下面这样就可以了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">    item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    totalcount:</span> <span class="literal">false</span> <span class="comment">#站内总字数 如果这里开启 下面的全站字数统计就不需要了</span></span><br><span class="line"><span class="attr">    separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>再打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>leancloud-visitors-count</code>后面位置添加一个分割符（空格即可）</p><p>再把不蒜子统计功能打开 主题配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不蒜子统计功能</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"><span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#不蒜子统计总开关</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># custom uv span for the whole site</span></span><br><span class="line"><span class="comment"># 效果：本站访客数12345人次</span></span><br><span class="line"><span class="attr">site_uv:</span> <span class="literal">false</span> <span class="comment">#上面已经开启所以不用设置为true</span></span><br><span class="line"><span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span> <span class="string">本站访客数</span></span><br><span class="line"><span class="attr">site_uv_footer:</span> <span class="number">12345</span><span class="string">次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># custom pv span for the whole site</span></span><br><span class="line"><span class="comment"># 效果：本站总访问量12345次（一般不开启这个）</span></span><br><span class="line"><span class="attr">site_pv:</span> <span class="literal">false</span> <span class="comment">#上面已经开启所以不用设置为true</span></span><br><span class="line"><span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span> <span class="string">本站总访问量</span></span><br><span class="line"><span class="attr">site_pv_footer:</span> <span class="number">12345</span><span class="string">次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># custom pv span for one page only</span></span><br><span class="line"><span class="comment"># 效果：本文总阅读量12345次</span></span><br><span class="line"><span class="attr">page_pv:</span> <span class="literal">true</span> <span class="comment">#阅读次数开关</span></span><br><span class="line"><span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span> <span class="string">本文总阅读量</span></span><br><span class="line"><span class="attr">page_pv_footer:</span> <span class="number">12345</span><span class="string">次</span></span><br></pre></td></tr></table></figure><h3 id="统计站点访问量-字数统计"><a href="#统计站点访问量-字数统计" class="headerlink" title="统计站点访问量 字数统计"></a>统计站点访问量 字数统计</h3><p>找到站点的<code>themes/next/layout/_partials</code>目录下的<code>footer.swig</code>文件。添加以下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新增访客统计代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"busuanzi-count"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-uv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    访问用户： <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"busuanzi-value"</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-uv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    访问次数： <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"busuanzi-value"</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 博客字数统计 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-pv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-pencil"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    博客全站共： <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; totalcount(site) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 新增访客统计代码 END--&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果增加了 ‘ 新增访客统计代码’这个可以下面一步忽略 如果都设置的话会出现两个统计字数的</p></blockquote><p>在<code>/themes/next/layout/_partials/footer.swig</code>文件<code>endif %}</code>前加上下面代码可以实现在站点底部统计全站字数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>Total Words:&#123;&#123; totalcount(site) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果无法显示可能是<code>hexo-wordcount</code>插件没有安装，git bash在网站根目录安装一下就可以：<code>$ npm install hexo-wordcount --save</code></p></blockquote><p><a href="https://www.jianshu.com/p/fd3accaa2ae0" rel="external nofollow noopener noreferrer" target="_blank">Hexo博客解决不蒜子统计无法显示问题</a></p><h3 id="增加版权信息"><a href="#增加版权信息" class="headerlink" title="增加版权信息"></a>增加版权信息</h3><p>在目录<code>themes/next/layout/_macro/</code>下添加<code>my-copyright.swig</code>（这是一个自定义文件）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my_post_copyright"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JS库 sweetalert 可修改路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>本文标题:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>文章作者:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">title</span>=<span class="string">"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>发布时间:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>最后更新:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>原始链接:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; page.title &#125;&#125;"</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"copy-path"</span>  <span class="attr">title</span>=<span class="string">"点击复制文章链接"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-clipboard"</span> <span class="attr">data-clipboard-text</span>=<span class="string">"&#123;&#123; page.permalink &#125;&#125;"</span>  <span class="attr">aria-label</span>=<span class="string">"复制成功！"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>许可协议:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-creative-commons"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">"license"</span> <span class="attr">href</span>=<span class="string">"https://creativecommons.org/licenses/by-nc-nd/4.0/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 转载请保留原文链接及作者。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var clipboard = new Clipboard('.fa-clipboard');</span></span><br><span class="line"><span class="undefined">$(".fa-clipboard").click(function()&#123;</span></span><br><span class="line"><span class="undefined">clipboard.on('success', function()&#123;</span></span><br><span class="line"><span class="undefined">    swal(&#123;</span></span><br><span class="line"><span class="undefined">    title: "",</span></span><br><span class="line"><span class="undefined">    text: '复制成功',</span></span><br><span class="line"><span class="undefined">    icon: "success",</span></span><br><span class="line"><span class="undefined">    showConfirmButton: true</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;);  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在目录<code>themes/next/source/css/_common/components/post/</code>下添加<code>my-post-copyright.styl</code> （自定义文件）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.my_post_copyright</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">85%</span>;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">45em</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">2.8em</span> auto <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">0.93rem</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.6em</span>;</span><br><span class="line"><span class="attribute">word-break</span>: break-all;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">p</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">5.2em</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#b5b5b5</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.raw</span> &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line"><span class="attribute">border-bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#a3d2a3</span>;</span><br><span class="line"><span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.fa-clipboard</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.post-url</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span> &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">+mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_post_copyright</span> <span class="selector-class">.copy-path</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line"><span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>themes/next/layout/_macro/post.swig</code>在代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% include 'wechat-subscriber.swig' %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>前面添加代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include 'my-copyright.swig' %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<code>themes/next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"my-post-copyright"</span></span><br></pre></td></tr></table></figure><p>最后到站点根目录/scaffolds/post.md，在两个—中间增加一行(为的就是使用Hexo new 命令创建的文章自带版权模板)：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copyright:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>之后的每一篇文章都会自己加上版权信息，之前的文章也可以通过在文章对应的md文件头部加上以上代码添加版权信息</p><h3 id="添加分享文章功能"><a href="#添加分享文章功能" class="headerlink" title="添加分享文章功能"></a>添加分享文章功能</h3><p>这里我使用的是<a href="https://www.addthis.com/" rel="external nofollow noopener noreferrer" target="_blank">AddThis</a>(因为他的样式让我觉得很棒 这里注册要使用梯子哦)<br>注册之后找到这里<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/7.jpg" alt="图片消失啦"><br>复制uid<br>在主题配置文件中搜索add_this_id，去掉前面的注释，添加上你的AddThis ID就可以了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Share  分享</span></span><br><span class="line"><span class="comment">#jiathis: true</span></span><br><span class="line"><span class="comment"># Warning: JiaThis does not support https. 博主实测支持https</span></span><br><span class="line"><span class="attr">add_this_id:</span> <span class="string">你的uid</span></span><br></pre></td></tr></table></figure><p>样式配置<img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/8.jpg" alt="图片消失啦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/9.jpg" alt="图片消失啦"><br>然后就可以进行图标分享配置了 配置完之后要点激活工具就可以了</p><blockquote><p>各种不同的样式看你们习惯啦 如果觉得不好的也可以使用其他分享工具 也比较多 这里就不讲解了 有兴趣的朋友可以百度试试哦</p></blockquote><h3 id="添加文章评分功能"><a href="#添加文章评分功能" class="headerlink" title="添加文章评分功能"></a>添加文章评分功能</h3><p>通过<a href="https://widgetpack.com/" rel="external nofollow noopener noreferrer" target="_blank">widgetpack</a>来给网站每篇文章添加评分系统，效果如下：</p><p>首先注册账号，添加新站点，填入网站名称和域名地址，点击添加：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/10.jpg" alt="图片消失啦"></p><p>获取id：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/11.jpg" alt="图片消失啦"><br>复制下来到主题配置文件中搜索widgetpack添加即可:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">id:</span>  <span class="string">你的id</span></span><br><span class="line"><span class="attr">color:</span>  <span class="string">fc6423</span></span><br></pre></td></tr></table></figure><p>这里建议设置为按ip地址记录评分，比较方便(不用登陆即可评分 相当于ip替代了登陆这个工作)：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/12.jpg" alt="图片消失啦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/13.jpg" alt="图片消失啦"></p><h3 id="文章排序优先级设置"><a href="#文章排序优先级设置" class="headerlink" title="文章排序优先级设置"></a>文章排序优先级设置</h3><p>修改<code>hero-generator-index</code>插件，把文件<code>node_modules/hexo-generator-index/lib/generator.js</code>内的代码替换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line"><span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line"><span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">    __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>\scaffolds\post.md</code>头部—中添加以下代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top:</span> <span class="string">number</span></span><br></pre></td></tr></table></figure><p>以后新建文章就可以给文章的top赋值，number越大优先级越高。</p><p>已经写好的文章在对应的md文件头部添加top：number即可</p><h3 id="置顶图标"><a href="#置顶图标" class="headerlink" title="置顶图标"></a>置顶图标</h3><p>用上面的方法给文章置顶之后再给文章添加 sticky: true 即可实现置顶图标</p><p>修改图标大小 <code>\themes\next\source\css\_custom\custom.styl</code> 中添加一个css 既可设置他的大小 也可以更改颜色等信息</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.post-sticky-flag&#123; //置顶图标的大小css</span><br><span class="line">        <span class="selector-tag">font-size</span>: 20<span class="selector-tag">px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加站内搜索功能"><a href="#添加站内搜索功能" class="headerlink" title="添加站内搜索功能"></a>添加站内搜索功能</h3><p>这里使用的是<a href="https://www.algolia.com/" rel="external nofollow noopener noreferrer" target="_blank">Algolia</a><br>前往Algolia注册页面，注册一个新账户。可以使用GitHub或者Google账户直接登录，注册后的14天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户总共有10,000条记录，每月有100,000的可以操作数。<img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/15.jpg" alt="图片消失啦">注册完成后，创建一个新的Index，这个Index将在后面使用。（有新手引导）</p><p>Index创建完成后，此时这个Index里未包含任何数据。接下来需要安装Hexo Algolia扩展，这个扩展的功能是搜集站点的内容并通过API发送给Algolia。前往站点根目录，执行命令安装：<code>npm install --save hexo-algolia</code></p><p>找到新建的Index对应的Key复制下面的App ID和API Key<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/14.jpg" alt="图片消失啦"><br>同时修改权限:<br>在站点配置文件（注意是站点配置文件）末尾，新增配置代码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加搜索</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line"><span class="attr">    applicationID:</span></span><br><span class="line"><span class="attr">    apiKey:</span></span><br><span class="line"><span class="attr">    adminApiKey:</span></span><br><span class="line"><span class="attr">    indexName:</span> <span class="comment">#你的指数名字</span></span><br><span class="line"><span class="attr">    chunkSize:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>在站点根目录执行以下代码，更新Index(每次更新文章都需要执行一次)，即上传站点内容到algolia：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">export</span> <span class="string">HEXO_ALGOLIA_INDEXING_KEY='你的adminApiKey'</span> <span class="string">(这里好像</span> <span class="string">=</span> <span class="string">号左右两边不能有空格</span> <span class="string">这里要注意)</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">algolia</span></span><br></pre></td></tr></table></figure><p>更改主题配置文件，搜索algolia_search：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hits:</span></span><br><span class="line"><span class="attr">    per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">    input_placeholder:</span> <span class="string">输入关键字</span></span><br><span class="line"><span class="attr">    hits_empty:</span> <span class="string">"没有找到任何搜索结果: $&#123;query&#125;"</span></span><br><span class="line"><span class="attr">    hits_stats:</span> <span class="string">"$&#123;hits&#125; 找到约 $&#123;time&#125; 条结果"</span></span><br></pre></td></tr></table></figure><blockquote><p>顺序 <code>hexo + clean --&gt; hexo + g --&gt; hexo + d --&gt; export HEXO_ALGOLIA_INDEXING_KEY=&#39;你的adminApiKey&#39; --&gt; hexo algolia</code><br>如果按照新手指导创建的algolia指数没有用 就删除自己新建一个 一切默认即可 如果还是不行欢迎下方评论或联系我</p></blockquote><h3 id="在线联系"><a href="#在线联系" class="headerlink" title="在线联系"></a>在线联系</h3><p>首先去<a href="http://www.daovoice.io/" rel="external nofollow noopener noreferrer" target="_blank">DaoVoice</a>注册。注册后就可以查看你的app_id:</p><p>复制app_id，打开<code>/themes/next/layout/_partials/head.swig</code>写下如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params">i,s,o,g,r,a,m</span>)</span>&#123;i[<span class="string">"DaoVoiceObject"</span>]=r;i[r]=i[r]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;(i[r].q=i[r].q||[]).push(<span class="built_in">arguments</span>)&#125;,i[r].l=<span class="number">1</span>*<span class="keyword">new</span> <span class="built_in">Date</span>();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class="number">0</span>];a.async=<span class="number">1</span>;a.src=g;a.charset=<span class="string">"utf-8"</span>;m.parentNode.insertBefore(a,m)&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">"script"</span>,(<span class="string">'https:'</span> == <span class="built_in">document</span>.location.protocol ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">"//widget.daovoice.io/widget/0f81ff2f.js"</span>,<span class="string">"daovoice"</span>)</span></span><br><span class="line"><span class="javascript">daovoice(<span class="string">'init'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    app_id: <span class="string">"&#123;&#123;theme.daovoice_app_id&#125;&#125;"</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">daovoice(<span class="string">'update'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>接着打开主题配置文件，在最后写下如下代码：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/16.jpg" alt="图片消失啦"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Online contact</span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> <span class="string">'你的id'</span></span><br></pre></td></tr></table></figure><p>具体样式设计可以在 应用设置–&gt;聊天设置后边改</p><h3 id="给代码块添加复制功能"><a href="#给代码块添加复制功能" class="headerlink" title="给代码块添加复制功能"></a>给代码块添加复制功能</h3><p>下载clipboard.js<br>下载第三方插件：<a href="https://github.com/zenorocha/clipboard.js" rel="external nofollow noopener noreferrer" target="_blank">clipboard.js</a>,或者<a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" rel="external nofollow noopener noreferrer" target="_blank">直接下载</a>(右键另存为)。</p><p>保存文件到<code>theme/next/source/js/src</code>下 没有文件夹就创建文件夹。</p><p>在<code>theme/next/source/js/src</code>目录下创建<code>clipboard-use.js</code>添加内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;span&gt;复制&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>在<code>theme/next/source/css/_custom/custom.styl</code>样式中添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//代码块复制按钮</span><br><span class="line"><span class="selector-class">.highlight</span>&#123;</span><br><span class="line">  //方便copy代码按钮（btn-copy）的定位</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#fcfcfc,#eee);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">-o-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-copy</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>themes/next/layout/_layout.swig</code>文件中最后添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码块复制功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/clipboard.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/clipboard-use.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者将<code>clipboard.min.js</code>和<code>clipboard-use.js</code>保存到类似七牛云上，通过引用也可（推荐）</p><h3 id="设置默认文章格式"><a href="#设置默认文章格式" class="headerlink" title="设置默认文章格式"></a>设置默认文章格式</h3><p>在/scaffolds/post.md下修改为以下代码 顺序可以改 这样每次用hexo new 的文章都会是这种格式开头的了(默认文章格式)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">0</span> <span class="comment">#数值越大 排着越上面</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#123;&#123;</span> <span class="string">title</span> <span class="string">&#125;&#125;</span> <span class="comment">#主题</span></span><br><span class="line"><span class="attr">keywords:</span>  <span class="comment">#关键字</span></span><br><span class="line"><span class="attr">description:</span>  <span class="comment">#描述</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span> <span class="comment">#时间</span></span><br><span class="line"><span class="attr">tags:</span>  <span class="comment">#标签</span></span><br><span class="line"><span class="attr">categories:</span>  <span class="comment">#分类</span></span><br><span class="line"><span class="attr">copyright:</span>  <span class="comment">#版权</span></span><br><span class="line"><span class="attr">comments:</span>  <span class="comment">#评论</span></span><br><span class="line"><span class="attr">password:</span>  <span class="comment">#密码</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">!()[]</span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="bullet">--&gt;(阅读全文)</span></span><br></pre></td></tr></table></figure><h2 id="个性化优化"><a href="#个性化优化" class="headerlink" title="个性化优化"></a>个性化优化</h2><h3 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h3><p>NexT 默认使用的是  normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line"><span class="string">[Next官网有](http://theme-next.iissnan.com/theme-settings.html)</span></span><br></pre></td></tr></table></figure><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/17.jpg" alt="图片消失啦"></p><h3 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h3><p>在主题配置文件中设置，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line"><span class="attr">host:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line"><span class="attr">headings:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章字体</span></span><br><span class="line"><span class="attr">posts:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logo 字体</span></span><br><span class="line"><span class="attr">logo:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Lobster</span> <span class="string">Two</span></span><br><span class="line"><span class="attr">    size:</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line"><span class="attr">codes:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">PT</span> <span class="string">Mono</span></span><br></pre></td></tr></table></figure><h3 id="设置小型代码块颜色"><a href="#设置小型代码块颜色" class="headerlink" title="设置小型代码块颜色"></a>设置小型代码块颜色</h3><p>修改<code>\themes\next\source\css\_variables\base.styl</code>文件，修改<code>$code-background</code>和<code>$code-foreground</code>的值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Code &amp; Code Blocks</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$code-font-family               = $font-family-monospace</span><br><span class="line">$code-font-size                 = 13px</span><br><span class="line">$code-font-size                 = unit(hexo-config('font.codes.size'), px) if hexo-config('font.codes.size') is a 'unit'</span><br><span class="line">$code-border-radius             = 3px</span><br><span class="line">$code-foreground                = $black-light</span><br><span class="line">$code-background                = $gainsboro</span><br></pre></td></tr></table></figure><h3 id="文字增加背景色块"><a href="#文字增加背景色块" class="headerlink" title="文字增加背景色块"></a>文字增加背景色块</h3><p>打开<code>themes/next/source/css/_custom</code> 下的 <code>custom.sty</code>l 文件,添加属性样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 颜色块-黄</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-yellow</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#f0ad4e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 颜色块-绿</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-green</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 颜色块-蓝</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-blue</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#2780e3</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 颜色块-紫</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-purple</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#9954bb</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你需要编辑的文章地方。放置如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-blue"</span>&gt;</span> 站点配置文件 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-purple"</span>&gt;</span> 主题配置文件 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-yellow"</span>&gt;</span> 站点配置文件 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-green"</span>&gt;</span> 主题配置文件 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/18.jpg" alt="图片消失啦"></p><h3 id="在文档中增加图标-Font-Awesome"><a href="#在文档中增加图标-Font-Awesome" class="headerlink" title="在文档中增加图标, Font Awesome"></a>在文档中增加图标, <a href="http://fontawesome.dashgame.com/#basic" rel="external nofollow noopener noreferrer" target="_blank">Font Awesome</a></h3><p>代码<br>单一使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-adjust fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> fa-表示图标的名字</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-adjust fa-2x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> fa-可编辑大小</span><br></pre></td></tr></table></figure><p>组合使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"fa-stack fa-lg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square-o fa-stack-2x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-twitter fa-stack-1x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-adjust"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<br>单一使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-adjust fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> fa-表示图标的名字</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-adjust fa-2x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> fa-可编辑大小</span><br></pre></td></tr></table></figure><p>组合使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"fa-stack fa-lg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-square-o fa-stack-2x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-twitter fa-stack-1x"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用Font-Awesome绘制下载样式"><a href="#利用Font-Awesome绘制下载样式" class="headerlink" title="利用Font Awesome绘制下载样式"></a>利用Font Awesome绘制下载样式</h3><p>打开<code>themes/next/source/css/_custom</code> 下的 <code>custom.styl</code> 文件,添加属性样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-id">#download</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">background</span>: transparent;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line"><span class="attribute">transition</span>: all .<span class="number">5s</span> ease;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line">&amp;:hover &#123;</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你需要编辑的文章地方。放置如下代码<br><code>&lt;a id=&quot;download&quot; href=&quot;下载链接&quot;&gt;&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt;&lt;span&gt; Download Now&lt;/span&gt; &lt;/a&gt;</code></p><h3 id="利用Aplayer添加音乐播放器"><a href="#利用Aplayer添加音乐播放器" class="headerlink" title="利用Aplayer添加音乐播放器"></a>利用Aplayer添加音乐播放器</h3><p>首先将<a href="https://github.com/MoePlayer/APlayer" rel="external nofollow noopener noreferrer" target="_blank">Aplayer</a>源码下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下<br>新建themes\next\source\dist\music.js文件，添加内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const ap = new APlayer(&#123;</span><br><span class="line">    container: document.getElementById('aplayer'),</span><br><span class="line">    fixed: true,</span><br><span class="line">    autoplay: true, //自动播放</span><br><span class="line">    audio: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: "PDD洪荒之力",</span><br><span class="line">        artist: '徐梦圆',</span><br><span class="line">        url: 'http://up.mcyt.net/?down/39868.mp3',</span><br><span class="line">        cover: 'http://oeff2vktt.bkt.clouddn.com/image/84.jpg',</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: '9420',</span><br><span class="line">        artist: '麦小兜',</span><br><span class="line">        url: 'http://up.mcyt.net/?down/45967.mp3',</span><br><span class="line">        cover: 'http://oeff2vktt.bkt.clouddn.com/image/8.jpg',</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: '风筝误',</span><br><span class="line">        artist: '刘珂矣',</span><br><span class="line">        url: 'http://up.mcyt.net/?down/46644.mp3',</span><br><span class="line">        cover: 'http://oeff2vktt.bkt.clouddn.com/image/96.jpg',</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://aplayer.js.org/#/zh-Hans/" rel="external nofollow noopener noreferrer" target="_blank">Aplayer 中文文档</a></p><p>打开<code>themes\next\layout\_layout.swig</code>文件，将</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/dist/APlayer.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/dist/music.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加到<code>&lt;body itemscope ...&gt;</code>后面就行，即在<code>&lt;body&gt;&lt;/body&gt;</code>里面。<br>重新生成，访问页面，就能看到左下角的音乐播放器了</p><p>添加音乐：audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、封面等）的配置。这里放一个<a href="http://up.mcyt.net/" rel="external nofollow noopener noreferrer" target="_blank">mp3音乐外链网站</a>搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。</p><h3 id="左上角或右上角的Github样式"><a href="#左上角或右上角的Github样式" class="headerlink" title="左上角或右上角的Github样式"></a>左上角或右上角的Github样式</h3><p>实现效果有两种(效果可点击样式链接查看这里就不演示效果图了)：<br><a href="http://tholman.com/github-corners/" rel="external nofollow noopener noreferrer" target="_blank">样式1</a><br><a href="https://github.blog/2008-12-19-github-ribbons/" rel="external nofollow noopener noreferrer" target="_blank">样式2</a><br>在喜欢的网站上复制其中的代码到<code>themes/next/layout/_layout.swig</code>文件中放在<br><code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code> 的下面，并把href改为你的github地址就好了</p><h3 id="添加背景动画"><a href="#添加背景动画" class="headerlink" title="添加背景动画"></a>添加背景动画</h3><p>NexT已经自带了多种背景动画效果，你只需要根据需求在主题配置文件修改其中一个为true即可 想要什么效果自己可以每个试试看。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>其中之一实现效果：</p><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/20.webp" alt="图片消失啦"></p><h3 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h3><p>在主题配置文件中搜索<code>pace</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading. 加载条</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br></pre></td></tr></table></figure><p>这个也有多种主题选择，根据自己喜好选择修改即可</p><h3 id="点击出现小爱心效果"><a href="#点击出现小爱心效果" class="headerlink" title="点击出现小爱心效果"></a>点击出现小爱心效果</h3><p>在<code>/themes/next/source/js/sr</code>c新建<code>clicklove.js</code>文件，复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">! <span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        c(</span><br><span class="line">            <span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span></span><br><span class="line">        ), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; d.length; e++) d[e].alpha &lt;= <span class="number">0</span> ? (t.body.removeChild(d[e].el), d.splice(e, <span class="number">1</span>)) : (d[e].y--,</span><br><span class="line">            d[e].scale += <span class="number">.004</span>, d[e].alpha -= <span class="number">.013</span>, d[e].el.style.cssText = <span class="string">"left:"</span> + d[e].x + <span class="string">"px;top:"</span> + d[e].y +</span><br><span class="line">            <span class="string">"px;opacity:"</span> + d[e].alpha + <span class="string">";transform:scale("</span> + d[e].scale + <span class="string">","</span> + d[e].scale +</span><br><span class="line">            <span class="string">") rotate(45deg);background:"</span> + d[e].color + <span class="string">";z-index:99999"</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t = <span class="string">"function"</span> == <span class="keyword">typeof</span> e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">"div"</span>);</span><br><span class="line">        a.className = <span class="string">"heart"</span>, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - <span class="number">5</span>,</span><br><span class="line">            y: e.clientY - <span class="number">5</span>,</span><br><span class="line">            scale: <span class="number">1</span>,</span><br><span class="line">            alpha: <span class="number">1</span>,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">"style"</span>);</span><br><span class="line">        a.type = <span class="string">"text/css"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t) &#123;</span><br><span class="line">            a.styleSheet.cssText = e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rgb("</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">","</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">","</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d = [];</span><br><span class="line">    e.requestAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame ||</span><br><span class="line">            e.msRequestAnimationFrame || <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                setTimeout(e, <span class="number">1e3</span> / <span class="number">60</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>然后打开<code>\themes\next\layout\_layout.swig</code>文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h3><p>修改文件 <code>\themes\next\source\css\_custom\custom.styl</code> 在末尾添加如下css样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文章底部标签样式"><a href="#修改文章底部标签样式" class="headerlink" title="修改文章底部标签样式"></a>修改文章底部标签样式</h3><p>修改<code>/themes/next/layout/_macro/post.swig</code>搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code><br>实现效果图:</p><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/21.png" alt="图片消失啦"></p><h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p>实现效果图:</p><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/22.png" alt="图片消失啦"><br>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span>-------------本文结束<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>&lt;div class=&quot;post-block&quot;&gt;&lt;/div&gt;中</code> 末尾添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;#感谢阅读#&#125;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line">  <span class="string">&#123;%</span> <span class="string">if</span> <span class="string">not</span> <span class="string">is_index</span> <span class="string">%&#125;</span></span><br><span class="line">    <span class="string">&#123;%</span> <span class="string">include</span> <span class="string">'passage-end-tag.swig'</span> <span class="string">%&#125;</span></span><br><span class="line">  <span class="string">&#123;%</span> <span class="string">endif</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>位置可以根据自己喜欢调整(我的就是放在最后面的)，然后打开主题配置文件（_config.yml）,在末尾添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="设置圆形头像以及旋转效果"><a href="#设置圆形头像以及旋转效果" class="headerlink" title="设置圆形头像以及旋转效果"></a>设置圆形头像以及旋转效果</h3><p>打开<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code><br>在里面添加如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  height 100px; //设置宽高</span><br><span class="line">  border-radius:50%; //圆角</span><br><span class="line">  <span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> <span class="selector-tag">auto</span></span><br><span class="line">  overflow:hidden; //裁剪</span><br><span class="line">  <span class="selector-tag">-webkit-border-radius</span>: 80<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">-moz-border-radius</span>: 80<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">box-shadow</span>: <span class="selector-tag">inset</span> 0 <span class="selector-tag">-1px</span> 0 <span class="selector-id">#333sf</span>;</span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束</span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="selector-tag">-webkit-transition</span>: <span class="selector-tag">-webkit-transform</span> 2<span class="selector-class">.0s</span> <span class="selector-tag">ease-out</span>;</span><br><span class="line">  <span class="selector-tag">-moz-transition</span>: <span class="selector-tag">-moz-transform</span> 2<span class="selector-class">.0s</span> <span class="selector-tag">ease-out</span>;</span><br><span class="line">  <span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 1<span class="selector-class">.0s</span> <span class="selector-tag">ease-out</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转</span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果设置完之后出现名字没居中<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/23.jpg" alt="图片消失啦"><br>需要到<code>themes\next\layout\_macro\sidebar.swig</code>文件中找到<code>site-author-name</code>那一行修改为<code>&lt;p class=&quot;site-author-name&quot; itemprop=&quot;name&quot; style =&quot;text-align: center;&quot;&gt;&lt;/p&gt;</code></p></blockquote><h3 id="文章添加阴影效果"><a href="#文章添加阴影效果" class="headerlink" title="文章添加阴影效果"></a>文章添加阴影效果</h3><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>向里面加入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> <span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 203, .5);</span><br><span class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="代码块自定义样式"><a href="#代码块自定义样式" class="headerlink" title="代码块自定义样式"></a>代码块自定义样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff7600</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fbf7f8</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 边框的自定义样式</span><br><span class="line"><span class="selector-class">.highlight</span>, <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span>, <span class="selector-tag">code</span>, <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d6d6d6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo 强力驱动"></a>隐藏网页底部powered By Hexo 强力驱动</h3><p>打开<code>themes/next/layout/_partials/footer.swig</code>隐藏之间的代码即可，或者直接删除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个地方 &#123;% if theme.footer.powered %&#125;</span></span><br><span class="line"><span class="comment">  &lt;div class="powered-by"&gt;&#123;#</span></span><br><span class="line"><span class="comment">  #&#125;&#123;&#123; __('footer.powered', '&lt;a class="theme-link" target="_blank" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&#123;#</span></span><br><span class="line"><span class="comment">#&#125;&lt;/div&gt; 底部hexo 驱动字</span></span><br><span class="line"><span class="comment">&#123;% endif %&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125;</span></span><br><span class="line"><span class="comment">  &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; 底部hexo 驱动字 |</span></span><br><span class="line"><span class="comment">&#123;% endif %&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个地方&lt;div class="theme-info"&gt;&#123;#</span></span><br><span class="line"><span class="comment">  #&#125;&#123;&#123; __('footer.theme') &#125;&#125; &amp;mdash; &#123;#</span></span><br><span class="line"><span class="comment">  #&#125;&lt;a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next"&gt;&#123;#</span></span><br><span class="line"><span class="comment">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span></span><br><span class="line"><span class="comment">  #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;#</span></span><br><span class="line"><span class="comment">#&#125;&lt;/div&gt; 底部hexo 驱动字--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h3><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在以下位置插入下面代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (prompt(<span class="string">'请输入文章密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>)&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">'密码错误！'</span>);</span></span><br><span class="line"><span class="undefined">                history.back();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在要加密的文章<code>---</code>中间添加<code>password:xxx</code> xxx就是你的密码 不写就没有密码</p><h3 id="文章顶部显示更新时间"><a href="#文章顶部显示更新时间" class="headerlink" title="文章顶部显示更新时间"></a>文章顶部显示更新时间</h3><p>打开主题配置文件<code>_config.yml</code>，关键字搜索<code>updated_at</code>设置为<code>true</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  created_at:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  updated_at:</span> <span class="string">ture</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编辑文章，增加关键字updated（下一个可以根据文章改变时间自动更改）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layout:</span> <span class="string">layout</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-08</span><span class="bullet">-18</span> <span class="number">15</span><span class="string">:41:18</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2017</span><span class="bullet">-09</span><span class="bullet">-05</span> <span class="number">20</span><span class="string">:18:54</span> <span class="comment">#手动添加更新时间</span></span><br></pre></td></tr></table></figure><h3 id="崩溃欺骗"><a href="#崩溃欺骗" class="headerlink" title="崩溃欺骗"></a>崩溃欺骗</h3><p>在新建<code>themes\next\source\js\src</code>新建文件<code>crash_cheat.js</code>代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> OriginTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        $(<span class="string">'[rel="icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/img/TEP.ico"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'╭(°A°`)╮ 页面崩溃啦 ~'</span>;</span><br><span class="line">        clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">'[rel="icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/favicon.ico"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'(ฅ&gt;ω&lt;*ฅ) 噫又好了~'</span> + OriginTitle;</span><br><span class="line">        titleTime = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = OriginTitle;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>themes\next\layout\_layout.swig</code>文件最后添加如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--崩溃欺骗--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/crash_cheat.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="博客性能优化"><a href="#博客性能优化" class="headerlink" title="博客性能优化"></a>博客性能优化</h2><h3 id="gulp压缩"><a href="#gulp压缩" class="headerlink" title="gulp压缩"></a>gulp压缩</h3><blockquote><p>如果你打开生成的public文件夹里面的html、css、js源文件，你就会发现里面有大段的空白，这些空白占据着一定的空间。gulp是一个基于Node.js的自动化构建工具，我们可以通过一些gulp插件实现对html、css、js、image等静态资源的高效压缩，通过压缩这些静态资源，可以减少请求的数据量从而达到优化博客访问速度的目的</p></blockquote><p>首先安装gulp，执行以下命令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">gulp</span></span><br></pre></td></tr></table></figure><p>要实现gulp压缩需要安装以下五个模块：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gulp-htmlclean</span>       <span class="string">//</span> <span class="string">清理html</span></span><br><span class="line"><span class="string">gulp-htmlmin</span>        <span class="string">//</span> <span class="string">压缩html</span></span><br><span class="line"><span class="string">gulp-minify-css</span>     <span class="string">//</span> <span class="string">压缩css</span></span><br><span class="line"><span class="string">gulp-uglify</span>         <span class="string">//</span> <span class="string">混淆js</span></span><br><span class="line"><span class="string">gulp-imagemin</span>     <span class="string">//</span> <span class="string">压缩图片</span></span><br></pre></td></tr></table></figure><p>安装模块</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">gulp-htmlclean</span> <span class="string">gulp-htmlmin</span> <span class="string">gulp-minify-css</span> <span class="string">gulp-uglify</span> <span class="string">gulp-imagemin</span> <span class="bullet">--save</span></span><br></pre></td></tr></table></figure><p>安装的模块可以在根目录下的<code>package.json</code>文件里面看到。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"gulp": "^4.0.0",</span><br><span class="line">"gulp-htmlclean": "^2.7.22",</span><br><span class="line">"gulp-htmlmin": "^5.0.1",</span><br><span class="line">"gulp-imagemin": "^5.0.3",</span><br><span class="line">"gulp-minify-css": "^1.2.4",</span><br><span class="line">"gulp-uglify": "^3.0.1",</span><br></pre></td></tr></table></figure><p>添加<code>gulpfile.js</code><br>进入博客根目录，新建<code>gulpfile.js</code>文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss(&#123;</span><br><span class="line">            compatibility: <span class="string">'ie8'</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/js/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩图片</span></span><br><span class="line">gulp.task(<span class="string">'minify-images'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/images/**/*.*'</span>)</span><br><span class="line">        .pipe(imagemin(</span><br><span class="line">            [imagemin.gifsicle(&#123; <span class="string">'optimizationLevel'</span>: <span class="number">3</span> &#125;),</span><br><span class="line">            imagemin.jpegtran(&#123; <span class="string">'progressive'</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">            imagemin.optipng(&#123; <span class="string">'optimizationLevel'</span>: <span class="number">7</span> &#125;),</span><br><span class="line">            imagemin.svgo()],</span><br><span class="line">            &#123; <span class="string">'verbose'</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/images'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法</span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line"><span class="comment">//  'minify-html', 'minify-css', 'minify-js'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line"><span class="comment">// 会出现The following tasks did not complete: default, &lt;anonymous&gt; Did you forget to signal async completion?报错</span></span><br><span class="line"><span class="comment">// gulp.task('default', gulp.parallel('minify-html', 'minify-css', 'minify-js', 'minify-images', function () &#123;</span></span><br><span class="line"><span class="comment">//     // Do something after a, b, and c are finished.</span></span><br><span class="line"><span class="comment">// &#125;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决报错 2019-4-20号更新</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="string">'minify-images'</span>, (done) =&gt; done()));</span><br></pre></td></tr></table></figure><p>执行压缩（在每次生成部署的时候就要压缩一次）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">gulp</span> <span class="string">//执行压缩</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_41208114/article/details/79109269" rel="external nofollow noopener noreferrer" target="_blank">gulp4.0报错</a> 参考的第三个方案<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Hexo主题Next-优化整理/24.png" alt="还没有图片哦"></p><blockquote><p>在Hexo根目录打开命令行窗口<br>顺序总结为 <code>hexo + clean --&gt; hexo + g --&gt; gulp --&gt; hexo + d --&gt; export HEXO_ALGOLIA_INDEXING_KEY=&#39;764398dfb571b51f25f584fd5f03944b&#39;(你的adminApiKey 这个是我的) --&gt; hexo algolia</code> 如果没有添加搜索的后面两句可以省略 很久没使用可能需要用key来回执行export HEXO_ALGOLIA_INDEXING_KEY=’key’添加才会成功 如果还是不行则<code>npm install --save hexo-algolia</code>更新下algolia即可（推送搜索要翻墙） 不知道什么原因 Algolia不能在VSCode的终端输入命令。2019-5-10因为 images 路径修改到了远程服务器，所以需要每次把 images 文件压缩zip移到服务器进行unzip进行解压，目前没有服务器image暂时看不见。</p></blockquote><p><a href="https://www.cnblogs.com/sunala/p/10437537.html" rel="external nofollow noopener noreferrer" target="_blank">window 系统下安装了 gulp 后遇到 bash: gulp: command not found 这个问题的解决方法</a></p><blockquote><p>或者重新安装一次gulp模块即可</p></blockquote><h3 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h3><p>全部参考如下:<br><a href="https://www.jianshu.com/p/1f8107a8778c" rel="external nofollow noopener noreferrer" target="_blank">hexo搭建个人博客–NexT主题优化</a><br><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" rel="external nofollow noopener noreferrer" target="_blank">Hexo+NexT 主题配置备忘</a><br><a href="https://blog.csdn.net/qq_33699981/article/details/72716951" rel="external nofollow noopener noreferrer" target="_blank">hexo的next主题个性化教程：打造炫酷网站</a><br><a href="https://www.jianshu.com/p/efbeddc5eb19" rel="external nofollow noopener noreferrer" target="_blank">HEXO +下一步个人博客主题优化</a><br><a href="https://www.jianshu.com/p/93b63852f0b3" rel="external nofollow noopener noreferrer" target="_blank">Hexo博客之速度优化</a><br><a href="https://blog.csdn.net/java_1996/article/details/86499625" rel="external nofollow noopener noreferrer" target="_blank">基于Hexo搭建个人博客优化之（五）压缩篇–gulp4.0压缩静态资源</a></p>]]></content>
    
    <summary type="html">
    
      优化Hexo主题Next
    
    </summary>
    
      <category term="Hexo" scheme="http://www.tjl-myblog.cn/categories/Hexo/"/>
    
    
      <category term="Next优化" scheme="http://www.tjl-myblog.cn/tags/Next%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AlaSQL介绍</title>
    <link href="http://www.tjl-myblog.cn/AlaSQL%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://www.tjl-myblog.cn/AlaSQL介绍.html</id>
    <published>2019-01-18T10:39:09.000Z</published>
    <updated>2019-12-21T11:04:47.912Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p><a href="http://alasql.org/" rel="external nofollow noopener noreferrer" target="_blank">AlaSQL官网</a></p><blockquote><p>下载然后倒入到自己的js脚本即可使用 官网也给了代码</p></blockquote>]]></content>
    
    <summary type="html">
    
      AlaSQL 是一个开源SQL数据库为Javascript的强烈关注于查询速度和数据源灵活性为关系数据和无模式的数据 推荐自己练习SQL语法的时候使用
    
    </summary>
    
      <category term="SQL" scheme="http://www.tjl-myblog.cn/categories/SQL/"/>
    
    
      <category term="AlaSQL" scheme="http://www.tjl-myblog.cn/tags/AlaSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语法中AS中的作用及用法</title>
    <link href="http://www.tjl-myblog.cn/SQL%E8%AF%AD%E6%B3%95%E4%B8%ADAS%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95.html"/>
    <id>http://www.tjl-myblog.cn/SQL语法中AS中的作用及用法.html</id>
    <published>2019-01-18T09:19:27.000Z</published>
    <updated>2019-12-21T11:04:47.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><p>as是别名的关键字，一般这样使用： <code>select  字段  as  别名  from  表名</code></p><p>别名也可以这样定义：<code>select  字段 别名  from  表名</code></p><p>给字段起别名的时候  <code>as</code> 可写可不写  <code>select  字段  as  别名  from  表名</code>相等于<code>select  字段 别名  from  表名</code></p><p>起别名主要是为了其他开发人员方便看懂字段的含义。</p><p><a href="https://www.cnblogs.com/zhaotiancheng/p/6692553.html" rel="external nofollow noopener noreferrer" target="_blank">sql语句中as的用法和作用</a></p>]]></content>
    
    <summary type="html">
    
      MySQL的语法基础
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="MySQL中的AS" scheme="http://www.tjl-myblog.cn/tags/MySQL%E4%B8%AD%E7%9A%84AS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程语法基础</title>
    <link href="http://www.tjl-myblog.cn/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80.html"/>
    <id>http://www.tjl-myblog.cn/mysql存储过程语法基础.html</id>
    <published>2019-01-17T04:28:34.000Z</published>
    <updated>2019-12-21T11:04:47.927Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>由于博主水平有限 下面语法记录有不对还请留下你珍贵的意见</p></blockquote><h2 id="mysql的基础数据类型"><a href="#mysql的基础数据类型" class="headerlink" title="mysql的基础数据类型"></a>mysql的基础数据类型</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INT</td><td style="text-align:center">整型</td><td style="text-align:center">4字节整数类型，范围约+/-21亿</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">长整型</td><td style="text-align:center">8字节整数类型，范围约+/-922亿亿</td></tr><tr><td style="text-align:center">REAL</td><td style="text-align:center">浮点型</td><td style="text-align:center">4字节浮点数，范围约+/-1038</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">浮点型</td><td style="text-align:center">8字节浮点数，范围约+/-10308</td></tr><tr><td style="text-align:center">DECIMAL</td><td style="text-align:center">(M,N)高精度小数</td><td style="text-align:center">由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td style="text-align:center">CHAR(N)</td><td style="text-align:center">定长字符串</td><td style="text-align:center">存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td style="text-align:center">VARCHAR(N)</td><td style="text-align:center">变长字符串</td><td style="text-align:center">存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td style="text-align:center">BOOLEAN</td><td style="text-align:center">布尔类型</td><td style="text-align:center">存储True或者False</td></tr><tr><td style="text-align:center">DATE</td><td style="text-align:center">日期类型</td><td style="text-align:center">存储日期，例如，2018-06-22</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">时间类型</td><td style="text-align:center">存储时间，例如，12:20:59</td></tr><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">日期和时间类型</td><td style="text-align:center">存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><h1 id="基础关键语法"><a href="#基础关键语法" class="headerlink" title="基础关键语法"></a>基础关键语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   DELIMITER <span class="comment">--  声明语句结束符，用于区分;</span></span><br><span class="line">   <span class="keyword">DECLARE</span> n_sid <span class="built_in">INT</span> ; <span class="comment">-- 使用了 DECLARE 声明出来的变量 要用 into 进行赋值 下面就是一个例子 把 t_span_rank_babao_furnace 表中查到 的a_sid 赋值给 n_sid</span></span><br><span class="line"><span class="keyword">select</span> a_sid <span class="keyword">into</span> n_sid <span class="keyword">from</span> t_span_rank_babao_furnace <span class="keyword">where</span> <span class="keyword">sid</span> = _sid;</span><br><span class="line"></span><br><span class="line">   CEATE PROCEDURE demo_in_parameter(IN p_in int) <span class="comment">-- 声明创建存储过程</span></span><br><span class="line">   <span class="keyword">BEGIN</span> …. <span class="keyword">END</span> <span class="comment">-- 存储过程开始和结束符号</span></span><br><span class="line">   <span class="keyword">SET</span> @p_in=<span class="number">1</span> <span class="comment">-- 变量赋值</span></span><br><span class="line">   <span class="keyword">DECLARE</span> l_int <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">4000000</span>; <span class="comment">-- 变量定义(默认值为4000000) 这里要注意 变量类型在最后哦 习惯了c或其他语言可能会不习惯</span></span><br></pre></td></tr></table></figure><p>ps：在写sql存储过程的时候sql的关键字尽量都用大写</p><h2 id="存储过程与各种变量"><a href="#存储过程与各种变量" class="headerlink" title="存储过程与各种变量"></a>存储过程与各种变量</h2><p><a href="https://blog.csdn.net/yao5hed/article/details/81059806" rel="external nofollow noopener noreferrer" target="_blank">参考</a></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量只在BEGIN … END 代码块中有效，执行完代码块变量就会消失，在存储过程中最为常见的变量 DELIMITER是专门用来定义局部变量的可以使用DEFAULT来指定变量的默认值<br><code>DELIMITER x，y INT DEFAULT 100;</code> 定义了INT类型的变量x，y 并且赋予默认值为100 赋值用SET 或 SELECT<br>赋值例：<br>SELECT … INTO 语句  这个SELECT语法把选定的值直接存储到变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> total_count <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; <span class="comment">-- 定义了INT类型变量total_count 默认值给予0</span></span><br><span class="line"><span class="keyword">SET</span> total_count = <span class="number">10</span>; <span class="comment">-- 把10赋值给INT类型变量total_count</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> total_count <span class="keyword">FROM</span> products; <span class="comment">-- COUNT(*) 查找products表中的行数 把他赋值给total_count</span></span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p1(<span class="keyword">IN</span> a <span class="built_in">INT</span>,<span class="keyword">IN</span> b <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> c <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; <span class="comment">-- 定义一个INT类型的变量c 默认值为0</span></span><br><span class="line">    <span class="keyword">SET</span> c = a + b;</span><br><span class="line">    <span class="keyword">SELECT</span> c <span class="keyword">AS</span> <span class="keyword">num</span>; <span class="comment">-- 为c取'别名'</span></span><br><span class="line"><span class="keyword">END</span>;$$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>总结：这里的c就是局部变量</p><p><a href="http://www.tjl-myblog.cn/SQL语法中AS中的作用及用法.html">SQL语法中AS中的作用及用法</a></p><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>用户变量与数据库的连接有关（一个客户端定义的变量不能被其他客户端使用）当客户端连接断开退出时，该客户端的变量将全部失效。用户变量不需要声明，可以直接使用，定义用户变量时变量名前必须要加@。<br>赋值例(一般用SET)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @varName = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @var_name := <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>注1：”=”是比较操作符，判断两边参数是否相等，或者在更新语句中进行赋值<br>注2：“：=”主要是用于传递外部参数为语句中变量赋值<br>注3：赋值后输出用：SELECT @varName<br>注4：@c=@b*2是正确的，@b=@b+1是错误的，但SET @b=@b+1是正确的，这一点不像C++</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>mysql可以访问许多系统变量。当服务器运行时许多变量允许动态更改，这样就可以在不重启服务器就可以完成更新了。系统变量又包含两种：会话变量(影响具体客户端连接操作)，全局变量(影响服务器整体操作)</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量在mysql启动的时候由服务器初始化他们的值，这些默认值可以在/etc/my.cnf中修改。想要更改全局变量的值需要SUPER权限。全局变量作用域SERVER的生命周期，当服务器重启后所有全局变量值都失效，要想要全局变量在重启后生效，需要更改相应的配置文件<br>查看全局变量例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">variables</span>; <span class="comment">-- 变量太多，一般不用</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">`搜索条件`</span>;</span><br></pre></td></tr></table></figure><p>修改全局变量例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> varname = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">SET</span> @@GLOBAL.varname = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><h3 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h3><p>会话变量在每个数据库连接建立后，有mysql来初始化。mysql会将当前所有的全局变量都复制一份作为会话变量，相当于在建立会话之后，如果没有更改过会话变量与全局变量的值，那么这两份变量的值是完全一致的。设置会话变量不需要特殊权限，会话变量的作用域与用户变量一样，仅限于当前连接客户端。<br>查看会话变量例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SESSION</span> <span class="keyword">variables</span>; <span class="comment">-- 变量太多，一般不用</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">`搜索条件`</span>;</span><br></pre></td></tr></table></figure><p>修改会话变量例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> varname = <span class="keyword">value</span>; <span class="comment">-- 变量太多，一般不用</span></span><br><span class="line"><span class="keyword">SET</span> @@SESSION.varname = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>SESSION关键字，都可以用LOCAL关键字来代替。</p><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><pre><code>CREATE PROCEDURE proc_first 不带参数BEGIN    ...sql语句ENDCREATE PROCEDURE proc_first(OUT p INT) 带参数BEGIN    ...sql语句END</code></pre><p>下面是存储过程的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc1(<span class="keyword">OUT</span> s <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> s <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">-- 注1：如果有多个参数有，分开</span></span><br><span class="line"><span class="comment">-- 注2：COUNT(*) 函数返回表中的记录数</span></span><br><span class="line"><span class="comment">-- 注3：SELECT COUNT(*) INTO s FROM user;把user的值赋值给s</span></span><br></pre></td></tr></table></figure><h3 id="存储过程参数（in）"><a href="#存储过程参数（in）" class="headerlink" title="存储过程参数（in）"></a>存储过程参数（in）</h3><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/mysql存储过程语法基础一/1.jpg" alt="&#39;存储过程参数&#39;"><br>存储过程 “in” 参数：跟 C 语言的函数参数的值传递类似， 存储过程内部可能会修改此参数，但对 in 类型参数的修改，对调用者（caller）来说是不可见的（not visible）。<br>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> demo_in_parameter(<span class="keyword">IN</span> p_in <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SET</span> p_in = <span class="number">2</span>;<span class="comment">-- 赋值</span></span><br><span class="line">    <span class="keyword">SELECT</span> p_in;<span class="comment">-- 接收p_in的值</span></span><br><span class="line"><span class="keyword">END</span>; $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @p_in = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">CALL</span> demo_in_parameter(@p_in);</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_in |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  1   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_in |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  2   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_in;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_in |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  1   |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure><p>总结：以上可以看出，p_in虽然在存储过程中改变了值 但是并不影响外部@p_in的值(值传递)</p><h3 id="存储过程参数（out）"><a href="#存储过程参数（out）" class="headerlink" title="存储过程参数（out）"></a>存储过程参数（out）</h3><p>存储过程 “out” 参数：从存储过程内部传值给调用者。在存储过程内部，该参数初始值为 null，无论调用者是否给存储过程参数设置值<br>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> demo_out_paremter(<span class="keyword">OUT</span> p_out <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> p_out; <span class="comment">-- 定义变量 后面没有给他赋值 默认为NULL</span></span><br><span class="line">    <span class="keyword">SET</span> p_out = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> p_out;</span><br><span class="line"><span class="keyword">END</span>; $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @p_out = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">CALL</span> demo_out_paremter(@p_out);</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_out|</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  NULL|</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_out|</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  2   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_out;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_out|</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  1   |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure><p>总结：由以上可以看出第一个值是为NULL 因为使用OUT参数时他会忽略掉所有的实际参数值 他会在存储过程内部进行赋值 然后存储过程结束后他会把值返回出去</p><h3 id="存储过程参数（inout）"><a href="#存储过程参数（inout）" class="headerlink" title="存储过程参数（inout）"></a>存储过程参数（inout）</h3><p>存储过程 inout 参数跟 out 类似，都可以从存储过程内部传值给调用者。不同的是：调用者还可以通过 inout 参数传递值给存储过程。<br>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> demo_inout_paremter(INOUT p_inout <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> p_inout; <span class="comment">-- 定义变量 后面没有给他赋值 默认为NULL</span></span><br><span class="line">    <span class="keyword">SET</span> p_inout = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> p_inout;</span><br><span class="line"><span class="keyword">END</span>; $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @p_inout = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">CALL</span> demo_inout_paremter(@p_inout);</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|p_inout|</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|  1    |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|p_inout|</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|  2    |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"><span class="keyword">SELECT</span> @p_inout;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|p_inout|</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|  2    |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure><p>总结：存储过程 inout 参数的行为跟 C 语言函数中的引用传值类似</p><blockquote><p>通过以上例子：如果仅仅想把数据传给 MySQL 存储过程，那就使用“in” 类型参数；如果仅仅从 MySQL 存储过程返回值，那就使用“out” 类型参数；如果需要把数据传给 MySQL 存储过程，还要经过一些计算后再传回给我们，此时，要使用“inout” 类型参数。</p></blockquote><h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DROP PROCEDURE tablename;(这里表后面没括号)如果指定的过程不存在，则将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用</span></span><br><span class="line"><span class="comment">DROP PROCEDURE IF EXISTS （tablename）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 如果proc_first存在就删</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> proc_first;</span><br><span class="line"><span class="comment">-- 注：IF EXISTS(相当于if())</span></span><br></pre></td></tr></table></figure><h2 id="存储过程调用"><a href="#存储过程调用" class="headerlink" title="存储过程调用"></a>存储过程调用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名字() 后面的括号必不可少</span><br></pre></td></tr></table></figure><h2 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> 存储过程名</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SQL</span>语句代码块</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="查看一个已存在的存储过程"><a href="#查看一个已存在的存储过程" class="headerlink" title="查看一个已存在的存储过程"></a>查看一个已存在的存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名</span><br></pre></td></tr></table></figure><h2 id="列出所有的存储过程"><a href="#列出所有的存储过程" class="headerlink" title="列出所有的存储过程"></a>列出所有的存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span>  <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span></span><br></pre></td></tr></table></figure><h2 id="设置安全验证方式"><a href="#设置安全验证方式" class="headerlink" title="设置安全验证方式"></a>设置安全验证方式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQL SECURITY &#123; DEFINER | INVOKER &#125; ：指明谁有权限来执行。</span><br><span class="line">DEFINER：表示按定义者拥有的权限来执行(默认为当前用户)</span><br><span class="line">INVOKER：表示用调用者的权限来执行。默认情况下，系统指定为DEFINER</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`username`</span>@<span class="string">`localhost`</span> <span class="keyword">PROCEDURE</span> <span class="string">`test`</span>()</span><br><span class="line">    <span class="keyword">SQL</span> <span class="keyword">SECURITY</span> INVOKER</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">sql</span>代码块</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>总结：任意用户X访问此VIEW时，能否成功取决于X是否有调用该VIEW的权限，以及DEFINER是否有VIEW中的SELECT的权限。只需要修改创建同名用户或者修改DEFINER即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> DEFINER = <span class="string">'xx'</span>@<span class="string">'localhost'</span> <span class="keyword">view</span> xxxx <span class="keyword">as</span> ...</span><br></pre></td></tr></table></figure><h2 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    [statement_list]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">[end_label]</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> doiterate(p1 <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">label1: <span class="keyword">LOOP</span></span><br><span class="line">    <span class="keyword">SET</span> p1 = p1 + <span class="number">1</span>;</span><br><span class="line">    IF p1 &lt; 10 THEN</span><br><span class="line">        ITERATE label1; <span class="comment">-- 继续迭代</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">    LEAVE label1; <span class="comment">-- 终止循环</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> label1;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>存储子程序可以使用BEGIN … END复合语句来包含多个语句。<br>statement_list 代表一个或多个语句的列表。statement_list之内每个语句都必须用分号（；）来结尾。<br>复合语句可以被标记(有特殊含义 上面的loop意思就是重复执行begin … end的代码块 LEAVE退出)。除非begin_label存在,否则end_label不能被给出,并且如果二者都存在,他们必须是同样的。<br><a href="https://dev.mysql.com/doc/refman/8.0/en/statement-labels.html" rel="external nofollow noopener noreferrer" target="_blank">mysql官网语法</a></p><h1 id="MySQL存储过程的控制语句"><a href="#MySQL存储过程的控制语句" class="headerlink" title="MySQL存储过程的控制语句"></a>MySQL存储过程的控制语句</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>内部的变量在其作用域范围内享有更高的优先权，当执行到end。变量时，内部变量消失，此时已经在其作用域外，变量不再可见了，应为在存储过程外再也不能找到这个申明的变量，但是你可以通过out参数或者将其值指派给会话变量来保存其值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc3()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> x1 <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">DEFAULT</span> <span class="string">'outer'</span>;</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> x2 <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">DEFAULT</span> <span class="string">'inner'</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> x1;</span><br><span class="line">    <span class="keyword">END</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> x1;</span><br><span class="line">    <span class="keyword">SELECT</span> x2; <span class="comment">-- 读取不到</span></span><br><span class="line"><span class="keyword">END</span>;$$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line"></span><br><span class="line">    DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc2(<span class="keyword">IN</span> parameter <span class="built_in">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> <span class="keyword">var</span> <span class="built_in">INT</span>;</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">var</span> = parameter+<span class="number">1</span>;</span><br><span class="line">        IF var = 0 THEN</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">17</span>); <span class="comment">-- 插入</span></span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">        IF parameter=0 THEN</span><br><span class="line">            <span class="keyword">UPDATE</span> t <span class="keyword">SET</span> s1=s1+<span class="number">1</span>; <span class="comment">-- 更新</span></span><br><span class="line">        ELSE</span><br><span class="line">            <span class="keyword">UPDATE</span> t <span class="keyword">SET</span> s1=s1+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">END</span>;$$</span><br><span class="line">    DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>IF NOT EXISTS 即如果不存在 IF EXISTS 即如果存在</li></ul><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line"></span><br><span class="line">    DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc3 (<span class="keyword">IN</span> parameter <span class="built_in">INT</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> <span class="keyword">var</span> <span class="built_in">INT</span>;</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">var</span> = parameter + <span class="number">1</span>;</span><br><span class="line">        CASE</span><br><span class="line">        WHEN 0 THEN</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">17</span>);</span><br><span class="line">        WHEN 1 THEN</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">18</span>);</span><br><span class="line">        ELSE</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">into</span> t <span class="keyword">VALUES</span>(<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line">    <span class="keyword">END</span>;$$</span><br><span class="line">    DELIMITER;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">    CASE</span><br><span class="line">    WHEN var=0 THEN</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">30</span>);</span><br><span class="line">    WHEN var&gt;0 THEN</span><br><span class="line">    WHEN var&lt;0 THEN</span><br><span class="line">    ELSE</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">CASE</span></span><br></pre></td></tr></table></figure><h3 id="循环1"><a href="#循环1" class="headerlink" title="循环1"></a>循环1</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WHILE ···· <span class="keyword">END</span> <span class="keyword">WHILE</span></span><br><span class="line"></span><br><span class="line">    DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc4()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> <span class="keyword">var</span> <span class="built_in">INT</span>;</span><br><span class="line">        <span class="keyword">SET</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">        WHILE var &lt; 6 DO</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="keyword">var</span>);</span><br><span class="line">            <span class="keyword">SET</span> <span class="keyword">var</span> = <span class="keyword">var</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">    <span class="keyword">END</span>;$$</span><br><span class="line">    DELIMITER ;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">    WHILE 条件 <span class="keyword">DO</span></span><br><span class="line">        <span class="comment">--循环体</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span></span><br></pre></td></tr></table></figure><h3 id="循环2"><a href="#循环2" class="headerlink" title="循环2"></a>循环2</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">REPEAT···· <span class="keyword">END</span> <span class="keyword">REPEAT</span></span><br><span class="line">它在执行操作后检查结果，而<span class="keyword">while</span>则是执行前进行检查</span><br><span class="line"></span><br><span class="line">    DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc5 ()</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">DECLARE</span> v <span class="built_in">INT</span>;</span><br><span class="line">        <span class="keyword">SET</span> v = <span class="number">0</span>;</span><br><span class="line">        REPEAT</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(v);</span><br><span class="line">            <span class="keyword">SET</span> v = v + <span class="number">1</span>;</span><br><span class="line">        UNTIL v &gt; = 5</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">    <span class="keyword">END</span>; $$</span><br><span class="line">    DELIMITER ;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">    REPEAT</span><br><span class="line">        <span class="comment">--循环体</span></span><br><span class="line">    UNTIL 循环条件</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure><p>MySQL中的while循环和repeat循环的区别</p><ul><li>while是满足条件才执行循环，repeat是满足条件退出循环；</li><li>while在首次循环执行之前就判断条件，最少执行0次，repeat是在首次执行循环之后才判断条件，循环至少执行一次。</li></ul><h3 id="循环3"><a href="#循环3" class="headerlink" title="循环3"></a>循环3</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOOP ·····<span class="keyword">END</span> <span class="keyword">LOOP</span></span><br><span class="line"><span class="keyword">loop</span>循环不需要初始条件，这点和<span class="keyword">while</span> 循环相似，LEAVE语句的意义是离开循环。</span><br><span class="line"></span><br><span class="line">    DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc6 ()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> v <span class="built_in">INT</span>;</span><br><span class="line">        <span class="keyword">SET</span> v=<span class="number">0</span>;</span><br><span class="line">        LOOP_LABLE:LOOP <span class="comment">-- 标签开始</span></span><br><span class="line">            NSERT INTO t VALUES(v);</span><br><span class="line">            <span class="keyword">SET</span> v = v + <span class="number">1</span>;</span><br><span class="line">            IF v &gt;= 5 THEN</span><br><span class="line">                LEAVE LOOP_LABLE; <span class="comment">-- 退出循环</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>; <span class="comment">-- 标签结束</span></span><br><span class="line">    <span class="keyword">END</span>;$$</span><br><span class="line">    DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p>LABLES<br>标号可以用在BEGIN REPEAT WHILE 或者LOOP 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ITERATE</span><br><span class="line"></span><br><span class="line">    DELIMITER $$</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc10 ()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> v <span class="built_in">INT</span>;</span><br><span class="line">        <span class="keyword">SET</span> v = <span class="number">0</span>;</span><br><span class="line">        LOOP_LABLE:LOOP <span class="comment">-- 标签开始</span></span><br><span class="line">            IF v = 3 THEN</span><br><span class="line">                <span class="keyword">SET</span> v = v + <span class="number">1</span>;</span><br><span class="line">                ITERATE LOOP_LABLE;</span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">SET</span> v = v + <span class="number">1</span>;</span><br><span class="line">            IF v &gt;= 5 THEN</span><br><span class="line">                LEAVE LOOP_LABLE; <span class="comment">-- 退出循环</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">LOOP</span>; <span class="comment">-- 标签结束</span></span><br><span class="line">    <span class="keyword">END</span>;$$</span><br><span class="line">    DELIMITER ;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> LOOPLoopProc$$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> LOOPLoopProc()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">            <span class="keyword">DECLARE</span> x  <span class="built_in">INT</span>;</span><br><span class="line">            <span class="keyword">DECLARE</span> <span class="keyword">str</span>  <span class="built_in">VARCHAR</span>(<span class="number">255</span>);</span><br><span class="line">            <span class="keyword">SET</span> x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">SET</span> <span class="keyword">str</span> =  <span class="string">''</span>;</span><br><span class="line">            loop_label:  LOOP</span><br><span class="line">                        IF  x &gt; 10 THEN</span><br><span class="line">                            LEAVE  loop_label;</span><br><span class="line">                        <span class="keyword">END</span>  <span class="keyword">IF</span>;</span><br><span class="line">                        <span class="keyword">SET</span>  x = x + <span class="number">1</span>;</span><br><span class="line">                        IF  (x mod 2) THEN</span><br><span class="line">                            ITERATE  loop_label;</span><br><span class="line">                        ELSE</span><br><span class="line">                            <span class="keyword">SET</span>  <span class="keyword">str</span> = <span class="keyword">CONCAT</span>(<span class="keyword">str</span>,x,<span class="string">','</span>);</span><br><span class="line">                        <span class="keyword">END</span>  <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">            <span class="keyword">SELECT</span> <span class="keyword">str</span>;</span><br><span class="line">    <span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>在上面存储过程中我们首先在LOOP语句开始前声明了一个loop_label，然后在if语句总判断变量x是否大于10，如果大于10会使用LEAVE语句退出循环，而如果x是奇数时则会回到循环开始继续执行，这有点像continue语句，否则对str执行concat操作，并进入下一次循环</p><p>总结：LOOP、LEAVE、ITERATE更像其他编程语言中的goto语句。 LOOP要设定一个label指定循环的开始位置，而LEAVE则像其他语言中的break会离开LOOP指定的块，ITERATE则会再次回到LOOP开始的语句</p><h1 id="MySQL存储过程的基本函数"><a href="#MySQL存储过程的基本函数" class="headerlink" title="MySQL存储过程的基本函数"></a>MySQL存储过程的基本函数</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    CHARSET(str) <span class="comment">-- 返回字串字符集</span></span><br><span class="line">    CONCAT (string2 [,... ]) <span class="comment">-- 连接字串</span></span><br><span class="line">    INSTR (string ,substring ) <span class="comment">-- 返回substring首次在string中出现的位置,不存在返回0</span></span><br><span class="line">    LCASE (string2 ) <span class="comment">-- 转换成小写</span></span><br><span class="line">    LEFT (string2 ,length ) <span class="comment">-- 从string2中的左边起取length个字符</span></span><br><span class="line">    LENGTH (string ) <span class="comment">-- string长度</span></span><br><span class="line">    LOAD_FILE (file_name ) <span class="comment">-- 从文件读取内容</span></span><br><span class="line">    LOCATE (substring , string [,start_position ] ) <span class="comment">-- 同INSTR,但可指定开始位置</span></span><br><span class="line">    LPAD (string2 ,length ,pad ) <span class="comment">-- 重复用pad加在string开头,直到字串长度为length</span></span><br><span class="line">    LTRIM (string2 ) <span class="comment">-- 去除前端空格</span></span><br><span class="line">    REPEAT (string2 ,count ) <span class="comment">-- 重复count次</span></span><br><span class="line">    <span class="keyword">REPLACE</span> (<span class="keyword">str</span> ,search_str ,replace_str ) <span class="comment">-- 在str中用replace_str替换search_str</span></span><br><span class="line">    RPAD (string2 ,<span class="keyword">length</span> ,<span class="keyword">pad</span>) <span class="comment">-- 在str后用pad补充,直到长度为length</span></span><br><span class="line">    <span class="keyword">RTRIM</span> (string2 ) <span class="comment">-- 去除后端空格</span></span><br><span class="line">    <span class="keyword">STRCMP</span> (string1 ,string2 ) <span class="comment">-- 逐字符比较两字串大小,</span></span><br><span class="line">    <span class="keyword">SUBSTRING</span> (<span class="keyword">str</span> , <span class="keyword">position</span> [,<span class="keyword">length</span> ]) <span class="comment">-- 从str的position开始,取length个字符,</span></span><br><span class="line">注：mysql中处理字符串时，默认第一个字符下标为<span class="number">1</span>，即参数<span class="keyword">position</span>必须大于等于<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">substring</span>(<span class="string">'abcd'</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    +<span class="comment">-----------------------+</span></span><br><span class="line">    | substring('abcd',0,2) |</span><br><span class="line">    +<span class="comment">-----------------------+</span></span><br><span class="line">    |                       |</span><br><span class="line">    +<span class="comment">-----------------------+</span></span><br><span class="line">    1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">substring</span>(<span class="string">'abcd'</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    +<span class="comment">-----------------------+</span></span><br><span class="line">    | substring('abcd',1,2) |</span><br><span class="line">    +<span class="comment">-----------------------+</span></span><br><span class="line">    |     ab                |</span><br><span class="line">    +<span class="comment">-----------------------+</span></span><br><span class="line">    1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">TRIM</span>([[<span class="keyword">BOTH</span>|<span class="keyword">LEADING</span>|TRAILING][padding] <span class="keyword">FROM</span>]string2) <span class="comment">-- 去除指定位置的指定字符</span></span><br><span class="line">    <span class="keyword">UCASE</span> (string2 ) <span class="comment">-- 转换成大写</span></span><br><span class="line">    <span class="keyword">RIGHT</span>(string2,<span class="keyword">length</span>) <span class="comment">-- 取string2最后length个字符</span></span><br><span class="line">    <span class="keyword">SPACE</span>(<span class="keyword">count</span>) <span class="comment">-- 生成count个空格</span></span><br></pre></td></tr></table></figure><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    ABS (number2 ) <span class="comment">-- 绝对值</span></span><br><span class="line">    BIN (decimal_number ) <span class="comment">-- 十进制转二进制</span></span><br><span class="line">    CEILING (number2 ) <span class="comment">-- 向上取整</span></span><br><span class="line">    CONV(number2,from_base,to_base) <span class="comment">-- 进制转换</span></span><br><span class="line">    FLOOR (number2 ) <span class="comment">-- 向下取整</span></span><br><span class="line">    FORMAT (number,decimal_places ) <span class="comment">-- 保留小数位数</span></span><br><span class="line">    HEX (DecimalNumber ) <span class="comment">-- 转十六进制</span></span><br><span class="line">    注：HEX()中可传入字符串，则返回其ASC-11码，如HEX('DEF')返回4142143</span><br><span class="line">    也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19</span><br><span class="line">    LEAST (number , number2 [,..]) <span class="comment">-- 求最小值</span></span><br><span class="line">    MOD (numerator ,denominator ) <span class="comment">-- 求余</span></span><br><span class="line">    POWER (number ,power ) <span class="comment">-- 求指数</span></span><br><span class="line">    RAND([seed]) <span class="comment">-- 随机数</span></span><br><span class="line">    ROUND (number [,decimals ]) <span class="comment">-- 四舍五入,decimals为小数位数]</span></span><br><span class="line">注：返回类型并非均为整数，如：</span><br><span class="line"></span><br><span class="line">    (1)默认变为整形值</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">1.23</span>);</span><br><span class="line">    +<span class="comment">-------------+</span></span><br><span class="line">    | round(1.23) |</span><br><span class="line">    +<span class="comment">-------------+</span></span><br><span class="line">    |           1 |</span><br><span class="line">    +<span class="comment">-------------+</span></span><br><span class="line">    1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">1.56</span>);</span><br><span class="line">    +<span class="comment">-------------+</span></span><br><span class="line">    | round(1.56) |</span><br><span class="line">    +<span class="comment">-------------+</span></span><br><span class="line">    |           2 |</span><br><span class="line">    +<span class="comment">-------------+</span></span><br><span class="line">    1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">    (<span class="number">2</span>)可以设定小数位数，返回浮点型数据</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">1.567</span>,<span class="number">2</span>);</span><br><span class="line">    +<span class="comment">----------------+</span></span><br><span class="line">    | round(1.567,2)</span><br><span class="line">    +<span class="comment">----------------+</span></span><br><span class="line">    |           1.57 |</span><br><span class="line">    +<span class="comment">----------------+</span></span><br><span class="line">    1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SIGN</span> (number2 ) <span class="comment">-- 返回参数作为-1、0或1的符号，该符号取决于number2的值为负、零或正</span></span><br></pre></td></tr></table></figure><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ADDTIME (date2 ,time_interval )<span class="comment">-- 将time_interval加到date2</span></span><br><span class="line">CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) <span class="comment">-- 转换时区</span></span><br><span class="line">CURRENT_DATE ( ) <span class="comment">-- 当前日期</span></span><br><span class="line">CURRENT_TIME ( ) <span class="comment">-- 当前时间</span></span><br><span class="line">CURRENT_TIMESTAMP ( ) <span class="comment">-- 当前时间戳</span></span><br><span class="line">DATE (datetime ) <span class="comment">-- 返回datetime的日期部分</span></span><br><span class="line">DATE_ADD (date2 , INTERVAL d_value d_type ) <span class="comment">-- 在date2中加上日期或时间</span></span><br><span class="line">DATE_FORMAT (datetime ,FormatCodes ) <span class="comment">-- 使用formatcodes格式显示datetime</span></span><br><span class="line">DATE_SUB (date2 , INTERVAL d_value d_type ) <span class="comment">-- 在date2上减去一个时间</span></span><br><span class="line">DATEDIFF (date1 ,date2 ) <span class="comment">-- 两个日期差</span></span><br><span class="line">DAY (date ) <span class="comment">-- 返回日期的天</span></span><br><span class="line">DAYNAME (date ) <span class="comment">-- 英文星期</span></span><br><span class="line">DAYOFWEEK (date ) <span class="comment">-- 星期(1-7) ,1为星期天</span></span><br><span class="line">DAYOFYEAR (date ) <span class="comment">-- 一年中的第几天</span></span><br><span class="line">EXTRACT (interval_name FROM date ) <span class="comment">-- 从date中提取日期的指定部分</span></span><br><span class="line">MAKEDATE (year ,day ) <span class="comment">-- 给出年及年中的第几天,生成日期串</span></span><br><span class="line">MAKETIME (hour ,minute ,second ) <span class="comment">-- 生成时间串</span></span><br><span class="line">MONTHNAME (date ) <span class="comment">-- 英文月份名</span></span><br><span class="line">NOW ( ) <span class="comment">-- 当前时间</span></span><br><span class="line">SEC_TO_TIME (seconds ) <span class="comment">-- 秒数转成时间</span></span><br><span class="line">STR_TO_DATE (string ,format ) <span class="comment">-- 字串转成时间,以format格式显示</span></span><br><span class="line">TIMEDIFF (datetime1 ,datetime2 ) <span class="comment">-- 两个时间差</span></span><br><span class="line">TIME_TO_SEC (time ) <span class="comment">-- 时间转秒数]</span></span><br><span class="line">WEEK (date_time [,start_of_week ]) <span class="comment">-- 第几周</span></span><br><span class="line">YEAR (datetime ) <span class="comment">-- 年份</span></span><br><span class="line">DAYOFMONTH(datetime) <span class="comment">-- 月的第几天</span></span><br><span class="line">HOUR(datetime) <span class="comment">-- 小时</span></span><br><span class="line">LAST_DAY(date) <span class="comment">-- date的月的最后日期</span></span><br><span class="line">MICROSECOND(datetime) <span class="comment">-- 微秒</span></span><br><span class="line">MONTH(datetime) <span class="comment">-- 月</span></span><br><span class="line">MINUTE(datetime) <span class="comment">-- 分返回符号,正负或0</span></span><br><span class="line">SQRT(number2) <span class="comment">-- 开平方</span></span><br></pre></td></tr></table></figure><h2 id="MySql分页存储过程"><a href="#MySql分页存储过程" class="headerlink" title="MySql分页存储过程"></a>MySql分页存储过程</h2><p>MySql测试版本：5.0.41-community-nt</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> pr_pager; <span class="comment">-- 如果有这个存储过程就删除</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pr_pager(</span><br><span class="line"></span><br><span class="line"><span class="keyword">IN</span>    p_table_name        <span class="built_in">VARCHAR</span>(<span class="number">1024</span>),</span><br><span class="line"><span class="keyword">IN</span>    p_fields            <span class="built_in">VARCHAR</span>(<span class="number">1024</span>),</span><br><span class="line"><span class="keyword">IN</span>    p_page_size            <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">IN</span>    p_page_now            <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">IN</span>    p_order_string        <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line"><span class="keyword">IN</span>    p_where_string        <span class="built_in">VARCHAR</span>(<span class="number">1024</span>),</span><br><span class="line">    <span class="keyword">OUT</span>    p_out_rows            <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">DETERMINISTIC</span>  <span class="comment">-- 确定性</span></span><br><span class="line"><span class="keyword">SQL</span> <span class="keyword">SECURITY</span> DEFINER <span class="comment">-- 安全性</span></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'分页存储过程'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> m_begin_row <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> m_limit_string <span class="built_in">CHAR</span>(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> m_begin_row = (p_page_now - <span class="number">1</span>) * p_page_size;</span><br><span class="line">    <span class="keyword">SET</span> m_limit_string = <span class="keyword">CONCAT</span>(<span class="string">' LIMIT '</span>, m_begin_row, <span class="string">', '</span>, p_page_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> @COUNT_STRING = <span class="keyword">CONCAT</span>(<span class="string">'SELECT COUNT(*) INTO @ROWS_TOTAL FROM '</span>, p_table_name, <span class="string">' '</span>, p_where_string);</span><br><span class="line">    <span class="keyword">SET</span> @MAIN_STRING = <span class="keyword">CONCAT</span>(<span class="string">'SELECT '</span>, p_fields, <span class="string">' FROM '</span>, p_table_name, <span class="string">' '</span>, p_where_string, <span class="string">' '</span>, p_order_string,m_limit_string);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">PREPARE</span> count_stmt <span class="keyword">FROM</span> @COUNT_STRING;</span><br><span class="line">    <span class="keyword">EXECUTE</span> count_stmt;</span><br><span class="line">    <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> count_stmt;</span><br><span class="line">    <span class="keyword">SET</span> p_out_rows = @ROWS_TOTAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">PREPARE</span> main_stmt <span class="keyword">FROM</span> @MAIN_STRING;</span><br><span class="line">    <span class="keyword">EXECUTE</span> main_stmt;</span><br><span class="line">    <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> main_stmt;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="DETERMINISTIC"><a href="#DETERMINISTIC" class="headerlink" title="DETERMINISTIC"></a>DETERMINISTIC</h3><p>它表示一个函数在输入不变的情况下输出是否确定。如果你的函数当输入一样时,会返回同样的结果.这样, 数据库就用前一个计算的值,而不需要再重新计算一次.这对于使用函数索引等,会直到相当大的好处<br>调用:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> pr_pager(<span class="string">"t"</span>,<span class="string">"var"</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">""</span>,<span class="string">""</span>,@<span class="keyword">result</span>);</span><br><span class="line"><span class="keyword">call</span> pr_pager(<span class="string">"t"</span>,<span class="string">"var"</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="string">""</span>,<span class="string">""</span>,@<span class="keyword">result</span>);</span><br></pre></td></tr></table></figure><h3 id="select-into-用法"><a href="#select-into-用法" class="headerlink" title="select * into 用法"></a>select * into 用法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例1：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">into</span> <span class="keyword">result</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line">查找<span class="keyword">table</span>表中<span class="keyword">id</span>=<span class="number">1</span>的<span class="keyword">id</span>赋值给<span class="keyword">result</span></span><br><span class="line">例<span class="number">1</span>：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">id</span>) <span class="keyword">into</span> <span class="keyword">result</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line">查找<span class="keyword">table</span>中<span class="keyword">id</span>为<span class="number">1</span>的 把<span class="keyword">id</span>全部加起来 再把值赋值给<span class="keyword">result</span></span><br></pre></td></tr></table></figure><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例1：</span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`p_get_integral`</span>$$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`p_get_integral`</span>()</span><br><span class="line">    <span class="keyword">SQL</span> <span class="keyword">SECURITY</span> INVOKER</span><br><span class="line">_RETURN:<span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">select</span> roleid,<span class="keyword">concat</span>(<span class="keyword">sum</span>(itemnum),<span class="string">''</span>) <span class="keyword">from</span> log_delitem <span class="keyword">where</span> itemid <span class="keyword">in</span>(<span class="number">920</span>,<span class="number">2983</span>) <span class="keyword">and</span> info =<span class="string">'道具'</span> <span class="keyword">and</span> usetime &gt;= <span class="string">'2019-01-30 00:00:00'</span> <span class="keyword">and</span> usetime &lt;= <span class="string">'2019-01-30 10:40:00'</span> <span class="keyword">group</span> <span class="keyword">by</span> roleid;</span><br><span class="line">    <span class="keyword">END</span>;$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">查找log_delitem表中itemid = 920，2983 info信息等于'道具' 时间在'2019-01-30 00:00:00'和'2019-01-30 10:40:00'之间数据按roleid分组 再查找满足条件的roleid和itemnum值的总和</span><br></pre></td></tr></table></figure><h3 id="查看列数"><a href="#查看列数" class="headerlink" title="查看列数"></a>查看列数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span> information_schema.COLUMNS</span><br><span class="line"><span class="keyword">where</span> TABLE_SCHEMA=<span class="string">'ddd'</span> <span class="keyword">and</span> table_name=<span class="string">'ttt'</span></span><br><span class="line">ps:<span class="string">'ddd'</span>=<span class="string">'库名'</span>  <span class="string">'ttt'</span>=<span class="string">'表名'</span></span><br></pre></td></tr></table></figure><h3 id="查看行"><a href="#查看行" class="headerlink" title="查看行"></a>查看行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="string">'ttt'</span></span><br><span class="line">ps:<span class="string">'ttt'</span>=<span class="string">'表名'</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      MySQL的语法基础
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="MySQL基础语法" scheme="http://www.tjl-myblog.cn/tags/MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程详解</title>
    <link href="http://www.tjl-myblog.cn/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html"/>
    <id>http://www.tjl-myblog.cn/mysql存储过程.html</id>
    <published>2019-01-16T04:07:04.000Z</published>
    <updated>2019-12-21T11:04:47.926Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="MySQL存储过程详解"><a href="#MySQL存储过程详解" class="headerlink" title="MySQL存储过程详解"></a>MySQL存储过程详解</h2><ol><li>存储过程简介</li></ol><p>我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p><p>一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。</p><p>存储过程通常有以下优点：</p><p>(1).存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>(2).存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p><p>(3).存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL(SQL事务)代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p><p>(4).存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。</p><p>(5).存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p><ol start="2"><li>关于MySQL的存储过程</li></ol><p>存储过程是数据库存储的一个重要的功能，但是MySQL在5.0以前并不支持存储过程，这使得MySQL在应用上大打折扣。好在MySQL 5.0终于开始已经支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。</p><blockquote><p>总结：简单来说存储过程就相当于程序中的一个’函数‘ 调用这个’函数‘就会执行’函数‘内相应的sql语句 后续文章会讲解如何使用创建存储过程</p></blockquote>]]></content>
    
    <summary type="html">
    
      MySQL存储过程的作用、优点
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="MySQL存储过程详解" scheme="http://www.tjl-myblog.cn/tags/MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程DELIMITER命令讲解</title>
    <link href="http://www.tjl-myblog.cn/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8BDELIMITER%E5%91%BD%E4%BB%A4%E8%AE%B2%E8%A7%A3.html"/>
    <id>http://www.tjl-myblog.cn/mysql存储过程DELIMITER命令讲解.html</id>
    <published>2019-01-15T11:26:05.000Z</published>
    <updated>2019-12-21T11:04:47.926Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这篇文章主要描述了DELIMITER命令的作用</p></blockquote><h2 id="DELIMITER命令"><a href="#DELIMITER命令" class="headerlink" title="DELIMITER命令"></a>DELIMITER命令</h2><p>DELIMITER是MySQL中的命令，这个命令与存储过程没什么关系<br>他的作用就是告诉MySQL解释器，该段命令是否已经结束了，MySQL是否可以执行了<br>默认情况下DELIMITER是分号; 在命令行客户端中，如果有一行命令以分号结束，那么MySQL将不会管分号后面的sql语法 因为MySQL语法一遇到分号就会自动执行(默认的DELIMITER是分号)<br>而我们在写sql存储过程的时候又不可能只有一条语句 所以这时候就要用到DELIMITER了<br>DELIMITER后面换成其它符号，如//或$$ 这样就不会一出现；就会立即执行sql语句了<br>下面我们看几个例子</p><pre><code>DELIMITER $$DROP TRIGGER IF EXISTS `updateegopriceondelete`$$CREATE    TRIGGER `updateegopriceondelete` AFTER  DELETE ON  `customerinfo`    FOR EACH ROW BEGINDELETE FROM egoprice  WHERE customerId=OLD.customerId;    END$$DELIMITER ;</code></pre><p>DELIMITER 定好结束符为”$$”, 然后最后又定义为”;”, MySQL的默认结束符为”;”.<br>说明我们DELIMITER再sql可以在开头或末尾随意修改的 这个就看自己的需求了</p><pre><code>CREATE FUNCTION `SHORTEN`(S VARCHAR(255), N INT)    RETURNS varchar(255)    BEGIN        IF ISNULL(S) THEN            RETURN &apos;&apos;;        ELSEIF N&lt;15 THEN            RETURN LEFT(S, N);        ELSE            IF CHAR_LENGTH(S) &lt;=N THEN                RETURN S;            ELSE                RETURN CONCAT(LEFT(S, N-10), &apos;...&apos;, RIGHT(S, 5));            END IF;        END IF;    END;</code></pre><p>默认情况下，不可能等到用户把这些语句全部输入完之后，再执行整段语句。<br>因为MySQL一遇到分号，它就要自动执行。<br>即，在语句RETURN ‘’;时，MySQL就开始执行了。<br>这种情况下，就需要事先把DELIMITER换成其它符号，如//或$</p><pre><code>DELIMITER $$ 或 //CREATE FUNCTION `SHORTEN`(S VARCHAR(255), N INT)    RETURNS varchar(255)    BEGIN        IF ISNULL(S) THEN            RETURN &apos;&apos;;        ELSEIF N&lt;15 THEN            RETURN LEFT(S, N);        ELSE            IF CHAR_LENGTH(S) &lt;=N THEN                RETURN S;            ELSE                RETURN CONCAT(LEFT(S, N-10), &apos;...&apos;, RIGHT(S, 5));            END IF;        END IF;    END;$$或//DELIMITER ;(还原;)</code></pre><p>这样只有当$$或//出现之后，MySQL解释器才会执行这段语句</p><blockquote><p>注：DELIMITER 自定义结束符号 后面不要多加一个分号哦(￣▽￣)~*  DELIMITER $$; 用了DELIMITER 符号之后记得在最后还原哦 DELIMITER;</p></blockquote>]]></content>
    
    <summary type="html">
    
      DELIMITER命令的作用
    
    </summary>
    
      <category term="MySQL" scheme="http://www.tjl-myblog.cn/categories/MySQL/"/>
    
    
      <category term="MySQL存储过程基础语法" scheme="http://www.tjl-myblog.cn/tags/MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VSCode同步用户插件-配置</title>
    <link href="http://www.tjl-myblog.cn/vscode%E5%90%8C%E6%AD%A5%E7%94%A8%E6%88%B7%E6%8F%92%E4%BB%B6-%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.tjl-myblog.cn/vscode同步用户插件-配置.html</id>
    <published>2019-01-15T03:06:04.000Z</published>
    <updated>2019-12-21T12:16:24.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这篇文章主要描述了怎么通过github + settings Sync插件把自己的VSCode工具配置同步到自己的github用户下<br>好处：免去了我们换电脑时重新查找安装VSCode插件的环节</p></blockquote><h2 id="什么是-Visual-Studio-Code"><a href="#什么是-Visual-Studio-Code" class="headerlink" title="什么是 Visual Studio Code"></a>什么是 Visual Studio Code</h2><p>Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux<br>VSCode  作为一款逐渐火热的编辑器。它的特点免费、开源、多平台，以及集成git，代码调试，插件丰富等有点，被大家逐渐熟知和认可。<br><a href="https://www.jianshu.com/p/4ee1831d3b9b" rel="external nofollow noopener noreferrer" target="_blank">推荐链接</a></p><h3 id="2、什么是github"><a href="#2、什么是github" class="headerlink" title="2、什么是github"></a>2、什么是github</h3><p>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里我们用来存VSCode插件信息方便我们同步到新电脑上<br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">什么是git</a></p><h3 id="3、什么是settings-Sync插件"><a href="#3、什么是settings-Sync插件" class="headerlink" title="3、什么是settings Sync插件"></a>3、什么是settings Sync插件</h3><p>settings Sync是一款VSCode插件用来同步用户的插件 很方便我们后续再新电脑上使用VSCode(这里我使用的版本是3.1 最高版本会出错)<br><a href="https://www.jianshu.com/p/4ee1831d3b9b" rel="external nofollow noopener noreferrer" target="_blank">插件链接</a></p><h3 id="4、通过上面的工具同步VSCode插件配置"><a href="#4、通过上面的工具同步VSCode插件配置" class="headerlink" title="4、通过上面的工具同步VSCode插件配置"></a>4、通过上面的工具同步VSCode插件配置</h3><h4 id="让你的电脑连接上github仓库"><a href="#让你的电脑连接上github仓库" class="headerlink" title="让你的电脑连接上github仓库"></a>让你的电脑连接上github仓库</h4><ul><li>登陆github点击用户头像<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/1.jpg" alt="图片还没有哦"></li><li>进入设置 settings<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/2.jpg" alt="图片还没有哦"></li><li>进入开发者设置 developers<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/3.jpg" alt="图片还没有哦"></li><li>进入个人令牌 Personal access tokens(令牌相当于github和VSCode访问的一个连接标识)<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/4.jpg" alt="图片还没有哦"></li><li>添加令牌 起个名字 勾选gist Generate new token<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/5.jpg" alt="图片还没有哦"></li><li>复制access token 只有当时创建才可以复制哦 之后就会找不到(他会有提示)</li></ul><h4 id="使用settings-Sync插件上传"><a href="#使用settings-Sync插件上传" class="headerlink" title="使用settings Sync插件上传"></a>使用settings Sync插件上传</h4><ul><li>进入VSCode快捷键ctrl + shift + p 选择上传设置<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/6.jpg" alt="图片还没有哦"></li><li>填入access token记住GitHub Gist 下载同步要用是数字串<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/7.jpg" alt="图片还没有哦"></li></ul><h4 id="使用新的电脑同步插件"><a href="#使用新的电脑同步插件" class="headerlink" title="使用新的电脑同步插件"></a>使用新的电脑同步插件</h4><ul><li>下载VSCode 安装settings Sync插件</li><li>快捷键ctrl + shift + p 选择下载设置<br> <img src="http://image.tjl-myblog.cn:4455/images/blog_article/VSCode同步用户插件-配置/8.jpg" alt="图片还没有哦"></li><li>填入下载用的数字串回车等待同步完成即可</li></ul><p>– Gist ID : dacc06b0446d35a5257c6cdb77dbf4cd</p>]]></content>
    
    <summary type="html">
    
      同步VSCode插件、配置
    
    </summary>
    
      <category term="VSCode写博客" scheme="http://www.tjl-myblog.cn/categories/VSCode%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="VSCode" scheme="http://www.tjl-myblog.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基础语法</title>
    <link href="http://www.tjl-myblog.cn/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://www.tjl-myblog.cn/Markdown基础语法.html</id>
    <published>2019-01-11T10:58:58.000Z</published>
    <updated>2019-12-21T11:04:47.921Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这篇文章会教会你使用Markdownp基础语法书写你自己的博客文章</p></blockquote><h2 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown是什么？</h2><blockquote><p>由于博主的水平有限这里对Markdown仅做对于以下文章有用的简述 如需深入了解请自行百度</p></blockquote><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法他可以是普通文本具有一定格式<br>用途：配合hexo可以快速生成HTML文件省去写自己写HTML结构<br>优点：<br>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的排版效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。（下面你就会见识到有多简单了）<br>缺点：<br>1、需要记一些语法（不过呢五分钟包你学会，不会你找我）。<br>2、有些平台不支持Markdown编辑模式。</p><h2 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h2><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>一篇文章肯定少不了标题吧 Markdown为我们制定了一种定义标题的方法<br>在文字前面加上#即可 这样这段文字就是标题啦 怎么样是不是很简单<br>在Markdown中#最多可以连续有6个 #多少个代表多少级标签 标签级数越大字就体现的越大<br>注：标准语法一般在#后跟个空格再写文字，这样也好看一点嘛。</p><p>语法：</p><pre><code>#...</code></pre><p>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><p>效果：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><p>字体对于博客文章肯定是不可少的东西 Markdown为我们提供了以下常用的字体格式</p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>要倾斜的文字左右分别用一个*号包起来</p><h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><p>加粗的文字左右分别用两个*号包起来</p><h4 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h4><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>要加删除线的文字左右分别用两个~~号包起来</p><p>语法：</p><pre><code>*...* 这是倾斜的文字**...** 这是加粗的文字***...*** 这是斜体加粗的文字~~...~~ 这是加删除线的文字</code></pre><p>示例：</p><pre><code>*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre><p>效果：</p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del><br><del><strong><em>当然可以一起用啦</em></strong></del></p><h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在Markdown中引用只需在文字开头加&gt;就可以了 当然也是可以嵌套哦&gt;&gt;&gt;&gt; 下面就不演示引用的效果了有兴趣的可以自己尝试哦 博客的第一段话就是引用呢</p><p>语法：</p><pre><code>&gt;</code></pre><p>示例：</p><pre><code>&gt;这是引用哦</code></pre><p>效果：</p><pre><code>暂不演示哦</code></pre><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>在文章中的分割线在Markdown中也是相当简单的 只要’-‘或’*’存在三个以上那么这就是啦</p><p>语法：</p><pre><code>&apos;-&apos;或&apos;*&apos;存在三个以上</code></pre><p>示例：</p><pre><code>-------********</code></pre><p>效果：</p><hr><hr><hr><hr><h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><p>在文章中插入你喜欢的图片<br>语法：<br><img src="图片地址" alt="图片alt" title="&#39;图片title&#39;"><br>‘图片alt’:当你的图片路径加载不出你的图片资源时 就会显示alt这个value</p><p>示例：</p><pre><code>![](/images/blog_article/Markdown基础语法/1.jpg &quot;这是图片title哦&quot;)</code></pre><p>效果：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/Markdown基础语法/1.jpg" alt="图片消失啦" title="这是图片title哦"></p><h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><p>超链接：所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序<br>语法：</p><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code>[简书](http://jianshu.com)[百度](http://baidu.com)</code></pre><p>效果：<br><a href="http://jianshu.com" rel="external nofollow noopener noreferrer" target="_blank">简书</a><br><a href="http://baidu.com" rel="external nofollow noopener noreferrer" target="_blank">百度</a></p><p>注：有平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替<br>语法：</p><p><a href="超链接地址" target="_blank">超链接名</a></p><p>示例：</p><p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank" rel="external nofollow noopener noreferrer">简书</a></p><h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>语法：</p><pre><code>无序列表用 - + * 任何一种都可以注意：- + * 跟内容之间都要有一个空格</code></pre><p>示例：</p><pre><code>- 这是列表内容+ 这是列表内容* 这是列表内容</code></pre><p>效果：</p><ul><li>这是列表内容</li></ul><ul><li>这是列表内容</li></ul><ul><li>这是列表内容</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>语法：</p><pre><code>数字加点注意：序号跟内容之间要有空格</code></pre><p>示例：</p><pre><code>1. 这是列表内容   1. 这是列表内容1.1      1. 这是列表内容1.1.1         1. 这是列表内容1.1.1.12. 这是列表内容   1. 这是列表内容2.1.1      1. 这是列表内容2.1.13. 这是列表内容</code></pre><p>效果：</p><ol><li>这是列表内容<ol><li>这是列表内容1.1<ol><li>这是列表内容1.1.1<ol><li>这是列表内容1.1.1.1</li></ol></li></ol></li></ol></li><li>这是列表内容<ol><li>这是列表内容2.1<ol><li>这是列表内容2.1.1</li></ol></li></ol></li><li>这是列表内容</li></ol><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>嵌套注意：上一级和下一级之间敲三个空格即可 上面已经用有序列表做了演示哦</p><h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><p>语法：</p><pre><code>表头|表头|表头:---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-左边加：表示文字居左 默认是左-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code>姓名(左对齐) 技能(居中) 排行(右对齐)姓名| 技能 | 排行:---|:-:|--:刘备|哭|无地之容关羽|打|二哥张飞_字玄德|骂|三弟</code></pre><p>效果：<br>姓名| 技能 | 排行<br>:—|:-:|–:<br>刘备|哭|无地之容<br>关羽|打|二哥<br>张飞_字玄德|骂|三弟</p><blockquote><p>这个可能对刚看到的朋友还是有点摸不着头脑 但是我相信你如果多写几遍肯定没有问题的 加油</p></blockquote><h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><pre><code>语法：单行代码：代码之间分别用一个反引号包起来代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</code></pre><p>示例：</p><pre><code>`单行代码内容`(```)代码...代码...代码...(```)注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</code></pre><p>效果：<br><code>单行代码内容</code></p><pre><code>代码...代码...代码...</code></pre><h3 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h3><p>这个语法其实我也不是很熟啦所以这里博主就不做讲解了 做流程图一般也不会用Markdown来做 下面推荐几款软件 目前百度脑图只支持在线网页制作<br><a href="https://www.xmind.net/" rel="external nofollow noopener noreferrer" target="_blank">xmind</a><br><a href="http://www.edrawsoft.cn/mindmaster/" rel="external nofollow noopener noreferrer" target="_blank">MindMaster</a><br><a href="http://naotu.baidu.com/" rel="external nofollow noopener noreferrer" target="_blank">百度脑图</a></p><blockquote><p>在经过上面的讲解如果你都掌握的话自己写一遍漂亮的博客文章肯定是没有问题的了 还是那句话博主水平有限如果有兴趣深究的朋友可以自行百度哦 如遇到问题欢迎联系( • ̀ω•́ )✧！</p></blockquote>]]></content>
    
    <summary type="html">
    
      学会用Markdown语法写属于自己的文章
    
    </summary>
    
      <category term="Markdown" scheme="http://www.tjl-myblog.cn/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://www.tjl-myblog.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hexo对SEO的优化</title>
    <link href="http://www.tjl-myblog.cn/Hexo%E5%AF%B9SEO%E7%9A%84%E4%BC%98%E5%8C%96.html"/>
    <id>http://www.tjl-myblog.cn/Hexo对SEO的优化.html</id>
    <published>2019-01-11T10:34:02.000Z</published>
    <updated>2019-12-21T11:04:47.919Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这篇文章主要使用SEO使你的博客更具有吸引力（当然这是在被搜索引擎收录之后哦）</p></blockquote><h2 id="一、什么是SEO"><a href="#一、什么是SEO" class="headerlink" title="一、什么是SEO"></a>一、什么是SEO</h2><p>汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名<br>简单的说就是可以在当有用户搜索到关于你博客的内容时可以向他推送你博客的内容</p><h3 id="优化结构"><a href="#优化结构" class="headerlink" title="优化结构"></a>优化结构</h3><p>seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章。在根目录的配置文件下修改permalink如下可解决这个问题：</p><pre><code>url: http://你的网站root: /permalink: :title.htmlpermalink_defaults:</code></pre><h3 id="首页标题优化"><a href="#首页标题优化" class="headerlink" title="首页标题优化"></a>首页标题优化</h3><p>SEO最重要的是你的标题，一般搜索都是搜索你的标题。</p><p>更改index.swig文件(your-hexo-site\themes\next\layout);</p><p>将下面这段代码：</p><pre><code>{% block title %} {{ config.title }} {% endblock %}改成：    {% block title %} {{ config.title }} - {{ theme.description }} {% endblock %}</code></pre><p>这时候你的首页会更符合网站名称 - 网站描述这习惯。</p><p>进阶，做了seo优化，把关键词也显示在title标题里，可改成：</p><pre><code>{% block title %} {{ theme.keywords }} - {{ config.title }}{{ theme.description }} {% endblock %}</code></pre><p>注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。</p><h3 id="关键词与描述"><a href="#关键词与描述" class="headerlink" title="关键词与描述"></a>关键词与描述</h3><p>搜索引擎除了主要抓取标题外，页面的关键词和描述也会抓取。<br>在\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。</p><pre><code>keywords:description:</code></pre><p>在\themes\next\layout_partials\head.swig有如下代码，用于生成文章的keywords。暂时还没找到生成description的位置。</p><pre><code>{% if page.keywords %}    <meta name="keywords" content="{{ page.keywords }}">    {% elif page.tags and page.tags.length %}    <meta name="keywords" content="{% for tag in page.tags %}{{ tag.name }},{% endfor %}">    {% elif theme.keywords %}    <meta name="keywords" content="{{ theme.keywords }}">    {% endif %}</code></pre><p>然后在\themes\next\layout_macro\post.swig中找到这个位置：</p><pre><code>{% if post.description %}</code></pre><p>将以下代码去掉：</p><pre><code>{% if post.description %}{{ post.description }}&lt;div class=&quot;post-more-link text-center&quot;&gt;    &lt;a class=&quot;btn&quot; href=&quot;{{ url_for(post.path) }}&quot;&gt;    {{ __('post.read_more') }} »    &lt;/a&gt;&lt;/div&gt;</code></pre><p>否则首页的文章摘要就会变成文章的description。</p><p>举个例子：</p><pre><code>title: HEXO SEO优化copyright: truetop: 0date: 2019-1-1 21:17:42tags: SEOcategories:password:keywords: [HEXO,HEXO SEO优化]description: 总结一下使用Hexo搭建博客后，SEO优化方案的总结，后期会不定期更新。</code></pre><h2 id="nofollow-标签"><a href="#nofollow-标签" class="headerlink" title="nofollow 标签"></a>nofollow 标签</h2><p>给非友情链接的出站链接添加 “nofollow” 标签，nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。<br>以hexo的NexT主题为例，需要修改两处</p><p>一：找到footer.swig，路径在your-hexo-site\themes\next\layout_partials，将下面代码：</p><pre><code>&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</code></pre><p>改成：</p><pre><code>&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt;</code></pre><p>二：修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码</p><pre><code>&lt;a href=&quot;{{ link }}&quot; target=&quot;_blank&quot;&gt;{{ name }}&lt;/a&gt;</code></pre><p>改成：</p><pre><code>&lt;a href=&quot;{{ link }}&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;{{ name }}&lt;/a&gt;</code></pre><p>将下面代码：</p><pre><code>&lt;a href=&quot;http://creativecommons.org/licenses/{{ theme.creative_commons }}/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt;</code></pre><p>改成：</p><pre><code>&lt;a href=&quot;http://creativecommons.org/licenses/{{ theme.creative_commons }}/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</code></pre><h2 id="安装nofollow插件"><a href="#安装nofollow插件" class="headerlink" title="安装nofollow插件"></a>安装nofollow插件</h2><p>减少出站链接能够有效防止权重分散，hexo有很方便的自动为出站链接添加nofollow的插件。</p><pre><code>npm install hexo-autonofollow --save</code></pre><p>该插件会将博客中的出站链接自动加上nofollow属性，例外请在站点配置文件_config.xml中添加如下字段</p><pre><code>nofollow:    enable: true    exclude:    - www.tjl-myblog.cn    - 友链地址</code></pre><p>这样，例外的链接将不会被加上nofollow属性。</p><p>##开启SEO优化选项</p><p>hexo博客next提供了seo优化选项，在主题配置文件_config.yml中有个选项是seo，默认是false，改成true即开启了seo优化，会进行一些seo优化，如改变博文title等，然后相同文件下有个关键字选项keywords，填充上，写博文时最好每篇博文都加上keywords。</p><p>我用的是next的主题，把该主题的_config.yml的默认keyword改成你的网址关键词</p><pre><code># Set default keywords (Use a comma to separate)keywords: &quot;tjl-myblog&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      让你的博客文章让更多的人搜索到
    
    </summary>
    
      <category term="Hexo" scheme="http://www.tjl-myblog.cn/categories/Hexo/"/>
    
    
      <category term="SEO" scheme="http://www.tjl-myblog.cn/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主动推送百度遇到的问题</title>
    <link href="http://www.tjl-myblog.cn/Hexo%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E7%99%BE%E5%BA%A6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.tjl-myblog.cn/Hexo主动推送百度遇到的问题.html</id>
    <published>2019-01-09T02:49:06.000Z</published>
    <updated>2019-12-21T11:04:47.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>FATAL duplicated mapping key at line 89, column 3:    type: git    ^YAMLException: duplicated mapping key at line 89, column 3:    type: git    ^</code></pre><p>在站点配置的时候我们 需要按以下格式<br>特别注意这里的 ‘-‘如果你想要有多个重复的属性值的话 那么就要在前面加上’-‘他会按着顺序执行下去 如果没有加 就会导致上面的错误</p><pre><code>deploy:- type: gitrepo: git远程仓库地址branch: master- type: baidu_url_submitterrepo:</code></pre>]]></content>
    
    <summary type="html">
    
      解决 &#39;FATAL duplicated mapping key at line 89, column 3&#39;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.tjl-myblog.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.tjl-myblog.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>从零开始使用github + Hexo搭建属于自己的博客</title>
    <link href="http://www.tjl-myblog.cn/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.html"/>
    <id>http://www.tjl-myblog.cn/从零开始搭建属于自己的博客.html</id>
    <published>2019-01-03T11:15:38.000Z</published>
    <updated>2019-12-21T11:04:47.928Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这篇是用GitHub Pages + Hexo搭建属于自己独立的博客的小白详细教程</p></blockquote><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" rel="external nofollow noopener noreferrer" target="_blank">安装Node.js</a></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul><li>下载对应版本<a href="https://git-scm.com/download/win" rel="external nofollow noopener noreferrer" target="_blank">Git</a></li><li><a href="https://www.cnblogs.com/ximiaomiao/p/7140456.html" rel="external nofollow noopener noreferrer" target="_blank">安装使用Git</a> 其实这里进行到设置好了自己的用户名和邮箱就行了 后面的有兴趣的可以了解下</li><li>安装好后查看环境 打开cmd命令命令窗口输入 <code>git version</code></li><li>鼠标右键<br>  <img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/1.png" alt="图片还没有哦"><ul><li>Git GUI Here是图形界面的Git操作</li><li>Git Bash Here是命令行的Git操作，我们选择 Git Bash Here<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/2.png" alt="图片还没有哦"></li></ul></li><li><a href="https://gitee.com/progit/" rel="external nofollow noopener noreferrer" target="_blank">Pro Git（中文版）</a></li><li>Git基本操作（可用<a href="https://blog.csdn.net/renfufei/article/details/41647937" rel="external nofollow noopener noreferrer" target="_blank">小乌龟</a>）<ul><li><code>git clone</code> :将远程仓库复制到本地 git clone项目地址</li><li><code>git init</code> :新建一个仓库</li><li><code>git pull</code> :抓取远程仓库所有分支更新并合并到本地!</li><li><code>git add</code> :跟踪新文件(把目标文件快照放入暂存区域): git add文件名/文件夹名如果是跟踪全部修改过的文件: <code>git add.</code>或者<code>git add--all</code></li><li><code>git commit</code> :提交你的修改: git commit-m”你的注释”</li><li><code>git push</code> :推送你本地仓库的更新到远程仓库,语法为git push (远程名] [本地分支]:远程分支]</li></ul></li></ul><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>命令都是单条执行的</p></blockquote><p>桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g --安装hexo</span><br><span class="line">npm install hexo-deployer-git --save --安装hexo部署到git page的deployer命令</span><br></pre></td></tr></table></figure><p>输入命令之后等待完成<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/3.png" alt="图片还没有哦"></p><p>安装好后根据自己的习惯创建目录或在已有目录右键打开Git Bash Here输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init --初始化hexo</span><br></pre></td></tr></table></figure><p>下载好后命令窗口继续执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --生成静态网页 可使用缩写 hexo g</span><br><span class="line">hexo server --开启本地服务器 可使用缩写 hexo s</span><br></pre></td></tr></table></figure><p>然后打开浏览器输入网址<code>127.0.0.1:4000</code>或者<code>localhost:4000</code> 即可预览效果（建议每次部署到远程仓库的时候都用本地预览下 下面会说怎么部署远程仓库）<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/4.png" alt="图片还没有哦"></p><p>本地博客就搭建好了，为了使我们的博客可以被互联网的朋友看到。我们需要一个服务器和一个域名，为了节约服务器的成本，我们服务器使用的是 GitHub Pages 域名在阿里云或腾讯云买一个就行了也不是很贵，便宜点的几块钱就行啦。</p><h2 id="使用Github"><a href="#使用Github" class="headerlink" title="使用Github"></a>使用Github</h2><p>访问<a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github</a>首页<br>点击右上角的 Sign Up，注册自己的账户</p><h3 id="创建项目远程仓库"><a href="#创建项目远程仓库" class="headerlink" title="创建项目远程仓库"></a>创建项目远程仓库</h3><p>注册完登陆后，我们就创建一个我们自己的<code>Github Pages</code>项目。点击<code>New repository</code><br>创建如下：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/5.png" alt="图片还没有哦"></p><h3 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h3><blockquote><p>配置Github的SSH密钥可以让本地Git项目与远程的Github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。</p></blockquote><ul><li><p>看看是否存在SSH密钥(keys)</p><ul><li><p>首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/. ssh</span><br></pre></td></tr></table></figure></li></ul><p>检查你本机用户home目录下是否存在.ssh目录。如果，不存在此目录，则创建一对新的SSH密钥。否则，你本机已经存在ssh公钥和私钥，直接可在GitHub账户中添加你的公钥。</p></li><li><p>创建一对新的SSH密钥(keys)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span>-keygen -t rsa -C <span class="string">"your_email@example.com"</span> <span class="comment">#这将按照你提供的邮箱地址，创建一对密钥</span></span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>直接回车，则将密钥按默认文件进行存储。<a href="https://blog.csdn.net/marslover521/article/details/84061832" rel="external nofollow noopener noreferrer" target="_blank">git - 查看本地公钥ssh-key</a><br>接着，根据提示，你需要输入密码和确认密码（如果你很放心，可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。）。相关提示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>输入完成之后，屏幕会显示如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure></li><li><p>GitHub账户中添加你的公钥</p><p>运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub <span class="comment">#也可以进入目录手动打开文件复制</span></span><br></pre></td></tr></table></figure><p>复制之后登陆GitHub<br>进入<code>Account Settings</code><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/6.png" alt="图片还没有哦"><br>选择<code>SSH Keys</code><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/7.png" alt="图片还没有哦"><br>粘贴密钥，添加即可<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/8.png" alt="图片还没有哦"></p></li><li><p>测试</p><p>可以输入下面的命令，看看设置是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果是下面的反馈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'github.com (207.97.227.239)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><p>输入yes就好，然后会看到：<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/9.png" alt="图片还没有哦"></p></li></ul><blockquote><p>测试这一步必不可少</p></blockquote><ul><li><p>设置用户信息（在安装Git的时候就应该设置的 <a href="https://www.cnblogs.com/wyhlightstar/p/6283517.html" rel="external nofollow noopener noreferrer" target="_blank">Git查看与修改用户名、邮箱</a>）</p><p>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。<br>Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"name"</span> <span class="comment">#你的用户名</span></span><br><span class="line">git config --global user.email  <span class="string">"email"</span> <span class="comment">#你的的邮箱</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="本地Hexo文件更新到Github库"><a href="#本地Hexo文件更新到Github库" class="headerlink" title="本地Hexo文件更新到Github库"></a>本地Hexo文件更新到Github库</h3><ul><li>登录Github打开上面我们创建的项目</li><li>点击SSH，选择SSH类型地址<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/10.png" alt="图片还没有哦"></li><li>复制地址<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/11.png" alt="图片还没有哦"></li><li>打开你一开始创建的Hexo文件夹，用<code>VSCode</code>打开刚文件夹下的 <code>_config.yml</code>（hexo的配置文件）文件<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/12.png" alt="图片还没有哦"></li><li>修改配置文件<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/13.png" alt="图片还没有哦"></li><li><p>生成Hexo的静态网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>开启本地服务器可预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># 开启本地服务器之后进入浏览器 上面已经说过方法</span></span><br></pre></td></tr></table></figure></li><li><p>部署到Github远程仓库上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d <span class="comment"># 部署之后即可通过 Github Pager 给我们的外链查看我们的博客</span></span><br></pre></td></tr></table></figure><ul><li><p>执行完之后会让你输入Github的账号和密码，输入完后就可以登录查看我们自己的部署在<code>Github Pages</code>服务器上的博客了。对应的地址是 username.github.io(我的是：tangjialang.github.io)</p></li><li><p>这时候，报错 <code>ERROR Deployer not found: git</code>，那么就是你的<code>deployer</code>没有安装成功，你需要执行如下命令再安装一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后再执行 <code>hexo d</code>就行了 然后就可以进行 本地预览了</p></li></ul></li><li><p>使用外链查看博客</p><p>在浏览器上输入Github Pager为我们生成的外链（例如我的是：<code>tangjialang.github.io/</code>，而你的只需要把你的Github用户名替换掉这个链接中的tangjialang，因为我的用户名是这个，那么你自己的专属博客地址就是：<code>https://[您的用户名].github.io/</code>）即可看到自己的博客了。当然，每一个人都可以通过这个地址访问到你的博客了。但是这样访问对于别人访问难免会很麻烦，用户名短一点还好那要是很长呢，恐怕也只有自己不嫌弃了吧。后面我们会说到如何通过域名来访问我们的博客（你可以理解为把外链和域名关联上 访问这个域名相当于就访问了这个网址）</p></li></ul><h2 id="美化自己的博客"><a href="#美化自己的博客" class="headerlink" title="美化自己的博客"></a>美化自己的博客</h2><p>通过上面的步骤我们的博客已经挂在了Github服务器上面，别人已经可以通过地址来登陆我们的博客了。但是我们的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。</p><ul><li>进入<a href="https://hexo.io/themes/" rel="external nofollow noopener noreferrer" target="_blank">Hexo的官网主题专栏</a><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/14.png" alt="图片还没有哦"></li><li>挑选我们喜欢的主题</li><li><p>克隆主题<br>来到Hexo文件夹下的themes目录，右键Git Bash，在命令行输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) <span class="comment"># git clone 后面是地址</span></span><br></pre></td></tr></table></figure></li><li><p>等待下载</p></li><li><p>完成之后修改Hexo的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: hexo-theme-next <span class="comment"># 找到 theme 然后修改成我们喜欢的主题名即可</span></span><br></pre></td></tr></table></figure></li><li><p>使用命令生成-预览-清理-部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment"># 生成</span></span><br><span class="line">hexo s <span class="comment"># 打开本地服务器 通过浏览器网址 127.0.0.1:4000 或 localhost 查看 如果不满意 可以不部署到远程仓库 那么远程仓库就不会改变 等满意了再部署</span></span><br><span class="line">hexo clean <span class="comment"># 在进行部署前 最好清理缓存 不然效果可能跟我们预览的不一样</span></span><br><span class="line">hexo d <span class="comment"># 部署 然后通过 Github Pager 为我们生成的外链查看 绑定了域名就用域名访问即可</span></span><br></pre></td></tr></table></figure><p>更多修改效果请查看对应主题的说明文档，<a href="http://theme-next.iissnan.com/" rel="external nofollow noopener noreferrer" target="_blank">点击此</a>查看本主题(Next)对应的说明文档<br><a href="http://tjl-myblog.cn/Hexo%E4%B8%BB%E9%A2%98Next-%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86.html" rel="external nofollow noopener noreferrer" target="_blank">Hexo主题Next-优化整理</a></p></li></ul><h2 id="博客书写文章"><a href="#博客书写文章" class="headerlink" title="博客书写文章"></a>博客书写文章</h2><ul><li>使用 <code>hexo new &#39;文章名&#39;</code> 发表新文章 会在项目 <code>\Hexo\source_posts</code> 中生成 我的家.md文件，用编辑器打开编写即可 当然，也可以直接在\Hexo\source_posts中新建一个.md文件。写完后，推送到服务器上即可查看新文章。</li><li>使用<a href="http://www.tjl-myblog.cn/使用VSCode书写Hexo博客文章.html">使用VSCode书写Hexo博客文章</a></li><li>推荐工具<ul><li>首款就是我在使用的VSCode工具，很方便管理。</li><li>Windows下可以使用 <a href="http://markdownpad.com/download.html" rel="external nofollow noopener noreferrer" target="_blank">MarkdownPad2</a>。</li><li>在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。</li><li>Web 端上，我强烈推荐 简书 这款产品</li></ul></li></ul><h2 id="关联域名"><a href="#关联域名" class="headerlink" title="关联域名"></a>关联域名</h2><blockquote><p>很多朋友创建了自己的博客之后会选择买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上，其实这也并不难，只要你有个域名。</p></blockquote><ul><li>购买域名<ul><li>如果你不是很有钱，在<a href="https://wanwang.aliyun.com/domain/com/?spm=5176.10695662.1158081.1.29d8fc0cUy1O7y" rel="external nofollow noopener noreferrer" target="_blank">阿里云</a>上，你只要几块钱就可以买到一个域名（<a href="https://dnspod.cloud.tencent.com/" rel="external nofollow noopener noreferrer" target="_blank">腾讯云</a>也不错），反正对新用户都是比较和善的。</li></ul></li><li>配置CNAME文件（这个文件是没有后缀的哦）<br>在 <code>\hexo\source</code> 文件夹下创建文件 <code>CNAME</code> 内容为你的域名，例如我的域名是：tjl-myblog.cn<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/15.png" alt="图片还没有哦"><br>然后提交到远程仓库<code>hexo clean --&gt; hexo g --&gt; hexo d</code></li><li><p>解析域名（进入控制台添加NS解析记录 进行解析<a href="https://console.cloud.tencent.com/cns" rel="external nofollow noopener noreferrer" target="_blank">腾讯解析</a> <a href="https://dc.console.aliyun.com/next/index?spm=5176.2020520001.aliyun_sidebar.aliyun_sidebar_domain.365c4bd3o90IqV#/domain/list/all-domain" rel="external nofollow noopener noreferrer" target="_blank">阿里解析</a>）<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/16.png" alt="图片还没有哦"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 腾讯云DNS</span></span><br><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br><span class="line"><span class="comment"># 阿里云DNS</span></span><br><span class="line">vip1.alidns.com</span><br><span class="line">vip2.alidns.com</span><br></pre></td></tr></table></figure><p><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/17.png" alt="图片还没有哦"><br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/18.png" alt="图片还没有哦"></p></li><li>获取ip<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/20.png" alt="图片还没有哦"></li><li>添加记录<br><img src="http://image.tjl-myblog.cn:4455/images/blog_article/从零开始搭建属于自己的博客/19.png" alt="图片还没有哦"></li></ul><p>然后等待生效（最迟72小时生效，即可通过你的域名浏览你的博客主页）</p><p>参考：<br><a href="https://juejin.im/entry/5a574864f265da3e3c6c1217" rel="external nofollow noopener noreferrer" target="_blank">2018，你该搭建自己的博客了</a></p>]]></content>
    
    <summary type="html">
    
      从零开始使用GitHub + Hexo搭建属于自己的博客
    
    </summary>
    
      <category term="Hexo" scheme="http://www.tjl-myblog.cn/categories/Hexo/"/>
    
    
      <category term="搭建博客" scheme="http://www.tjl-myblog.cn/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Git与Github仓库建立连接</title>
    <link href="http://www.tjl-myblog.cn/Git%E4%B8%8EGithub%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.html"/>
    <id>http://www.tjl-myblog.cn/Git与Github仓库建立连接.html</id>
    <published>2018-12-21T13:44:44.000Z</published>
    <updated>2019-12-21T11:04:47.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p><blockquote><p>这篇文档是使用git命令来创建本地仓库和远程仓库链接的笔记<br>写这篇笔记的原因 由于想在公司电脑上也进行管理我的远程仓库 所以这里记录一下以免以后忘记本人记性有点糟糕<br>前提:电脑已经安装好并配置好git的情况</p></blockquote><h2 id="本地远程仓库连接"><a href="#本地远程仓库连接" class="headerlink" title="本地远程仓库连接"></a>本地远程仓库连接</h2><h3 id="第一步-初始化本地仓库"><a href="#第一步-初始化本地仓库" class="headerlink" title="第一步 初始化本地仓库"></a>第一步 初始化本地仓库</h3><p>创建一个文件夹名字自定义 右键文件夹内 选择 Git Bash Here 输入 git init</p><h3 id="第二步-创建远程仓库"><a href="#第二步-创建远程仓库" class="headerlink" title="第二步 创建远程仓库"></a>第二步 创建远程仓库</h3><p><a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/</a> 登陆自己的账号 没有的自己注册一个 英语差的下一个翻译 点击New repository 然后根据提示出来的信息写入自己远程仓库的名字 然后点创建即可</p><h3 id="第三步-本地与远程建立链接"><a href="#第三步-本地与远程建立链接" class="headerlink" title="第三步 本地与远程建立链接"></a>第三步 本地与远程建立链接</h3><p>git remote add origin + 远程仓库的地址(SSH链接) 如果已经有了 可以使用 git remote rm origin 移除 然后再添加自己想要的仓库即可</p><h3 id="第四步-拉取数据文件"><a href="#第四步-拉取数据文件" class="headerlink" title="第四步 拉取数据文件"></a>第四步 拉取数据文件</h3><p>git pull origin master –allow-unrelated-histories 拉取远程仓库已有的数据文件(–allow-unrelated-histories 第一次这个必须加不然拉不下来)</p><h3 id="第五步-提交文件"><a href="#第五步-提交文件" class="headerlink" title="第五步 提交文件"></a>第五步 提交文件</h3><p>git push origin master 这一步结束之后本地仓库就可以和远程仓库正常的拉取和提交了</p>]]></content>
    
    <summary type="html">
    
      让你能畅通无阻的提交代码到远程仓库
    
    </summary>
    
      <category term="Github" scheme="http://www.tjl-myblog.cn/categories/Github/"/>
    
    
      <category term="本地远程仓库连接" scheme="http://www.tjl-myblog.cn/tags/%E6%9C%AC%E5%9C%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hexo迁移电脑遇到的问题</title>
    <link href="http://www.tjl-myblog.cn/Hexo%E8%BF%81%E7%A7%BB%E7%94%B5%E8%84%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.tjl-myblog.cn/Hexo迁移电脑遇到的问题.html</id>
    <published>2018-12-21T02:22:44.000Z</published>
    <updated>2019-12-21T11:04:47.920Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"></p><p>这个笔记主要是解决小白迁移Hexo到新电脑主题丢失的情况(前提主题配置你得备份得有 如果没有的话 还请不用看了 这个我也不知道怎么搞) 所以在这记录下遇到的问题以及解决的方案 这里我只记录了我遇到的问题 如果有问题可以在下方评论哦</p><a id="more"></a><h3 id="做好Hexo备份"><a href="#做好Hexo备份" class="headerlink" title="做好Hexo备份"></a>做好Hexo备份</h3><p>我们再使用Hexo都由hexo init 初始化hexo吧 然后根据改配置来搭建博客 所以这个相当于就是我们博客的基础配置 一定要保管好 不然你想再另一台电脑使用hexo添加博客 你就得再配置一遍了 </p><blockquote><p>想知道怎么用Hexo + GitHub搭建属于自己的博客的小伙伴可以转到<a href="http://tjl-myblog.cn/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.html" rel="external nofollow noopener noreferrer" target="_blank">从零开始搭建属于自己的博客</a></p></blockquote><h3 id="把Hexo推送到GitHub仓库并把Hexo拉取到新电脑"><a href="#把Hexo推送到GitHub仓库并把Hexo拉取到新电脑" class="headerlink" title="把Hexo推送到GitHub仓库并把Hexo拉取到新电脑"></a>把Hexo推送到GitHub仓库并把Hexo拉取到新电脑</h3><p>创建git仓库与远程仓库把 scaffolds、source、themes、.gitignore、(这里发现next主题根本拷贝不下来 所以只有把原来的备份好咯)_config.yml、db.json、package.json、package-lock.json文件提交到远程仓库即可 如果不会提交和拉取的请看我的另一篇文章 git与一个github仓库建立连接</p><h3 id="生产新的nodejs模块"><a href="#生产新的nodejs模块" class="headerlink" title="生产新的nodejs模块"></a>生产新的nodejs模块</h3><p>生成新的nodejs模块文件夹</p><p>hexo init</p><p>复制到原道git下面的项目（也阔以用主题的方式吧npm模块压缩的模式保存并拉取下来）</p><p>需要安装的模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g <span class="comment">#安装hexo</span></span><br><span class="line">npm install hexo-deployer-git --save <span class="comment">#安装hexo部署到git page的deployer命令</span></span><br><span class="line">npm install --save hexo-generator-feed <span class="comment">#RSS</span></span><br><span class="line">npm install hexo-wordcount --save <span class="comment">#统计字数</span></span><br><span class="line">npm install --save hexo-algolia <span class="comment">#站内搜索</span></span><br><span class="line">npm install gulp <span class="comment">#压缩</span></span><br><span class="line">npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save <span class="comment">#gulp压缩模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><h3 id="在新机上面使用127-0-0-1-4000-访问博客"><a href="#在新机上面使用127-0-0-1-4000-访问博客" class="headerlink" title="在新机上面使用127.0.0.1:4000/访问博客"></a>在新机上面使用127.0.0.1:4000/访问博客</h3><p>右键选择 Git Bash Here 输入 hexo generate(生成静态网页 也可以使用g) 在这里我们会遇到第一个问题 如果之前的步骤都是对的那么肯定会出现</p><pre><code>ERROR Local hexo not found in ~\Desktop\Hexo\Static_HexoERROR Try running: &apos;npm install hexo --save&apos;</code></pre><p>接下里只需要输入npm install 出现下面的页面即可</p><pre><code>nunjucks@3.1.3 postinstall C:\Users\ccx\Desktop\Hexo\Static_Hexo\node_modules\nunjucks&gt; node postinstall-build.js srcnpm WARN rollback Rolling back node-pre-gyp@0.10.0 failed (this is probably harmless): EPERM: operation not permitted, scandir &apos;C:\Users\ccx\Desktop\Hexo\Static_Hexo\node_modules\fsevents\node_modules&apos;npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})added 451 packages in 73.361s</code></pre><p>然后再使用hexo g 再使用hexo server(运行本地服务器 可以使用s) 之后</p><pre><code>INFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>就可以使用127.0.0.1:4000访问你的博客啦 这时候我们应是高兴的是吧 可是呢结果并不是如此<br>在这里我们会遇到第二个问题 这个页面访问居然是空白的一点都不可科学是吧<br>细心点可能会发现 </p><pre><code>WARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.htmlWARN  No layout: index.html</code></pre><p>这肯定是不正常的 这个的原因是因为由于同步中未将Next主题提交，也是为了下次同步最新的Next主题，故才有多地同步是更新Next主题方案</p><h3 id="解决http-localhost-4000出现白屏"><a href="#解决http-localhost-4000出现白屏" class="headerlink" title="解决http://localhost:4000出现白屏"></a>解决<a href="http://localhost:4000出现白屏" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:4000出现白屏</a></h3><p>解决方案：直接获取/更新Next主题<br>git clone <a href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/iissnan/hexo-theme-next</a> themes/next 使用这个把主题拷贝下来就大工告成啦<br>然后再分别使用<br>hexo g<br>hexo s<br>然后再<a href="http://localhost:4000上去看就好了然后我们就把他推送到我们GitHub上就好啦" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:4000上去看就好了然后我们就把他推送到我们GitHub上就好啦</a></p><h3 id="推送到GitHub"><a href="#推送到GitHub" class="headerlink" title="推送到GitHub"></a>推送到GitHub</h3><p>不过在之前得清一下缓存哦<br>hexo clean<br>hexo g<br>hexo d<br>之后就可以使用username.github.io访问你的博客了 usernam是你的用户名哦</p><blockquote><p>这里是我的博客地址tangjialang.github.io<br>这是我的域名tjl-myblog.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      让你在多台电脑同时更新博客
    
    </summary>
    
      <category term="Hexo" scheme="http://www.tjl-myblog.cn/categories/Hexo/"/>
    
    
      <category term="Hexo迁移" scheme="http://www.tjl-myblog.cn/tags/Hexo%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
</feed>
