<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c258bb101609862"></script>


  
  
    
      
    
    
      
    
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "f29bed36"
    });
  daovoice('update');
  </script>




  <meta name="google-site-verification" content="i9xX-QciZhzIQmFB93J3PUKRXElCJ6lJC17GV6wh9w0">
  








  <meta name="baidu-site-verification" content="EhXXdbSOXv">







  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="TJL个人博客">





  <link rel="alternate" href="/atom.xml" title="TJL的博客" type="application/atom+xml">






<meta property="og:type" content="article">
<meta property="og:title" content="unity学习笔记">
<meta property="og:url" content="http://www.tjl-myblog.cn/unity学习笔记.html">
<meta property="og:site_name" content="TJL的博客">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://image.tjl-myblog.cn:4455/one.jpg">
<meta property="og:image" content="http://image.tjl-myblog.cn:4455/C#虚函数与虚函数表.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/11_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/11_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/11_3.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/11_4.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/12_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/12_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/12_3.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/12_4.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/13_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/13_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/13_3.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/13_4.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/14_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/14_5.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/14_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/14_3.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/14_4.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/15_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/17_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_3.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_4.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_5.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_6.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_7.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_8.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_9.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/24_10.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/27_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/27_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/28_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/38_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/50_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/54_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/56_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/56_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/60_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/61_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/61_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/63_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/65_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/68_3.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/68_1.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/68_2.png">
<meta property="og:image" content="http://www.tjl-myblog.cn/unity学习笔记/74_1.png">
<meta property="og:updated_time" content="2020-03-08T08:01:13.588Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="unity学习笔记">
<meta name="twitter:image" content="http://image.tjl-myblog.cn:4455/one.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","Sidebar Display, available value (only for Muse | Mist)":null,"display":"hide","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '1Q44Q725B0',
      apiKey: 'eab77275713240120eb2eccee7f178a9',
      indexName: 'find_content',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键字","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"${hits} 找到约 ${time} 条结果"}
    }
  };
</script>



  <link rel="canonical" href="http://www.tjl-myblog.cn/unity学习笔记.html">





<script>
    (function(){
        if(''){
          let password = prompt('请输入文章密码')
            if (password === ''){//用户点击确定但是没有输入内容
              alert('密码不能为空');
              history.back();
              return;
            }
            else if (password !== ''){//确定
              alert('密码错误！');
              history.back();
            }
            else if(!password){//取消 返回的null
              history.back();
              return;
            }
            
        }
    })();
</script>

  <!--<title>unity学习笔记 | TJL的博客</title> 原 下面是经过优化的SEO-->
  <title>unity学习笔记 | TJL的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- 左下角播放器 -->
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
    <!--下面是右上角的小猫-->
    <a href="https://github.com/tangjialang?tab=repositories" class="github-corner" aria-label="View source on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner">

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TJL的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.tjl-myblog.cn/unity学习笔记.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="游戏人生">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://image.tjl-myblog.cn:4455/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TJL的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">unity学习笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-23T16:53:30+08:00">
                2019-12-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-08T16:01:13+08:00">
                2020-03-08
              </time>
            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  46.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  175
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://image.tjl-myblog.cn:4455/one.jpg" alt="图片还没有哦"><br><a id="more"></a></p>
<h1 id="unity-第一课（初识unity）"><a href="#unity-第一课（初识unity）" class="headerlink" title="unity 第一课（初识unity）"></a>unity 第一课（初识unity）</h1><h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><ul>
<li><code>.net</code>跨平台开源框架（只限于windows）</li>
<li><code>mono</code>跨平台开源框架 跨平台的.net标准框架（不限于windows）<h2 id="基于mono的两大项目："><a href="#基于mono的两大项目：" class="headerlink" title="基于mono的两大项目："></a>基于<code>mono</code>的两大项目：</h2></li>
<li>unity（游戏开发引擎）</li>
<li><a href="https://www.xamarin.com" rel="external nofollow noopener noreferrer" target="_blank">Xamarin（跨平台的移动App的开发工具）</a></li>
</ul>
<blockquote>
<p>unity就是基于mono的基础上，进行游戏引擎开发而实现的跨平台</p>
</blockquote>
<h1 id="unity-第二课（unity场景树渲染体系物理体系）"><a href="#unity-第二课（unity场景树渲染体系物理体系）" class="headerlink" title="unity 第二课（unity场景树渲染体系物理体系）"></a>unity 第二课（unity场景树<em>渲染体系</em>物理体系）</h1><h2 id="unity组件开发的优点"><a href="#unity组件开发的优点" class="headerlink" title="unity组件开发的优点"></a>unity组件开发的优点</h2><ul>
<li>使用一个开发工具，将所有的工作环节都集成在一起，相互独立的进行开发，开发效率提升。</li>
</ul>
<h2 id="场景树"><a href="#场景树" class="headerlink" title="场景树"></a>场景树</h2><p><code>GameObject = 节点 + Transform</code></p>
<ul>
<li>每一个场景是由节点树组成的（由节点的Transform组成的）</li>
<li>场景树基于Transform组成 而不是游戏节点GameObject</li>
</ul>
<h2 id="图像世界"><a href="#图像世界" class="headerlink" title="图像世界"></a>图像世界</h2><p><strong>渲染关系</strong><br>Mesh（3D模型网格） + Mesh render + 材质（Material 皮肤、贴图） = 3D模型</p>
<h2 id="物理世界"><a href="#物理世界" class="headerlink" title="物理世界"></a>物理世界</h2><p><strong>物理关系</strong><br>加刚体，运动的物体，可以运动可以受力。<br>不加刚体，静止的物体。<br>只有刚体而没有形状的话，相当于幽灵没有实质，所以需要物理形状。<br>在物理形状上，会有物理材质，就像不同天气，地面会有不同的地面（湿润、干燥）。</p>
<ul>
<li>刚体（Rigidbody）：让一个物体具有重量具有物理属性</li>
</ul>
<blockquote>
<p>物体分为两种</p>
<ul>
<li>没加刚体就是静态不动物体</li>
<li>加刚体的物体拥有物理属性可受力</li>
</ul>
</blockquote>
<ul>
<li>物理形状（Collider 碰撞器）：让物体拥有形状<ul>
<li>物理材质（下雨过后地面很滑，出太阳之后地面很干，这地面可以称为物理材质）</li>
</ul>
</li>
</ul>
<blockquote>
<p>有形状物体与物体才会发生联系</p>
</blockquote>
<h1 id="unity-第三课-Unity-C-的基本结构-类-成员-类的函数"><a href="#unity-第三课-Unity-C-的基本结构-类-成员-类的函数" class="headerlink" title="unity 第三课 (Unity C#的基本结构_类_成员_类的函数)"></a>unity 第三课 (Unity C#的基本结构_类_成员_类的函数)</h1><p>游戏的程序简单运作模式分为三步骤</p>
<ul>
<li><p>初始化</p>
</li>
<li><p>while循环</p>
<ul>
<li>处理游戏事件</li>
<li>渲染游戏场景画面</li>
<li>是否需要休眠（<strong>cpu性能好的情况才会休眠，如果性能不好就会一直执行循环，休眠是为了节约cpu，不休眠是为了给游戏换取最大的流程程度</strong>）<blockquote>
<p>1s要维持60fps 1s 分为60份 1s / 60 = 0.01666…（0.016s）</p>
<pre><code>cpu的处理能力 如果在0.01s就已经处理完了 (事件+物理计算+渲染画面)cpu就会休眠0.006s
如果你cpu能力无法在0.016s内完成（事件+物理计算+渲染画面）你的游戏帧数就无法达到60fps
</code></pre><ul>
<li>这个休眠就是用来维持游戏帧数在60fps上下，根据不同的cpu处理能力来决定休眠的时间</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>游戏结束处理</p>
</li>
</ul>
<blockquote>
<p>手游 帧频到达60（顶峰） 虽然还能继续往上加 但是人眼是分辨不出什么差别的，60帧频就是人眼的极限了看着的画面就很流畅，如果继续增加帧频只会费电。</p>
</blockquote>
<h2 id="组件代码入口"><a href="#组件代码入口" class="headerlink" title="组件代码入口"></a>组件代码入口</h2><p>MonoBehaviour 组件的基本规则（基类）</p>
<ul>
<li>void Awake(){} 组件实例加载时调用</li>
<li>void Start(){} 在第一次update之前调用</li>
<li>void Update(){} 游戏每次刷新的时候调用</li>
<li>void FixedUpdate() {} 物理引擎每次固定刷新的时候调用，与帧频无关 主要是用于物理计算 （固定机制 根据cpu当前性能得到一个固定的频率）</li>
<li>void OnGUI() {} 绘制2D元素入口的时候调用，你如玩家的昵称，血条 绘制GUI元素</li>
</ul>
<blockquote>
<p>组件类和脚本文件名称要保持一致</p>
</blockquote>
<ul>
<li><p>程序跑起来的时候生成的</p>
<ul>
<li>栈 在函数执行返回之后进行回收</li>
<li>堆 在没有任何引用指向的时候进行回收</li>
</ul>
</li>
<li><p>程序加载启动的时候</p>
<ul>
<li>数据段、代码段 在程序关闭时 回收</li>
</ul>
</li>
</ul>
<h1 id="unity第四课-Unity-C-表达式-条件-循环-函数传参-out关键字"><a href="#unity第四课-Unity-C-表达式-条件-循环-函数传参-out关键字" class="headerlink" title="unity第四课 (Unity C#表达式_条件_循环_函数传参_out关键字)"></a>unity第四课 (Unity C#表达式_条件_循环_函数传参_out关键字)</h1><h2 id="out和ref"><a href="#out和ref" class="headerlink" title="out和ref"></a><a href="https://blog.csdn.net/qq373011556/article/details/81944690" rel="external nofollow noopener noreferrer" target="_blank">out和ref</a></h2><p>同：<br>1、都能返回多个返回值。</p>
<p>2、若要使用 ref 和 out 参数，则方法定义和调用方法都必须显式使用 ref 和 out 关键字。在方法中对参数的设置和改变将会直接影响函数调用之处 (参数的初始值）。</p>
<p>异：<br>1、ref 指定的参数在函数调用时候必须初始化，不能为空的引用。而 out 指定的参数在函数调用时候可以不初始化；</p>
<p>2、out 指定的参数在进入函数时会清空自己，必须在函数内部赋初值。而 ref 指定的参数不需要。</p>
<h1 id="unity第五课-Unity-C-构造函数调用基类继承-多态-重载"><a href="#unity第五课-Unity-C-构造函数调用基类继承-多态-重载" class="headerlink" title="unity第五课 (Unity_C#构造函数调用基类继承_多态_重载)"></a>unity第五课 (Unity_C#构造函数<em>调用基类</em>继承_多态_重载)</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>基类的引用变量来保存子类的实例</li>
<li>使用 <code>virtual</code> 关键字修饰的函数就是一个虚函数，在实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过 <code>override</code> 关键字）所以说 子类如果要重写父类函数想实现C++的多态的话还得在子类函数前面用 <code>override</code> 关键字进行修饰。</li>
<li>虚函数的实现：每一个类都有一个虚函数表，当一个函数为虚函数的时候就会添加进表中，当new 这个实例的时候，会生成一个指向虚函数表的引用变量，当基去调用这个函数的时候，发现为虚函数，就会用这个引用变量去虚函数表中找这个函数，因为每一个类的虚函数表<br><img src="http://image.tjl-myblog.cn:4455/C#虚函数与虚函数表.png" alt="图片还没有哦"></li>
</ul>
<h1 id="第六课（Unity-C-数组-string-static-const-泛型编程-名字空间）"><a href="#第六课（Unity-C-数组-string-static-const-泛型编程-名字空间）" class="headerlink" title="第六课（Unity_C#数组_string_static_const_泛型编程_名字空间）"></a>第六课（Unity_C#数组_string_static_const_泛型编程_名字空间）</h1><p><code>string.Format</code> 格式化生成字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = string.Format(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, &quot;xiaohong&quot;, 10, &quot;male&quot;);</span><br></pre></td></tr></table></figure></p>
<p><code>string.Equals</code> 两个字符串是否相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">str = &quot;Hello&quot;;</span><br><span class="line">if(str.Equals(&quot;Hello&quot;))&#123;</span><br><span class="line">    //相等则进</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// == 表示比较 两个数据对象是否是同一个 如果是字符串值的比较就用这个函数</span><br></pre></td></tr></table></figure></p>
<p><code>ToUpper</code> 字符串转换为大写<code>str.ToUpper()</code></p>
<p><code>ToLower</code> 字符串转换为小写<code>str.ToLower()</code></p>
<h2 id="静态变量（static）、const、readonly"><a href="#静态变量（static）、const、readonly" class="headerlink" title="静态变量（static）、const、readonly"></a>静态变量（static）、const、readonly</h2><blockquote>
<p>类中不需要使用成员变量、纯逻辑而使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">    //static const 全局唯一</span><br><span class="line">    //使用类名.xxx</span><br><span class="line">    public static int pi = 3.14;</span><br><span class="line">    public static const int b = 2;</span><br><span class="line">    public const int c = 2; //不加static也行 const 不能修改的变量（常量）</span><br><span class="line"></span><br><span class="line">    //每一个实例，都会有一个readonly变量</span><br><span class="line">    //readonly的变量又一次修改的机会</span><br><span class="line">    //在对象构造的时候可进行赋值进行修改 之后就无法进行修改了</span><br><span class="line">    public readonly int test_readonly = 4;</span><br><span class="line"></span><br><span class="line">    //const 修饰累的成员变量，在编译的时候确定的常量，运行的时候无法修改</span><br><span class="line">    //readonly实例化的时候确定的常量，可以在构造函数的时候修改，之后就无法修改了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Debug.Log(Person.pi);</span><br><span class="line"></span><br><span class="line">Debug.Log(Person.b);</span><br><span class="line"></span><br><span class="line">Debug.Log(Person.c);</span><br></pre></td></tr></table></figure>
<p>使用 <code>类名.xxx</code>，存在数据段上（全局变量，静态变量）</p>
<p><strong>静态成员变量（全局唯一）<br>静态成员方法</strong></p>
<p>静态成员函数不需要实例直接用类即可调用，由于没有对象实例，静态成员没有this，我们没法访问对象的成员和调用成员函数。处理纯粹的逻辑例如<code>Math.sin Math.cos</code></p>
<h2 id="泛型编程（和C-的模板很像）"><a href="#泛型编程（和C-的模板很像）" class="headerlink" title="泛型编程（和C++的模板很像）"></a>泛型编程（和C++的模板很像）</h2><blockquote>
<p>假如一个类需要实现数值之间的<code>+、-、*、/</code>的计算，如果这个数值有<code>int float double</code>等多种数据类型的话，那么就需要N个类来实现这个方法了，如果使用泛型的话，只需要定义一个泛型类就可以实现N种计算<br><strong>泛型使用之前需要给定一个数据类型，因为他本是是没有数据类型的</strong><br>泛型可以是类可以是函数方法，如果成员方法要是泛型，那么类就先要是泛型才行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//这是一个泛型函数</span><br><span class="line">void Swao&lt;T&gt;(T a, T b)&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这是一个泛型类， 整数（int） Point、浮点数（int） Point</span><br><span class="line">//使用之前需要给定一个数据类型 会自动隐式生成相对数据类型的类</span><br><span class="line">class Point&lt;T&gt;&#123;</span><br><span class="line">    T xpos;</span><br><span class="line">    T ypos;</span><br><span class="line"></span><br><span class="line">    //这是一个泛型成员函数</span><br><span class="line">    public void add_object(T x, T y)&#123;</span><br><span class="line">        this.xpos = x;</span><br><span class="line">        this.ypos = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point&lt;int&gt; Point_int = new Point&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">//隐式生成</span><br><span class="line">// class Point&#123;</span><br><span class="line">//     int xpos;</span><br><span class="line">//     int ypos;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">Point&lt;float&gt; Point_float = new Point&lt;float&gt;();</span><br><span class="line"></span><br><span class="line">//隐式生成</span><br><span class="line">// class Point&#123;</span><br><span class="line">//     float xpos;</span><br><span class="line">//     float ypos;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间（）"><a href="#命名空间（）" class="headerlink" title="命名空间（）"></a>命名空间（）</h2><blockquote>
<p>为了彼此不互相冲突而有的命名空间，一般做库的时候才会使用命名空间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using my_namespace;//让命名空间，加入搜索列表</span><br><span class="line"></span><br><span class="line">//制作自己的命名空间</span><br><span class="line">namespace my_namespace</span><br><span class="line">&#123;</span><br><span class="line">    //外面虽然已经有 Ponit 类了，但是由于命名空间不一样所以可行</span><br><span class="line">    class Point&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point point = new Ponit();</span><br><span class="line"></span><br><span class="line">//命名空间.xxx 每一个都加命名空间很麻烦 使用using即可解决</span><br><span class="line">//加了using 即可Point mypoint = new Ponit();这样使用</span><br><span class="line"></span><br><span class="line">my_namespace.Point mypoint = new my_namespace.Ponit();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>例如上面例子，如果有一样的就会先在当前文件查找 Point，如果找不到因为using 就会去my_namespace命名空间去查找。都找不到就会报错</strong></p>
</blockquote>
<h1 id="第七课-（unity-transform组件一）"><a href="#第七课-（unity-transform组件一）" class="headerlink" title="第七课 （unity_transform组件一）"></a>第七课 （unity_transform组件一）</h1><blockquote>
<p>任何一个组件，都会有一个gameObject指向它挂载的节点实例.<br>任何一个组件，都有个数据成员指向这个节点的transfrom组件实例的;<br>this.transfrom; 通过任何一个组件来获得每一个节点的transfrom组件。<br>同理，transfrom它也是一个组件，所以它也有一个gameObject指向它挂的节点</p>
</blockquote>
<blockquote>
<p><strong>每一个游戏物体 都有transfrom组件 而 每一个组件都有gameObject  所有用this.gameObject  能到到当前组件的实例 this.transfrom.gameObject  也能得到当前组件实例</strong></p>
</blockquote>
<blockquote>
<p>this.gameObject 与this.transform.gameObject是一样的<br>this.transform.transform.transform 可以一直这样往后面写，因为this是组件，又一个transform指向它的transform组件实例, this.transform.transform 如果你闲着不累可以写多一点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//this.gameObject 和 this.transform.gameObject 是一样的</span><br><span class="line"></span><br><span class="line">this.gameObject.name //通过挂载的脚本得到name</span><br><span class="line">this.transform.Find(&quot;name&quot;).gameObject.name</span><br><span class="line">this.transform.Find(&quot;name&quot;);//通过名字查找节点</span><br><span class="line">this.transform.FindChild(&quot;name&quot;); //通过孩子节点的名字查找</span><br><span class="line"></span><br><span class="line">// Find(&quot;name/name&quot;) //可填多重路径</span><br><span class="line">// FindChild(&quot;name&quot;) //不能是多重路径</span><br></pre></td></tr></table></figure>
<h2 id="相对坐标-绝对坐标"><a href="#相对坐标-绝对坐标" class="headerlink" title="相对坐标/绝对坐标"></a>相对坐标/绝对坐标</h2><blockquote>
<p><strong>编辑器里面的 <code>postion</code> 是相对坐标，可是代码里面的<code>postion</code>是绝对坐标</strong><br>编辑器里面的世界坐标等于所有父节点的坐标加自己的相对坐标（绝对坐标）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这里是代码 和 编辑器里面是相反的</span><br><span class="line">this.transform.position //这个的是绝对坐标（世界坐标）</span><br><span class="line">this.transform.localPosition; //这个的是相对坐标</span><br></pre></td></tr></table></figure>
<h1 id="第八课-（unity-transform组件二）"><a href="#第八课-（unity-transform组件二）" class="headerlink" title="第八课 （unity_transform组件二）"></a>第八课 （unity_transform组件二）</h1><blockquote>
<p>一个网格的大小为1m</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 将局部坐标转成世界坐标</span><br><span class="line">// 将 Vector3(0, 0, 0) 这个坐标相对于以 this.transform 为原点的坐标 转为世界坐标</span><br><span class="line">// 假如 this.transform 的坐标为 Vector3(0, 0, 10) 那么  Vector3(0, 0, 0) </span><br><span class="line">// 相对于 Vector3(0, 0, 10) 的世界坐标就为 Vector3(0, 0, 10) 将点</span><br><span class="line">Vector3 w_pos = this.transform.TransformPoint(new Vector3(0, 0, 0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 就用 TransformVector（我的南方）就得到了，我的南方在地球的什么方</span><br><span class="line">// 简而言之就是 来获取本地向量 在 世界的什么方向</span><br><span class="line"></span><br><span class="line">//我的南方 不等于 地球的南方，我想知道 我的南方 在地球的什么方向 就用 TransformVector（我的南方向量）就得到了 我的南方在地球的什么方向 （TransformVector 可得到，我的本地坐标 在 世界坐标的什么 方向） 将向量</span><br><span class="line">w_pos = this.transform.TransformVector(0, 0, 0);</span><br><span class="line"></span><br><span class="line">// 将世界坐标转成局部坐标 将世界坐标的点 假如世界坐标点为 Vector3(0, 0, 10) </span><br><span class="line">// 那么 local_wpos 就为 Vector3(0, 0, 5) </span><br><span class="line">// Vector3(0, 0, 10)  这个点 相对于 Vector3(0, 0, 15)这个点的什么位置 Vector3(0, 0, 5) </span><br><span class="line">// 世界坐标转局部坐标</span><br><span class="line">Vector3 local_wpos = this.transform.InverseTransformPoint(new Vector3(0, 0, 15));</span><br><span class="line"></span><br><span class="line">// 平移物体 1：第二个参数为 参考系 2 第一个参数为 每个方向的分量</span><br><span class="line">// Tranlate(new Vector3(0,0,1),this.transform) this.transform 实例的方向</span><br><span class="line">// Tranlate(new Vector3(0,0,1),Space.World) 世界坐标轴方向</span><br><span class="line">// Tranlate(new Vector3(0,0,1),Space.self) 自身坐标轴方向</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个旋转主要就三种表示方法：</p>
<ul>
<li>矩阵（需要16个元素来存放，耗内存）</li>
<li>欧拉角（万象节锁，没有平滑插值，unity顺序为 ZXY）</li>
<li>四元素（提供平滑插值，欧拉角没有，比欧拉角多一个维度，复杂一点，增加了一个向量+外加多少度）</li>
</ul>
</blockquote>
<blockquote>
<p><strong>unity为了防止万向节锁代码里面 用的是四元素，编辑器为了只管看变化用的是欧拉角</strong><br><strong>unity transform里面为了避免万象节锁，使用的是四元数来存放一个旋转<br>unity编辑器里面为了直观的来旋转，使用的是欧拉角来表示</strong></p>
</blockquote>
<p>unity编辑器里面的旋转 是 欧拉角 代码里面是四元素 （unity中编辑器和代码是不一样的比如之前的position）</p>
<blockquote>
<p>物体旋转</p>
<ul>
<li>transform存放一个代表旋转的四元数rotation;</li>
<li>四元数转换成对应的欧拉角eulerAngles;</li>
<li>欧拉角转成四元数Quaternion.Euler(在原来基础上旋转，叠加需要，两个四元素相乘，<strong>把每个小变换组成一个大的总的变换，那么是用 * 和矩阵类似</strong>);</li>
<li>Rotate(旋转欧拉角度函数，在当前的基础上旋转);</li>
</ul>
</blockquote>
<h1 id="第九课-（unity-transform组件三）"><a href="#第九课-（unity-transform组件三）" class="headerlink" title="第九课 （unity_transform组件三）"></a>第九课 （unity_transform组件三）</h1><p><a href="https://blog.csdn.net/ChinarCSDN/article/details/82914420" rel="external nofollow noopener noreferrer" target="_blank">Unity 增量时间 Time.deltaTime 详解</a></p>
<ul>
<li><p>能达到一样的效果</p>
<blockquote>
<p><strong>欧拉角旋转</strong><br>this.cube.Rotate(new Vector3(0, 45, 0));<br><strong>旋转向量 + 角度</strong><br>this.cube.Rotate(new Vector3(0, 1, 0), 45);</p>
</blockquote>
</li>
<li><p><strong>RotateAround</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// RotateAround 围绕一个点 旋转多少度</span><br><span class="line">Vector3 pos = new Vector3(0, 0, 0);</span><br><span class="line">// 原点 方向上 角度45/s</span><br><span class="line">this.sphere.RotateAround(pos, new Vector3(0, 1, 0), Time.deltaTime * 45);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LookAT</strong></p>
<blockquote>
<p>跟看一个物体一样，一直看着这个物体不转眼</p>
<ol>
<li>头顶方向,旋转时候饶的这个向量，默认为y (0, 1, 0)</li>
<li>旋转角度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一个为 要盯着哪一个实例看 第二个为 方向 Y</span><br><span class="line">// 鼠标点击人物往哪一个方向看 这个函数就起到了关键的作用</span><br><span class="line">this.transform.LookAt(看的点的位置, new Vector3(0, 1, 0));</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>Quaternion.FromToRotation</strong></p>
<blockquote>
<p>从开始向量，到目标向量的旋转四元素角度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//起点 终点 会 生成一个旋转角度</span><br><span class="line">Quaternion rot = Quaternion.FromToRotation(new Vector3(0, 0, 1), new Vector3(1, 0, 1));</span><br><span class="line">this.cube.rotation = rot;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Lerp</strong></p>
<blockquote>
<p>线性插值 直线移动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 起点         终点</span><br><span class="line">// from(0,0,0) to(10,0,0)</span><br><span class="line">// 用插值也能达到移动物体的目的 下面的代码会让cube的实例移动到(10,0,0)的位置然后停止</span><br><span class="line">// 最后一个参数用来控制移动的速度</span><br><span class="line">// this.cube.transform.position = Vector3.Lerp(Vector3.zero, Vector3.right * 10, 速度)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Slerp</strong></p>
<blockquote>
<p>球面插值 球面弧线移动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 起点         终点</span><br><span class="line">// 因为球面圆形就是 0 0 0 如果from为 0 0 0就会少一个点那么他就会是直线移动而不是球的弧线</span><br><span class="line">// from(-10,0,0) 球面插值from这个不能为 0 0 0  to(10,0,0)</span><br><span class="line">// 用插值也能达到移动物体的目的 下面的代码会让cube的实例移动到(10,0,0)的位置然后停止</span><br><span class="line">// 最后一个参数用来控制移动的速度 </span><br><span class="line">// this.cube.transform.position = Vector3.Slerp(Vector3.right * -10, Vector3.right * 10, Time.time * 0.1f);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="第十课（C-的结构体、属性、ref）"><a href="#第十课（C-的结构体、属性、ref）" class="headerlink" title="第十课（C#的结构体、属性、ref）"></a>第十课（C#的结构体、属性、ref）</h1><p>结构体是值类型 用 new 结构体也只是调用结构体的构造函数 他并不会在堆上开堆，用的是栈内存</p>
<h1 id="第十一课（unity-几何体-材质-FBX-package导入导出）"><a href="#第十一课（unity-几何体-材质-FBX-package导入导出）" class="headerlink" title="第十一课（unity_几何体_材质_FBX_package导入导出）"></a>第十一课（unity_几何体_材质_FBX_package导入导出）</h1><p><strong>材质的常用的着色模式</strong></p>
<ul>
<li>standard</li>
<li>mobile/diffuse(漫反射)</li>
</ul>
<p><strong>材质mobile/diffuse</strong></p>
<ul>
<li>Tiling 分别x、y铺多少块（会受到纹理Wrap Mode的影响 这个来决定图片怎么铺）</li>
<li>Offset 0,0左下角(开始铺) 1,1右上角</li>
</ul>
<p><strong>纹理</strong></p>
<ul>
<li>Wrap Mode 图片铺的样式（包装模式）<ul>
<li>Clamp 边缘填充（以边缘的像素进行填充）</li>
<li>Repeat 循环填充（用图片循环，平铺）</li>
</ul>
</li>
<li>Filter Mode 放大缩小时的插值模式 (Point)表示不用算法会造成放大后图片比较不清晰</li>
</ul>
<p><strong>FBX模型</strong></p>
<ul>
<li>模型顶点坐标</li>
<li>纹理坐标</li>
<li>模型动画(可以没有)</li>
</ul>
<p><strong>package导入导出</strong></p>
<ul>
<li>export导出</li>
<li>import导入</li>
</ul>
<h2 id="unity2017-3-0导入模型，模型无法修改材质问题"><a href="#unity2017-3-0导入模型，模型无法修改材质问题" class="headerlink" title="unity2017.3.0导入模型，模型无法修改材质问题"></a>unity2017.3.0导入模型，模型无法修改材质问题</h2><p>导入材质发现无法修改材质<br><img src="unity学习笔记/11_1.png" alt="图片暂时没有哦"></p>
<p>选择导入的模型 将 location 从 use embedded materials 改成 use external materials (legacy);<br><img src="unity学习笔记/11_2.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/11_3.png" alt="图片暂时没有哦"></p>
<p>修改之后再点击材质你就会发现材质可以修改了，然后按照对应的材质手动修改好就行了。</p>
<p>切断与原模型的联系，就算模型源文件删除了也不会影响场景里面的模型<br><img src="unity学习笔记/11_4.png" alt="图片暂时没有哦"></p>
<h1 id="第十二课（unity-Camera-摄像机详解）"><a href="#第十二课（unity-Camera-摄像机详解）" class="headerlink" title="第十二课（unity_Camera 摄像机详解）"></a>第十二课（unity_Camera 摄像机详解）</h1><ul>
<li><p>Clear Flage<br><strong>以什么什么为背景来绘制我们的场景</strong><br><img src="unity学习笔记/12_1.png" alt="图片暂时没有哦"></p>
</li>
<li><p>Culling Mask<br><strong>对哪一些物体是可见的</strong></p>
<ul>
<li>Everything <strong>所有可见</strong></li>
<li><p>Nothing <strong>所有不可见</strong></p>
<p>根据Layer来勾选是否能看见物体（如果一个物体的Layer为test时Culling Mask中没有对test勾选那么这个物体就是不可见的）</p>
</li>
</ul>
</li>
<li><p>Clipping Planes<br>摄像机能看到的最近距离和最远距离<br><img src="unity学习笔记/12_2.png" alt="图片暂时没有哦"></p>
</li>
<li><p>Viewport Rect 视口大小<br><img src="unity学习笔记/12_3.png" alt="图片暂时没有哦"></p>
</li>
<li><p>Depth<br>摄像机的绘制循序 <strong>大先绘制 小后绘制</strong></p>
</li>
<li><p>Target Display<br>可以接多个显示设备</p>
</li>
<li><p>Projection投射类型</p>
<ul>
<li>Perspective 透视投影算法 锥形（3D转2D 用相似三角形换算出投影过来的 近的宽，远的窄）<br>  <img src="unity学习笔记/12_4.png" alt="图片暂时没有哦"><ul>
<li>Field of View 视角大小    控制投影的大小</li>
</ul>
</li>
<li>Orthographic 平行投影 立方体<ul>
<li>Size 在纵向上一半的显示范围 可根据这个值和屏幕宽高比换算出真实宽高<blockquote>
<p>例如：size为5，屏幕宽高比为 5:4 那么他的宽就是 因为是纵向的一半所有需要乘2，高为(5 <em> 2) </em> 5 / 4 = 12.5（算出一个比例为多少 ）宽就是 5 * 12.5 = 62.5 （比例 5 : 4） 最后得到的宽高(62.5 : 50)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="绘制流水线"><a href="#绘制流水线" class="headerlink" title="绘制流水线"></a>绘制流水线</h2><ul>
<li>模型裁剪，剔除掉不在视椎的范围的物体（视椎裁剪）</li>
<li>世界坐标转为摄像机坐标</li>
<li>摄像机坐标转视口坐标 摄像机的3D坐标转为2D坐标 –&gt; 投影,成像 投影算法：正交投影(2D UI)，透视投影</li>
<li>视口坐标转屏幕坐标 </li>
</ul>
<h1 id="遮挡剔除-Occlusion-Culling-默认开启"><a href="#遮挡剔除-Occlusion-Culling-默认开启" class="headerlink" title="遮挡剔除 (Occlusion Culling) 默认开启"></a>遮挡剔除 (Occlusion Culling) 默认开启</h1><blockquote>
<p>先绘制远的物体再绘制进的物体 这样近的物体就会覆盖远的物体.<br>如果近的物体完全把远的物体挡住了，开启遮挡剔除就不会绘制后面的，如果关闭遮挡剔除那么后面虽然看不到，但是还是会绘制出来，开始有利于游戏性能<br><strong>都是以Mesh来确定是否来遮挡剔除</strong> 建模的时候就要注意区分节点，如果节点是一个那么就没法使用遮挡剔除</p>
</blockquote>
<h1 id="第十三课（unity-初识光源一）"><a href="#第十三课（unity-初识光源一）" class="headerlink" title="第十三课（unity_初识光源一）"></a>第十三课（unity_初识光源一）</h1><p>光三个因素</p>
<ul>
<li>颜色</li>
<li>范围</li>
<li>强度</li>
</ul>
<p>太阳光（平行光源）</p>
<ul>
<li>颜色 </li>
<li>范围（整个世界全局可见） </li>
<li>强度 所有强度一致的</li>
<li>生活参照：太阳</li>
</ul>
<p>灯泡（点光源）</p>
<ul>
<li>颜色 </li>
<li>范围 球体范围内进行衰减，距离越近强度越强</li>
<li>强度 从中心点开始，像四周减弱; </li>
<li>生活参照：普通的灯泡</li>
</ul>
<p>台灯或舞台（聚光灯）</p>
<ul>
<li>颜色 </li>
<li>范围 有特定的方向和范围, 像锥形;</li>
<li>强度 从中心轴开始，像四周减弱</li>
<li>生活参照：台灯、舞台灯、聚光灯</li>
</ul>
<p>光有颜色 255 255 255 白光<br>假如光的强度只有0.5的白光 128 128 128</p>
<blockquote>
<p>光的颜色 + 光的强度就 = 新的颜色 + 材质上的颜色做混合 = 全新的颜色</p>
</blockquote>
<h2 id="光属性"><a href="#光属性" class="headerlink" title="光属性"></a>光属性</h2><p>Render Mode</p>
<ul>
<li>auto 自动选择</li>
<li>important 质量更好 像素进行光照</li>
<li>not import 性能更好 顶点进行光照</li>
</ul>
<p>Cookie 使用一个带Alpha通道的纹理来制作一个遮罩，是光线在不同的地方有不同的强度</p>
<p>Intensity 光的强度<br>Draw Halo 光晕</p>
<ul>
<li><p>太阳光 Directional light</p>
<ul>
<li>Culling Mask和摄像机是一样的<blockquote>
<p>光照对哪一些层是有效的</p>
</blockquote>
</li>
</ul>
</li>
<li><p>点光 Point light<br>Range 光的半径（半径越大，光的衰减就越慢，也就越亮）</p>
</li>
<li><p>聚光灯 Spotlight<br>Range 椎体高<br>Spot Angle 锥角（越大范围越大，越小范围越小）</p>
</li>
</ul>
<h2 id="光源模式"><a href="#光源模式" class="headerlink" title="光源模式"></a>光源模式</h2><p>Baking/2017.3.0为(Mode):</p>
<ul>
<li>实时模式(Realtime)<blockquote>
<p>优点：光照实时计算出来，可以不断的变化<br>缺点：所有光照实时计算出来，消耗CPU</p>
</blockquote>
</li>
<li>烘焙模式(Baked)游戏静态物体，又需要阴影的可以用烘焙来达到更好的游戏性能<blockquote>
<p>优点：预先计算出来，性能好，烘焙出来之后去掉之前的光也会有光<br>缺点：不能够动态的改变（烘焙出来的影子，物体移动阴影不会发生改变）</p>
</blockquote>
</li>
</ul>
<p><strong>烘焙步骤</strong>:</p>
<ol>
<li>场景中的3D物体设置成静态光照的模式;<br><img src="unity学习笔记/13_1.png" alt="图片暂时没有哦"></li>
<li>烘焙的光源设置成Baked;<br><img src="unity学习笔记/13_2.png" alt="图片暂时没有哦"></li>
<li>打开Lighting窗口，在Scene Tab下点击Build;<br><img src="unity学习笔记/13_3.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/13_4.png" alt="图片暂时没有哦"></li>
</ol>
<ul>
<li>混合模式(Mixed) 对动态的物体使用实时光照，对静态的物体使用烘焙</li>
</ul>
<h1 id="第十四课（unity-UGUI-Canvas详解）"><a href="#第十四课（unity-UGUI-Canvas详解）" class="headerlink" title="第十四课（unity_UGUI_Canvas详解）"></a>第十四课（unity_UGUI_Canvas详解）</h1><p>做2D有三套UI</p>
<ul>
<li>自带的GUI</li>
<li>NGUI(广泛用来做2D界面 开源的第三方包) 需要安装<blockquote>
<p>unity5.x后 把NGUI作者找到 开发了UGUI</p>
</blockquote>
</li>
<li>UGUI 内置的</li>
</ul>
<p>3D世界显示2D元素</p>
<ol>
<li>使用正交摄像机</li>
<li>使用透视摄像机，将2D元素移动到合适的距离</li>
</ol>
<ul>
<li>像素换算米<blockquote>
<p>像素变成米然后后面再来计算,640<em>960 单位为100 最后得到6.4 </em> 9.6<br><img src="unity学习笔记/14_1.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/14_5.png" alt="图片暂时没有哦"></p>
</blockquote>
</li>
</ul>
<h2 id="2D元素充满屏幕-3D摄像机做2D"><a href="#2D元素充满屏幕-3D摄像机做2D" class="headerlink" title="2D元素充满屏幕(3D摄像机做2D)"></a>2D元素充满屏幕(3D摄像机做2D)</h2><p>计算正确的Z距离（zeye）</p>
<blockquote>
<p>tan(摄像机视角角度 <em> 0.5) = (h / 2) / zeye；<br>最佳Z值 zeye = h / (2 </em> tan(30))<br>Z / zeye = 最佳缩放比例</p>
</blockquote>
<ol>
<li>用z来设置，计算出最佳的z距离（Z得固定）<blockquote>
<p>tan(30) <em> 2 = 1.1547<br>假如分辨率为 h 640 </em> w 960 = h 6.4 * w 9.6<br>6.4 / 1.1547 = 5.54为最佳的z距离</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>如果2D与3D共存，上面的Z固定了可能会造成遮挡的情况，所有用下面的可以解决此问题<br>不管Z为多少，用Z / 最佳z距离 即可得出2D元素的缩放比例，即可完成图片铺满全屏效果</p>
</blockquote>
<ol start="2">
<li>使用缩放比例进行调整设置<blockquote>
<p>假如z = 10<br>z / 最佳z距离（5.54） = 合适的缩放比例（x 1.8, y 1.8）</p>
</blockquote>
</li>
</ol>
<p>UGUI 核心</p>
<ul>
<li>Canvas(做正确的显示的 做比例适配的)</li>
<li>控件（按钮等）</li>
<li>事件响应（自动创建EventSystem 接收事件）</li>
</ul>
<p>Canvas</p>
<ul>
<li><p>Render Mode </p>
<ul>
<li>Screen Space-Overlay 覆盖到屏幕的上方，就和电视的菜单一样都是在上方（没办法和3D共存）<blockquote>
<p>不支持UI组件image的材质球，显示不出来材质</p>
</blockquote>
</li>
<li><p>Screen Space-Camers 需要指定摄像机 不指定就和上面是一样的</p>
<ul>
<li>Plane Distance 决定2D界面和3D界面的的遮挡关系<blockquote>
<p>这个值小于3D的Z值就会挡住3D物体 大于3D就会显示3D物体</p>
</blockquote>
</li>
</ul>
</li>
<li><p>World Spance  </p>
<ul>
<li>2D和3D完全在一起（<strong>用自己上面的换算Z和缩放比例</strong>）</li>
<li>(这里的Z可决定2D和3D遮挡关系的Z了）和上面Plane Distance一样</li>
<li>Canvas先计算出最佳Z值填上去，遮挡关系要选好不要遮挡了不需要遮挡的物体</li>
<li>再用Z / 最佳Z = 缩放比例填上缩放比例即可这个是修改Canvas的</li>
<li>Canvas下面只需要修改像素为米的单位即可完成充满屏幕的匹配（640 <em> 960改为6.4 </em> 9.6）<br><img src="unity学习笔记/14_2.png" alt="图片暂时没有哦"><br><img src="unity学习笔记/14_3.png" alt="图片暂时没有哦"></li>
</ul>
</li>
</ul>
</li>
<li>Pixel Perfect 勾选画质更好 更完美的填充像素（subpixel）</li>
</ul>
<p>Canvas Scaler 比例计算</p>
<p>Canvas Scaler and Screen Space-Camers</p>
<ul>
<li>UI Scale Mode<ul>
<li>Constant Pixel Size 图片有多大就只显示多大到窗口里面（不做任何缩放） 按像素来（显示窗口就要写死分辨率的）</li>
<li>Scale With Screen Size 按屏幕来缩放 一般用这个<ul>
<li>找好标准屏幕是多少<ul>
<li>Reference Resolution x 960 y 640 就会按照 960 * 640 来进行缩放<blockquote>
<p>只有同比例的缩放才会不影响大小</p>
</blockquote>
</li>
<li>假如我放在一个1920 <em> 1080的屏幕里面，得到比例由上面的960 </em> 640为比例缩放得到缩放比例，宽获取比例 1920 / 960 = 2,    高获取比例1080 / 640 = 1.6875</li>
<li>如果以高度来当缩放因子，宽度就会明显得不到填充完整，因为宽需要缩放2。</li>
<li>如果以宽度来当缩放因子，高度就会明显显示不完整（出界），因为高只需要1.6875。</li>
<li>用Match滑动条来决定到底是以宽(1)来做缩放因子，还是以高(1)来做缩放因子<br><img src="unity学习笔记/14_4.png" alt="图片暂时没有哦"></li>
<li>如果Mathch值为0.5那么就用(宽缩放因子 + 高缩放因子) / 2 = 一个差值，这个差值就是最终的缩放因子,<strong>一般我们不是用宽，就是用高来决定</strong>。<blockquote>
<p>选定大的因子来做缩放就会充满铺满但是小的那一方可能会显示不完整<br>选定小的因子来做缩放，就会有一方会充满不了屏幕</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>Constant Physical Size 按物理尺寸比例比例来进行缩放，如果物理尺寸不一样就会拉大或缩小</li>
</ul>
</li>
</ul>
<p>Canvas Scaler and World Spance</p>
<ul>
<li>Canvas Scaler 没有作用</li>
</ul>
<h2 id="image组件"><a href="#image组件" class="headerlink" title="image组件"></a>image组件</h2><p>可用材质球制定纹理（Screen Space-Overlay不支持材质球）</p>
<ul>
<li>Raycast Target<blockquote>
<p>应该认为这是光线投射的目标吗(是否可以为射线的目标)</p>
</blockquote>
</li>
<li>Preserve Aspect<blockquote>
<p>保持图像现有尺寸（保持图片宽高比）</p>
</blockquote>
</li>
<li>Set Native Size<blockquote>
<p>将图片尺寸设置为纹理的原始像素大小<br>560 * 363最佳Z为3.14</p>
</blockquote>
</li>
</ul>
<h1 id="第十五课（unity-UGUI-RectTransform组件与UI屏幕适配）"><a href="#第十五课（unity-UGUI-RectTransform组件与UI屏幕适配）" class="headerlink" title="第十五课（unity_UGUI_RectTransform组件与UI屏幕适配）"></a>第十五课（unity_UGUI_RectTransform组件与UI屏幕适配）</h1><p><strong>常用分辨率</strong></p>
<ul>
<li>iphone5<ul>
<li>1136 * 640</li>
</ul>
</li>
<li>iphone4<ul>
<li>960 * 640</li>
</ul>
</li>
<li>iPad<ul>
<li>768 * 1024</li>
</ul>
</li>
<li>800 * 480</li>
<li>1920 * 1080</li>
<li>1080 * 1920</li>
</ul>
<p>Pivot</p>
<blockquote>
<p>中心点 左下为0,0 右上角1,1<br>中心点到锚点的距离</p>
</blockquote>
<p>Anchors</p>
<blockquote>
<p>左下为0,0 右上角1,1<br>相对于父节点位置的停靠点（百分比）,用来做适配用的</p>
</blockquote>
<p>Canvas</p>
<blockquote>
<p>与屏幕的大小一样</p>
</blockquote>
<p>UI界面的屏幕适配</p>
<ol>
<li>确定美术的设计分辨率<br><img src="unity学习笔记/15_1.png" alt="图片暂时没有哦"></li>
<li>UI界面Canvas节点的配置，设置Canvas参考分辨率</li>
<li>背景图要能确保充满所有的屏幕，重要的景物在主流屏幕分辨率下的公共区域</li>
<li>UI布局找准停靠点<blockquote>
<p>只需<strong>设置好父节点的停靠点</strong>（<strong>父物体一般大小设置为0</strong>,父节点就是用来做停靠点的），这样做适配就不用管子节点的位置，只需要把父节点的停靠点停好，那么<strong>子节点是相对于父节点</strong>停靠的，这样就很方便了。</p>
</blockquote>
</li>
</ol>
<h1 id="第十六课（Unity-UGUI-Image与Sprite-2D-and-UI-）"><a href="#第十六课（Unity-UGUI-Image与Sprite-2D-and-UI-）" class="headerlink" title="第十六课（Unity_UGUI_Image与Sprite(2D_and_UI)）"></a>第十六课（Unity_UGUI_Image与Sprite(2D_and_UI)）</h1><p>Filter Mode 纹理的缩放模式算法</p>
<p>Image Type 缩放模式</p>
<ul>
<li>simple<blockquote>
<p>图片缩放到目标大小</p>
</blockquote>
</li>
<li>tiled<blockquote>
<p>图片平铺填充到目标大小</p>
</blockquote>
</li>
<li>slice<blockquote>
<p>图片按照九宫格缩放（指定缩放区域，一些特殊的，不缩放的，比如QQ的气泡）</p>
</blockquote>
</li>
<li>Filled<blockquote>
<p>指定区域显示，垂直，水平，圆周（cd动画）</p>
<ul>
<li>Fill Method 显示的类型（圆周360）</li>
<li>Fill Origin 开始显示的方位 Botton Top Left Right</li>
<li>Fill Amount 图片显示的百分比 （0 - 1）</li>
<li>Clock wise 是否顺时针显示</li>
</ul>
</blockquote>
</li>
</ul>
<p>Sprite Edit 配合 slice这个使用</p>
<blockquote>
<p>精灵九宫格拉伸区域</p>
</blockquote>
<p>PackTag</p>
<blockquote>
<p>指定打包时候的标志，自动打包的标志，优化</p>
</blockquote>
<p>Pixels Per Unit</p>
<blockquote>
<p>以多少为一个unity单位(米) 默认100为1个单位</p>
</blockquote>
<h1 id="第十七课（Unity-UGUI-RawImage与Texture和Button）"><a href="#第十七课（Unity-UGUI-RawImage与Texture和Button）" class="headerlink" title="第十七课（Unity_UGUI_RawImage与Texture和Button）"></a>第十七课（Unity_UGUI_RawImage与Texture和Button）</h1><p>Texture</p>
<blockquote>
<p>会把贴图转为2^N次方</p>
<ul>
<li>用于显示图片的贴图（Texture/Sprite(2D and UI)）</li>
<li>Alpha from Grayscal<br>将灰度作为Alpha通道的值</li>
<li>WarpMode <ul>
<li>纹理寻址超过范围的填充模式<ul>
<li>Clamp（边缘填充）</li>
<li>Repeat（循环填充）</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>RawImage</p>
<ul>
<li>UV Rect 贴图纹理寻址</li>
<li>怎么贴<br><img src="unity学习笔记/17_1.png" alt="图片暂时没有哦"></li>
</ul>
<blockquote>
<p>RawImage于Image的区别，<strong>UV Rect贴图寻址</strong>可以做一些效果如：<strong>滚动的地图</strong>，其他没有什么这种需求建议使用Image</p>
</blockquote>
<p>RawImage于Image的区别</p>
<ol>
<li>Sprite只能用在Image组件上做2D and UI</li>
<li>Sprite可以做九宫格</li>
<li>Sprite一般用作小图，可以打Atlas（图集所有小图的集合） Packing Tag</li>
<li>Texture基于纹理寻址模式，不能打包Atlas</li>
<li>UI需要修改UV Rect和利用寻址模式的（滚动地图）,用Texture，否者用Sprite</li>
</ol>
<p>Button</p>
<p>Interactable 是否使用按钮</p>
<p>按钮的4种过度效果</p>
<ul>
<li>Transition 鼠标的过度效果<ul>
<li>None 没有任何效果</li>
<li>Color Tint 颜色过度</li>
<li>Sprite Swap 精灵过度</li>
<li>Animation 动画过度<blockquote>
<p>正常效果<br>划过效果<br>按下效果<br>禁用效果</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="第十八课（Unity-UGUI-Mask-布局-Text组件）"><a href="#第十八课（Unity-UGUI-Mask-布局-Text组件）" class="headerlink" title="第十八课（Unity_UGUI_Mask_布局_Text组件）"></a>第十八课（Unity_UGUI_Mask_布局_Text组件）</h1><p>Mask</p>
<ul>
<li>Rect Mask 2D 矩形mash<blockquote>
<ol>
<li>创建一个空节点，指定节点的大小用于裁剪</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>添加Rect Mask组件</li>
<li>把需要裁剪的图片放在这个组件下面，就会通过这个矩形区域被裁剪掉。<blockquote>
<p>Mask节点下面的孩子只能通过mash区域可见,其他区域会被参见，只能在这个矩形区域内可见</p>
</blockquote>
</li>
</ol>
<ul>
<li>Mask（很像蒙版）<blockquote>
<ol>
<li>创建Mash图片创建Image对象（这个图片要是<strong>不透明的</strong>，比如一个圆形头像）</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>在这个节点上加入Mask组件</li>
<li>将图像加入到这个Image孩子节点下（即可通过这个圆形头像看到圆形区域子节点的图像）</li>
<li>加入的孩子节点只能通过不透明区域看到<blockquote>
<p>在这个节点下面的孩子只能通过不透明的区域看到<br>有毛边的话可以用一个头像外边框</p>
</blockquote>
</li>
</ol>
<p>Vertical Layout Group 组件</p>
<blockquote>
<p>垂直布局 自动把很多个元素，垂直进行布局，不用我们去手动操作</p>
<ul>
<li>Spacing<br>每个元素之间的间隔</li>
<li>Padding<br>排版是从哪儿开始的，距离起点的距离</li>
<li>Child Alignment<br>怎么布局</li>
<li>Child Force Expand<br>width和height可防止父节点大小过大时会把图片拉伸，去掉勾即可</li>
</ul>
</blockquote>
<p>Horizontal Layout Group 组件</p>
<blockquote>
<p>水平布局 自动把很多个元素，垂直进行布局，不用我们去手动操作</p>
<ul>
<li>Spacing<br>每个元素之间的间隔</li>
<li>Padding 局部边缘填充<br>排版是从哪儿开始的，距离起点的距离</li>
<li>Child Alignment<br>孩子排版的方式</li>
<li>Child Force Expand 自适应宽高度<br>width和height可防止父节点大小过大时会把图片拉伸，去掉勾即可</li>
</ul>
</blockquote>
<p>Grid Layout Group 组件</p>
<ul>
<li>Cell Size<blockquote>
<p>每一个的大小</p>
</blockquote>
</li>
<li>Spacing<blockquote>
<p>之间的间隔</p>
</blockquote>
</li>
<li>Start Corner 第一个元素的位置<blockquote>
<p>从哪儿开始排的</p>
</blockquote>
</li>
<li>Start Axis<blockquote>
<p>垂直还是水平</p>
</blockquote>
</li>
<li>Constarint <ul>
<li>Fiexible </li>
<li>Fixed Column Count 固定列数</li>
<li>Fixed Row Count 固定行数</li>
</ul>
</li>
</ul>
<p>Text 组件</p>
<p>1：Text 显示的文本<br>2: Font 使用的文字的字体;<br>3: FontStyle: 文字字体样式;<br>4: LineSpacing: 行间距; 只对垂直溢出有效<br>5: Alignment: 对齐方式;<br>7: Horizontal 水平溢出;<br>8: Vertical 垂直溢出;<br>9: RichText 多格式文本 \&lt;color=blue&gt;&lt;\/color&gt;</p>
<ul>
<li>Best Fit 最佳匹配方式<ul>
<li>Min 字体最小能被缩小到多小</li>
<li>Max 字体最大能被放大到多大</li>
</ul>
</li>
</ul>
<h1 id="第十九课（Unity-UGUI-Solider-Toggle-InputTextfiled组件）"><a href="#第十九课（Unity-UGUI-Solider-Toggle-InputTextfiled组件）" class="headerlink" title="第十九课（Unity_UGUI_Solider_Toggle_InputTextfiled组件）"></a>第十九课（Unity_UGUI_Solider_Toggle_InputTextfiled组件）</h1><p>Slider<br>1: 修改滑动条背景色 –&gt; Background,指定图片或颜色;<br>2: 修改滑动条进度的颜色–&gt;Fill Area–&gt;Fill 指定图片或颜色;<br>3: 修改滑动点与按钮一样:  颜色/图片/动画/过度效果<br>3: 滑动的值被改变: 抛出on value Change事件;<br>4: 获得当前滑动条的进度值[0, 1],</p>
<blockquote>
<p>可以修改这个值[min, max];</p>
</blockquote>
<p>Toggle<br>1: 勾选框背景–&gt;Background   颜色或图片;<br>2: –&gt;Background–&gt;Checkmark 勾选框 颜色或图片;<br>3: 组件节点的RectTransform 大小是响应时间的范围;<br>4: 获得勾选框的值isOn;<br>5:Toggle 勾选过度 渐变/None;<br>6: 每次修改，抛出on value change事件;</p>
<p>InputField<br>Selection Color 选中文本时的颜色<br>Read Only 勾选表示该内容无法被修改</p>
<h1 id="第二十课（Unity-Recttransform-stretch-预制体-ScrollView）"><a href="#第二十课（Unity-Recttransform-stretch-预制体-ScrollView）" class="headerlink" title="第二十课（Unity_Recttransform_stretch_预制体_ScrollView）"></a>第二十课（Unity_Recttransform_stretch_预制体_ScrollView）</h1><p>更新数据</p>
<ul>
<li>预制体数据同步到物体用 Revert</li>
<li>物体数据同步到预制体用 Apply</li>
</ul>
<h1 id="第二十一课（Unity-Input输入详解）"><a href="#第二十一课（Unity-Input输入详解）" class="headerlink" title="第二十一课（Unity_Input输入详解）"></a>第二十一课（Unity_Input输入详解）</h1><blockquote>
<p>监听Input事件都是在Update里面监听</p>
</blockquote>
<ul>
<li>Input.mousePosition<blockquote>
<p>监听当前鼠标位置（以屏幕左下角为原点）</p>
</blockquote>
</li>
<li>Input.anyKey<blockquote>
<p>持续啊亲下，直到弹起（可以是键盘也可以是鼠标）</p>
</blockquote>
</li>
<li>Input.anyKeyDown 当前按下<blockquote>
<p>当前按下</p>
</blockquote>
</li>
<li>Input.inputString<blockquote>
<p>返回输入的assic字符</p>
</blockquote>
</li>
<li>Input.acceleration<blockquote>
<p>如果没有重力传感器，那么就是返回的（0,0,0）返回重力加速度传感器的值，加速度的方向</p>
</blockquote>
</li>
<li>touches<blockquote>
<p>返回当前触摸事件</p>
</blockquote>
</li>
</ul>
<h2 id="获取虚拟轴的值"><a href="#获取虚拟轴的值" class="headerlink" title="获取虚拟轴的值"></a>获取虚拟轴的值</h2><ul>
<li>Input.GetAxis（0 - 1有差值）/Input.GetAxisRaw（0 - 1没有差值）返回虚拟轴的值<blockquote>
<p>Eidt –&gt; ProjectSetting –&gt; Input<br>Input.GetAxis(“Horizontal”)<br>水平虚拟轴</p>
</blockquote>
</li>
</ul>
<p>GetAxis(“Mouse X”)<br>GetAxis(“Mouse Y”)</p>
<blockquote>
<p>距离上一次鼠标的变化 dx dy</p>
</blockquote>
<h2 id="虚拟按键-判断按键有没有按下"><a href="#虚拟按键-判断按键有没有按下" class="headerlink" title="虚拟按键 判断按键有没有按下"></a>虚拟按键 判断按键有没有按下</h2><ul>
<li>Input.GetButton(“Firel”)<blockquote>
<p>持续按下，Firel鼠标左键</p>
</blockquote>
</li>
<li>Input.GetButtonDown(“Firel”)<blockquote>
<p>当前按下</p>
</blockquote>
</li>
<li><p>Input.GetButtonUp(“Firel”)</p>
<blockquote>
<p>当前弹起</p>
</blockquote>
</li>
<li><p>Input.GetKey()</p>
<blockquote>
<p>持续按下</p>
</blockquote>
</li>
<li>Input.GetKeyDown()<blockquote>
<p>当前按下</p>
</blockquote>
</li>
<li>Input.GetKeyUp()<blockquote>
<p>当前弹起</p>
</blockquote>
</li>
<li>KeyCode.xx<blockquote>
<p>键盘上的按键</p>
</blockquote>
</li>
</ul>
<h2 id="判断鼠标有没有按下"><a href="#判断鼠标有没有按下" class="headerlink" title="判断鼠标有没有按下"></a>判断鼠标有没有按下</h2><p>Input.GetMouseButtonDown(0 1 2)左键 右键 中键<br>鼠标当前按下<br>Input.GetMouseButtonUp(0 1 2)左键 右键 中键<br>鼠标当前抬起<br>Input.GetMouseButton(0 1 2)左键 右键 中键<br>鼠标持续按下</p>
<p>GetTouche() 返回当前触控Touch对象</p>
<h2 id="Input-Manager参数"><a href="#Input-Manager参数" class="headerlink" title="Input Manager参数"></a>Input Manager参数</h2><p>1: Name: 轴的名字;<br>2: Descriptive: 正向方向描述;<br>3:  Button:正向反向按钮和附加按钮;<br>4: Gravity:复位的速度，用于按键和鼠标；<br>5: Dead: 小于该值的输入值, 都会被视为0，用于摇杆。<br>6: Sensitivity(灵敏度): 对于键盘输入，该值越大则响应时间越快，该值越小则越平滑。对于鼠标输入，设置该值会对鼠标的实际移动距离按比例缩放<br>7: Snap对齐: 如果启用该设置，当轴收到反向的输入信号时，轴的数值会立即置为0，仅用于键/鼠标 输入。<br>8:Invert 反转: 启用该参数可以让正向按钮发送负值，反向按钮发送正值。<br>9:Type 类型: 所有的按钮输入都应设置为 键/鼠标 (Key / Mouse) 类型，对于鼠标移动和滚轮应设为 鼠标移动(Mouse Movement)。摇杆设为摇杆轴 (Joystick Axis)，用户移动窗口设为窗口移动 （Window Movement）。<br>10:Axis 轴: 设备的输入轴（摇杆，鼠标，手柄等）<br>11:Joy Num 摇杆编号: 设置使用哪个摇杆。默认是接收所有摇杆的输入。仅用于输入轴和非按键。 </p>
<ul>
<li>Touch</li>
</ul>
<p>1:fingerID; 手指ID<br>2: position  手指位置<br>3: deltaPosition 距离上一次的偏移;<br>4: phase: 触摸相位TouchPhase.Began Moved, cancel, ended;<br>5: Touch事件同时会触发 GetMouseButton(0)事件,能够使用<br>Input.GetAxis(“Mouse X/Y”)获取触摸偏移位置;<br>6: 到底用Touch还是用Mouse,如果对触摸的准确性要求不高，可以使用Mouse,否则还是区别对待，使用Touch，如果要多点触控，那么自己判断，直接自己使用Touch</p>
<ul>
<li>Input.Touch<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//只有移动设备有这个touch</span><br><span class="line">if (Input.touchCount &gt; 0) &#123;</span><br><span class="line">    Touch t = Input.GetTouch(0);</span><br><span class="line">    // t.position; //触摸的位置;</span><br><span class="line">    // t.deltaPosition; // 距离上一次,位置的偏移</span><br><span class="line">    // t.phase // 触摸的相位，--&gt;状态， 按下，滑动，弹起,cancel;</span><br><span class="line">    // Touch,只在移动设备上能用，所以统一，鼠标和这个Touch,</span><br><span class="line">    // Touch同时也会发送一个 鼠标左键的事件,模拟一次鼠标左键;</span><br><span class="line">    // GetMouseButton(0), 鼠标，和触摸都可以当作鼠标事件来处理，那么</span><br><span class="line">    // 我们的代码就只要写一次。单点触摸的时候。</span><br><span class="line">    // 多点触摸,自己处理Touch事件。</span><br><span class="line"></span><br><span class="line">    // 单点触控</span><br><span class="line">    // t.position, --&gt; mousePostion;</span><br><span class="line">    // t.deltaPosition --&gt; Input.GetAxis(&quot;Mouse X/Y&quot;);</span><br><span class="line">    // Begin(Down 当前按下), ended(Up 当前抬起), moved(Button 持续按下)</span><br><span class="line">    // end </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第二十二课（Unity-帧动画播放组件）"><a href="#第二十二课（Unity-帧动画播放组件）" class="headerlink" title="第二十二课（Unity_帧动画播放组件）"></a>第二十二课（Unity_帧动画播放组件）</h1><p><strong>帧动画基本介绍</strong></p>
<ul>
<li>美术准备好一个连续动作的离散图片</li>
<li>程序在准确的时间来切换这个图片</li>
<li>优点<ul>
<li>简单、速度快</li>
</ul>
</li>
<li>缺点<ul>
<li>资源占用相对过大</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码控制image组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前代码强制要求要加入一个Image组件</span><br><span class="line">// 如果没有Image，就会自动加上。如果有就使用</span><br><span class="line">// 在MonoBehaviour外面定义</span><br><span class="line">[RequireComponent(typeof(Image))]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果代码要求这个节点会依赖某一个（必须）组件<code>[RequireComponent(typeof(Image))]</code>可以加上这句话，如果你忘记添加该组件，不用担心这句代码会自动给你加上该组件，如果已有组件那么就使用这个组件，不会造成冲突，很实用</strong></p>
</blockquote>
<blockquote>
<p>该播放第几张图片 = （向下取整）（经过总时间 / 图片切换间隔时间）</p>
</blockquote>
<p><strong>如果需要循环播放，直接用（把数值调整为初始化状态）</strong></p>
<blockquote>
<p>如果直接赋值为初始化可能会造成动画不流畅,所以这里用了减法，把之前叠加的数据都减去即可</p>
<ul>
<li>经过总时间 -= (切换间隔 * 总图片张数)</li>
<li>图片索引 -= 总图片张数</li>
</ul>
</blockquote>
<h1 id="第二十三课（Unity定时器事件委托节点操作）"><a href="#第二十三课（Unity定时器事件委托节点操作）" class="headerlink" title="第二十三课（Unity定时器事件委托节点操作）"></a>第二十三课（Unity定时器<em>事件委托</em>节点操作）</h1><ul>
<li><p>定时器 （不支持参数）</p>
<ul>
<li><p>一次性定时器</p>
<ul>
<li>Invoke(“function_name”,time);<blockquote>
<p>多少秒后调用，只会调用一次</p>
</blockquote>
</li>
</ul>
</li>
<li><p>循环定时器</p>
<ul>
<li>InvokeRepeating(“function_name”,time, t);<blockquote>
<p>time秒之后开始调用，每隔t秒调用一次</p>
</blockquote>
</li>
<li>CancelInvoke(“function_name”);<blockquote>
<p>取消一个循环定时器</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>委托</p>
<blockquote>
<p>和订阅号一样，如果订阅号新发布了文章，那么就会推送给，每一个订阅了他的人<br>订阅号发布文章 – &gt; 订阅号告诉订阅中心（委托） –&gt; 然后订阅中心 –&gt; 向已经订阅了的人推送这篇文章</p>
</blockquote>
</li>
</ul>
<p>我们触发这个事件，我们只需要告诉委托就好了，并不需要知道，多少人需要这个事件，我们告诉委托有这个事件之后，那么他就会把这个事件推送给需要的人。</p>
<p>触发者：不需要关心多少人在监听（不需要关系多少人在等我们的文章，我们只需要把写好的文章发布出来，就会通知委托，然后委托把这个文章（事件）推送给需要的监听者，监听者自然也就监听到了自己感兴趣的文章（事件））<br>监听者：不需要关心触发者是谁，何时会发送，谁会发送，如果我们监听感兴趣的东西有了，那么就自动会收到新来的文章（就能调用得到相关事件的函数，我们只会对自己感兴趣的来进行处理）</p>
<blockquote>
<p>监听者不需要管触发者，只要是自己感兴趣的触发者，自然他发的东西，监听就会自动获取得到。</p>
</blockquote>
<p>监听者：设置需要委托的函数，告诉委托，有这个事件触发了，请你调用我这个函数。<br>委托者：当有这个事件触发以后，委托者就会调用，每一个监听者委托的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个委托类型，定义这个委托能委托什么样的函数</span><br><span class="line">public delegate void EventHandler(string name, int age);</span><br><span class="line"></span><br><span class="line">// 定义一个委托实例的引用变量</span><br><span class="line">public EventHandler e;</span><br><span class="line"></span><br><span class="line">// public event EventHandler e; event修饰的委托只能是实例内部触发</span><br><span class="line"></span><br><span class="line">// 实例化委托实例 一般不这样写 原理是这样的 下面 用 e = a 方便一些</span><br><span class="line">// e = new EventHandler(a);</span><br><span class="line"></span><br><span class="line">// 下面是隐式创建了委托实例和这个一样 e = new EventHandler(a);</span><br><span class="line">e = a</span><br><span class="line">// e = a + b</span><br><span class="line">// e = a + b - a</span><br><span class="line">// e += a;</span><br><span class="line"></span><br><span class="line">//委托可用 + - += -= 来增加或减少委托函数</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">需要委托的函数 参数需要和 定义委托类型一样 string name, int age</span><br><span class="line">例如</span><br><span class="line"></span><br><span class="line">这个函数就是监听者，准备要委托的函数</span><br><span class="line">void a(string name, int age)&#123;</span><br><span class="line">    Debug.Log(&quot;a&quot; + name + age);</span><br><span class="line">    // 委托函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个函数就是监听者，准备要委托的函数</span><br><span class="line">void b(string name, int age)&#123;</span><br><span class="line">    Debug.Log(&quot;a&quot; + name + age);</span><br><span class="line">    // 委托函数</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 触发者</span><br><span class="line">// 触发委托，就会调用相对应委托的函数</span><br><span class="line">e(&quot;小明&quot;, 10); //打印 小明10</span><br><span class="line"></span><br><span class="line">// 委托可跨脚本 只要委托函数参数是委托类型的那么就可以委托</span><br><span class="line">// 当触发的时候，就会调用这个委托函数</span><br><span class="line"></span><br><span class="line">// 跨脚本也可以触发委托事件，因为获得了脚本对象的那个委托</span><br><span class="line">// 如果有个需求，就是我在外部能添加委托，但是我无法触发委托呢？ 在委托前面加 event</span><br><span class="line">// event 修饰的委托，就只能是在它的成员函数里面触发，达到了上面的需求</span><br></pre></td></tr></table></figure>
<ul>
<li><p>系统封装的委托类</p>
<blockquote>
<p>System 命名空间下<br>Action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Action e; // 没有参数的委托</span><br><span class="line">public Action&lt;string&gt; e //模板委托 最多4个参数模板 多于4个就自己定也可以</span><br><span class="line">// public delegate void EventHandler(xxx);</span><br><span class="line"></span><br><span class="line">// 一般用法 </span><br><span class="line">// public 外部能加入委托</span><br><span class="line">// event 外部只能添加不能触发委托，委托只能由内部触发</span><br><span class="line">public event Action&lt;int&gt; action = null;</span><br><span class="line"></span><br><span class="line">// 添加委托函数</span><br><span class="line">action += b;</span><br><span class="line">void b(int num)&#123;</span><br><span class="line">    Debug.Log(&quot;num = &quot; + num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 触发 action</span><br><span class="line">if(this.action != null)&#123;</span><br><span class="line">    //触发委托</span><br><span class="line">    this.action(10); // 打印 num = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>删除节点/删除组件</p>
<ul>
<li>删除自己所在的节点,节点上所有组件全部删除<br>MonoBehaviour.Destroy(this.gameObject);</li>
<li>删除组件(删除别的节点 先获取再删除)<br>MonoBehaviour.Destroy(this.Getponent<image>().gameObject);</image></li>
<li>删除组件(删除自己)<br>MonoBehaviour.Destroy(this);</li>
<li>删除组件(删除别的组件上面的组件 先获取再删除)<br>MonoBehaviour.Destroy(this.Getponent<image>());<blockquote>
<p>删除节点的时候会把挂载的所有组件都删除</p>
</blockquote>
</image></li>
</ul>
</li>
</ul>
<p>上面的删除会调用<code>OnDestroy</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 一般在OnDestroy里面删除委托</span><br><span class="line">void OnDestroy()&#123;</span><br><span class="line">    // 监听了委托删除组件的时候记得删除相应的委托</span><br><span class="line">    // -= 即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>隐藏自己/禁用节点</p>
<blockquote>
<p><code>this.gameObject.SetActive(false)</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// （禁用节点）隐藏节点时调用</span><br><span class="line">// 禁用节点之后节点的事件函数也不会执行 除非是用定时器之前定的才会执行调用</span><br><span class="line">void OnDisable()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>显示自己/激活节点</p>
<blockquote>
<p><code>this.gameObject.SetActive(true)</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// （激活节点）显示节点时调用</span><br><span class="line">void OnEnabal()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="第二十四课（Unity-BmpFont的使用和第一个编辑器扩展功能）"><a href="#第二十四课（Unity-BmpFont的使用和第一个编辑器扩展功能）" class="headerlink" title="第二十四课（Unity_BmpFont的使用和第一个编辑器扩展功能）"></a>第二十四课（Unity_BmpFont的使用和第一个编辑器扩展功能）</h1><blockquote>
<p>BmpFont制作工具：GlyphDesigner(Mac系统)</p>
<ul>
<li>GlyphDesigner(Mac系统)<ul>
<li>导入字库</li>
<li>调整好想要的大小和颜色</li>
<li>导出即可得到<em>.fnt和对应的</em>.png</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>字库<ul>
<li>系统字库<blockquote>
<p>优点：省空间<br>缺点：效果中规中矩，无法做特定文字</p>
</blockquote>
</li>
<li>自定义字库(无线字符个数)<blockquote>
<p>优点：样式自定义、灵活<br>缺点：unity需要携带字库文件，占用太大空间</p>
</blockquote>
</li>
<li>BmpFont（位图文字 有限的字符个数）<blockquote>
<p>优点：速度快，占用空间小（因为是有限的）<br>能做出特殊效果的文字<br>缺点：也正因为有限所有成了他的缺点</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="手动计算字模"><a href="#手动计算字模" class="headerlink" title="手动计算字模"></a>手动计算字模</h2><p>BmpFont 有个图片<em>.png 有个文件</em>.fnt（）</p>
<ul>
<li>先创建 一个字库（命名和*.fnt文件一样）<br><img src="unity学习笔记/24_1.png" alt="图片暂时没有哦"></li>
<li>创建字体库 材质球（命名和*.fnt文件一样）<br><img src="unity学习笔记/24_2.png" alt="图片暂时没有哦"><blockquote>
<p>再拖上对应需要使用的png文件</p>
</blockquote>
</li>
<li>使用材质球<br><img src="unity学习笔记/24_3.png" alt="图片暂时没有哦"></li>
<li>设置字体需要使用的数量<br><img src="unity学习笔记/24_4.png" alt="图片暂时没有哦"></li>
<li>填写UV等参数<br><img src="unity学习笔记/24_5.png" alt="图片暂时没有哦"><blockquote>
<p>例如<br>char id=52 x=2 y=2 width=25 height=33 xoffset=0 yoffset=0 xadvance=20 page=0 chnl=0 letter=”4”<br><strong>UV公式<br>X = x / 贴图宽(2/128 = 0.015625) ； Y = 1 - y / 贴图高(1- 2/128 = 0.984375)<br>W = width / 贴图宽(25/128 = 0.1953125) ； H = -1 <em> height / 贴图高 (-33/128 = -0.2578125)<br>Vert<br>X = xoffset (0) ; Y = yoffset (-0.5 </em> height)<br>W = width(25) ； H = height(33)       advance = xadvance (20)；</strong><br><img src="unity学习笔记/24_6.png" alt="图片暂时没有哦"></p>
</blockquote>
</li>
</ul>
<h2 id="扩展编辑器自动计算字摸（字体模型库）"><a href="#扩展编辑器自动计算字摸（字体模型库）" class="headerlink" title="扩展编辑器自动计算字摸（字体模型库）"></a>扩展编辑器自动计算字摸（字体模型库）</h2><p>创建文件</p>
<ul>
<li><p>Editor（扩展编辑器代码名字一定不能错）</p>
<blockquote>
<p>Editor里面的代码不会混合项目代码<br>  用来扩展我们的编辑器<br>  一定要是Editor（这里面的代码都表示是扩展编辑器用的，而不是实际项目中用的）</p>
</blockquote>
</li>
<li><p>加入扩展编辑器的脚本<code>CreateFontEditor.cs</code></p>
</li>
<li><p>打开vs2017可以发现多了个带Editor的项目<br>  <img src="unity学习笔记/24_7.png" alt="图片暂时没有哦"></p>
</li>
<li>入口菜单（点菜单就会调用 CreateFont）<blockquote>
<p>没有那个路径会生成一个新的菜单路径<br>  <img src="unity学习笔记/24_8.png" alt="图片暂时没有哦"></p>
</blockquote>
</li>
<li>就可以使用插件进行自动计算了<ul>
<li><img src="unity学习笔记/24_9.png" alt="图片暂时没有哦"></li>
<li><img src="unity学习笔记/24_10.png" alt="图片暂时没有哦"></li>
</ul>
</li>
</ul>
<h1 id="第二十五课（Unity物理引擎的使用-一-）"><a href="#第二十五课（Unity物理引擎的使用-一-）" class="headerlink" title="第二十五课（Unity物理引擎的使用(一)）"></a>第二十五课（Unity物理引擎的使用(一)）</h1><blockquote>
<p>Unity2D物理引擎基于Box2D封装而成</p>
</blockquote>
<ul>
<li><p>刚体</p>
<blockquote>
<p>控制物体运动和受力</p>
<ul>
<li>刚体的物理参数设置:<ul>
<li>UseAutoMass/Mass:刚体质量,根据密度*面积计算出来</li>
<li>Linear Drag: 线性阻尼(阻力);</li>
<li>Angular Drag: 旋转阻尼;</li>
<li>Gravity Scale: 重力缩放因子（重力）;</li>
<li>is Kinematic: 静态刚体和动态刚体（是否为静态刚体，静态不动的刚体）;</li>
<li>Sleep 模式: 刚体休眠模式，没有参与受力就会休眠，也可以设置永久不休眠;</li>
<li>collistionDetectionMode: 刚体碰撞检测的模式(连续/分离)<ul>
<li>discrete（分离）</li>
<li>Continuous（连续）一般用于速度很快的物体，一般用于子弹检查</li>
</ul>
</li>
<li>Constraints<ul>
<li>Freeze Position（X Y） 这个为true则刚体不能进行移动，锁轴</li>
<li>Freeze Rotation 这个为true 刚体则不能旋转</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>碰撞器</p>
<blockquote>
<p>是物体的形状 + 碰撞的物理参数（物理材质、摩擦力、弹力）</p>
<ul>
<li>碰撞器的物理参数设置: <ul>
<li>Is Trigger 触发器 勾选表示物体是一个虚体，只会触发相应事件，不会发生物理运动</li>
</ul>
</li>
<li>矩形碰撞器</li>
<li>圆形碰撞器（Edge）</li>
<li>边界碰撞器（Circle）</li>
<li>多边形碰撞器（Polygon）</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑-Camera跟随玩家）"><a href="#第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑-Camera跟随玩家）" class="headerlink" title="第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑_Camera跟随玩家）"></a>第二十六课（Unity刚体组件<em>键盘控制人物跑动跳跃</em>物理地形编辑_Camera跟随玩家）</h1><h1 id="第二十七课（Unity碰撞管理与碰撞检测）"><a href="#第二十七课（Unity碰撞管理与碰撞检测）" class="headerlink" title="第二十七课（Unity碰撞管理与碰撞检测）"></a>第二十七课（Unity碰撞管理与碰撞检测）</h1><ul>
<li>物理引擎设置<ul>
<li><img src="unity学习笔记/27_1.png" alt="图片暂时没有哦"></li>
<li><img src="unity学习笔记/27_2.png" alt="图片暂时没有哦"></li>
</ul>
</li>
</ul>
<h2 id="物体碰撞器"><a href="#物体碰撞器" class="headerlink" title="物体碰撞器"></a>物体碰撞器</h2><p>节点碰撞发生的时候</p>
<blockquote>
<p>它会去查询所有组件里面有没有对应的事件函数，如果有就调用这个节点上挂载事件函数</p>
</blockquote>
<ul>
<li>碰撞开始事件<br>void OnCollisionEnter2D(Collision2D c){}<blockquote>
<p>Collision2D 碰撞信息<br>  c.gameObject 获取与我们碰撞的节点</p>
</blockquote>
</li>
<li>碰撞结束事件<br>void OnCollisionExit2D(Collision2D c){}</li>
<li>碰撞持续事件<br>void OnCollisionStay2D(Collision2D c){}</li>
</ul>
<p>##　物体触发器</p>
<ul>
<li>开始触发<br>void OnTriggerEnter2D(Collider2D c)<blockquote>
<p>Collider2D 碰撞信息<br>  c.gameObject 获取与我们碰撞的节点</p>
</blockquote>
</li>
<li>结束触发<br>void OnTriggerExit2D(Collider2D c)</li>
<li>持续触发<br>void OnTriggerStay2D(Collider2D c)</li>
</ul>
<h1 id="（二十八-amp-二十九）一个2D项目（飞机大战）"><a href="#（二十八-amp-二十九）一个2D项目（飞机大战）" class="headerlink" title="（二十八&amp;二十九）一个2D项目（飞机大战）"></a>（二十八&amp;二十九）一个2D项目（飞机大战）</h1><ul>
<li>Screen.height（逻辑宽度，显示的高度）</li>
<li>如果是设置的640 * 960<blockquote>
<p><img src="unity学习笔记/28_1.png" alt="图片暂时没有哦"></p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Canvas设置的是 设计宽高</span><br><span class="line">// Game视图的是 逻辑宽高</span><br><span class="line">// Screen获取的就是 逻辑宽高</span><br><span class="line">// 因为屏幕适配的问题（如果设计宽高和逻辑宽高不一样，那么就需要适配一下，再来获取屏幕高度了，不然会导致对应不上） 640.0f / Screen.width = 得到缩放因子 宽度比例</span><br><span class="line">// 真正的高度等于 Screen.height * 得到的缩放因子 宽度比例</span><br><span class="line">// SetParent(this.bullet_root, 是否使用世界) 这个函数后面使用false 不然可能会出现大小或位置不对 用局部</span><br></pre></td></tr></table></figure>
<h2 id="RequireComponent-typeof-Componentname"><a href="#RequireComponent-typeof-Componentname" class="headerlink" title="[RequireComponent(typeof(Componentname))]"></a>[RequireComponent(typeof(Componentname))]</h2><blockquote>
<p><strong>写好之后重新挂载到脚本才会去生成组件，如果先挂载脚本到实例，写了这个代码的话，他也不会自动帮你生成对应的组件，这点要注意。先写代码，再挂实例！</strong></p>
</blockquote>
<blockquote>
<p>如果预制体制作需要重复工作且每一个不一样，可用<code>Break Prefab Instance</code>暂时切断他们的联系然后重命名再加上新的元素即可</p>
</blockquote>
<h1 id="第030课（Unity3D物理引擎-一-刚体碰撞器材质）"><a href="#第030课（Unity3D物理引擎-一-刚体碰撞器材质）" class="headerlink" title="第030课（Unity3D物理引擎(一)刚体碰撞器材质）"></a>第030课（Unity3D物理引擎(一)刚体碰撞器材质）</h1><ul>
<li><p>刚体</p>
<ul>
<li>Mass 质量</li>
<li>Drag 阻力</li>
<li>Angular Drag 旋转阻力</li>
<li>Use Gravity 是否受重力影响 true 不受重力影响</li>
<li>Is kinematic (是否受牛顿运动学影响): false,正常的物理计算，true运动只会在代码和动画里面受影响，普通的碰撞等都不会改变它的运动状态;</li>
<li>Interpotate: (物体运动插值模式)<br>None(最近计算值)  Interpolate(内插值) extrapolate(外插值)</li>
<li>Collision Detection<ul>
<li>Discrete(离散模式 资源少,静止,低速) </li>
<li>Continuous(连续检测，高速体积小)</li>
<li>Continus Dynamic（动态连续物体）被使用了Continusous检测撞击的对象，使用Continus Dynamic模式;<blockquote>
<p>如果子弹使用了连续监测，那么子弹撞击的那面墙就是使用<code>Continus Dynamic</code>这个离散模式</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Constraints 锁轴</p>
</li>
<li><p>常用参数</p>
<ul>
<li>角速度(angularVelocity);</li>
<li>线性速度(velocity);</li>
<li>重心(center of mass)</li>
<li>碰撞检测开关(detectCollisions): 默认为true, 关闭检测碰撞 false;<blockquote>
<p>把物理形状的盒子全部关闭也是可以达到上面的效果，因为只要关闭就不会发生物理碰撞了</p>
</blockquote>
</li>
<li>intertiaTensor惯性张量 intertiaTensorRotation 惯性张量旋转;</li>
<li>最大角速度(maxAngularVelocity);</li>
<li>最大穿透速度(maxDepenetrationVelocity)</li>
<li>position: 刚体的世界坐标,与图像的transform.position尽量保持一致;<blockquote>
<p>物体也有个position 大致相等，刚体带动物体进行移动<br>  刚体先有position带动物体(并不完全一样，有微小的差异)</p>
</blockquote>
</li>
<li>rotation: 刚体在世界坐标的旋转;</li>
<li>useConeFiction是否使用锥形摩擦,一般false; true一般不使用;</li>
<li>mass 质量</li>
</ul>
</li>
<li>常用方法<ul>
<li>AddForce 给刚体一个力,方向是世界坐标</li>
<li>ForceMode 类型: t（即0.02s 系统指定）</li>
<li>f•t=m•v (force)   f•t=1.0•v (Acceleration)  </li>
<li>f•1.0=m•v(Impulse)  f•1.0=1.0•v(VelocityChange)</li>
<li>AddForceAtPosition postion是世界体系坐标，确保坐标在物体内;</li>
<li>AddRelativeForce力方向 相对于物体坐标</li>
<li>MovePosition/MoveRotation 调整刚体到指定的位置/旋转</li>
<li>AddTorque/AddRelativeToque: 施加一个力矩(相对力矩);</li>
<li>设置密度SetDensticy,体积是碰撞器体积;</li>
<li>Sleep: 强制刚体休眠; Wakeup 唤醒刚体;</li>
<li>SweepTest/SweepTestAll 扫描检测，返回射线碰撞到的刚体; </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AddForce（世界坐标方向的力）"><a href="#AddForce（世界坐标方向的力）" class="headerlink" title="AddForce（世界坐标方向的力）"></a>AddForce（世界坐标方向的力）</h2><blockquote>
<p>AddForce(力的方向 <em> 力的大小(质量 </em> xxx)，力的模式(ForceMode))</p>
<ul>
<li>Force力计算模式 力会持续0.02s<br><strong>用刚体的质量给它加一个连续的力。时间0.02f</strong><br>力 f<br>持续时间 t = 0.02f<br>质量 m<br>初速度 v0<br>作用力 v1<br>f <em> t = m </em> (v1 - v0)<br>力跟质量有关系 一般用这个</li>
</ul>
</blockquote>
<ul>
<li><p>Acceleration 力计算模式 力会持续0.02s</p>
<blockquote>
<p><strong>把一个连续的加速度加到刚体上，忽略它的质量。时间0.02f</strong><br>持续时间 t = 0.02<br>m 质量 不会受质量的影响 质量为1.0f<br>f <em> t(1.0f) = m(1.0f) </em> (v1 - v0)</p>
</blockquote>
</li>
<li><p>Impulse力计算模式 力会持续1s</p>
<blockquote>
<p><strong>利用刚体的质量，给它加上一个瞬间的力脉冲。时间1.0f</strong><br>持续时间 t = 1.0f<br>f <em> t = m </em> (v1 - v0)</p>
</blockquote>
</li>
<li><p>VelocityChange 力计算模式 力会持续1s</p>
<blockquote>
<p><strong>向刚体添加瞬时速度变化，忽略其质量时间1.0f</strong><br>持续时间 t = 1.0f<br>m = 1.0f<br>f <em> t(1.0f) = m(1.0f) </em> v(VelocityChange)<br>它这个力只会和速度有关系</p>
</blockquote>
</li>
</ul>
<p>##　AddForceAtPosition（世界坐标方向的力）</p>
<blockquote>
<p><strong>默认给力到重心</strong><br>AddForceAtPosition(力的方向 <em> 力的大小(质量 </em> xxx) * 给力到哪一个点(确保是在物体内)，力的模式)<br>就像一个力打上一个球的边缘一样，会使用这个球旋转</p>
</blockquote>
<h2 id="AddRelativeForce（相对坐标方向的力，模型坐标）"><a href="#AddRelativeForce（相对坐标方向的力，模型坐标）" class="headerlink" title="AddRelativeForce（相对坐标方向的力，模型坐标）"></a>AddRelativeForce（相对坐标方向的力，模型坐标）</h2><h2 id="AddTorque（世界坐标方向力）"><a href="#AddTorque（世界坐标方向力）" class="headerlink" title="AddTorque（世界坐标方向力）"></a>AddTorque（世界坐标方向力）</h2><blockquote>
<p>AddTorque(Vector3.right * 10); 力矩方向给右边 会绕x轴旋转<br>给个力矩就会使这个物体做圆周运动<br>给绕哪一个轴旋转的力矩 就会绕哪个轴旋转</p>
</blockquote>
<h2 id="AddRelativeTorque（相对坐标方向力，模型坐标）"><a href="#AddRelativeTorque（相对坐标方向力，模型坐标）" class="headerlink" title="AddRelativeTorque（相对坐标方向力，模型坐标）"></a>AddRelativeTorque（相对坐标方向力，模型坐标）</h2><h2 id="物理管理器"><a href="#物理管理器" class="headerlink" title="物理管理器"></a>物理管理器</h2><ul>
<li>Gravity 重力,设置重力的大小和方向;</li>
<li>Default Material：为每个物体给一个默认的物理材质;</li>
<li>Bounce Threshold 反弹阈值,低于这个不进行反弹计算;</li>
<li>SleepThreshold 休眠阈值能量低于这个阈值休眠 E = (sqrt(v) + sqrt(A)) * 0.5<blockquote>
<p>v 速度 A 角度</p>
</blockquote>
</li>
<li>Default Contact offset 默认接触偏差,低于该值认为刚体已经接触必须&gt;0;</li>
<li>Solver Iteration Count 关节和连接迭代次数;</li>
<li>Raycasts Hit Triggers 射线是否命中触发器, true检测命中, false忽略触发器;</li>
<li>Enable Adaptive Force 允许自适应力 修正模拟运动状态的数值偏差;碰撞矩阵,配置层级间的碰撞关系;</li>
</ul>
<h2 id="物理形状-碰撞器"><a href="#物理形状-碰撞器" class="headerlink" title="物理形状/碰撞器"></a>物理形状/碰撞器</h2><ul>
<li>Box Collider 盒子碰撞器;</li>
<li>Sphere Collider 球体碰撞器</li>
<li>Capsule Collider 胶囊碰撞器;</li>
<li>Mesh Collider  网格碰撞器（使用这个的物体不能直接加刚体 unity 5.0）;<blockquote>
<p>或勾选刚体的 <code>Is Kinematic</code></p>
</blockquote>
</li>
<li>Terrian Collider 地形碰撞器;</li>
<li>Wheel Collider 车轮碰撞器;</li>
</ul>
<h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><blockquote>
<p>每种物体的弹力，摩擦力等物理参数可能不一样，unity使用物理材质来描述它们;</p>
<ul>
<li>Dynamic Friction 滑动摩擦(动态摩擦)</li>
<li>Static Firction 静态摩擦</li>
<li>Bounciness 表面弹性;</li>
<li>Friction Combine 摩擦力的混合方式</li>
<li>Bounciness Combine 弹力的混合方式;</li>
</ul>
</blockquote>
<ul>
<li>Bounce Combine<ul>
<li>Average 平均值<blockquote>
<p>如果一个球弹力为1 地面为0 那么弹一次 就会取他们直接弹力的平均值 弹力有衰减</p>
</blockquote>
</li>
<li>Maximun 最大值<blockquote>
<p>球弹力为1 地面为0 最大值为1 那么球就会一直弹下去 弹力一直为1</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="第三十一课（Unity3D物理引擎-二-刚体碰撞检测配置与触发器配置）"><a href="#第三十一课（Unity3D物理引擎-二-刚体碰撞检测配置与触发器配置）" class="headerlink" title="第三十一课（Unity3D物理引擎(二)刚体碰撞检测配置与触发器配置）"></a>第三十一课（Unity3D物理引擎(二)刚体碰撞检测配置与触发器配置）</h1><p>##　Physics</p>
<blockquote>
<p>类 物理设置 代码设置物理设置</p>
</blockquote>
<p>忽略两个层之间的碰撞<br>Physics.IgnoreLayerCollision(8, 9);</p>
<h1 id="第三十二课（unity-自带摇杆与车轮碰撞器的使用）"><a href="#第三十二课（unity-自带摇杆与车轮碰撞器的使用）" class="headerlink" title="第三十二课（unity_自带摇杆与车轮碰撞器的使用）"></a>第三十二课（unity_自带摇杆与车轮碰撞器的使用）</h1><ul>
<li>WheelCollider<blockquote>
<p>x 用来控制方向 y 用来控制向前还是向后</p>
<ul>
<li>motorTorque：车轮移动的力矩,为正向前，为负向后</li>
<li>steerAngle: 车轮的转向角;</li>
<li>rmp: 每分钟转多少转;<br>(rmp * 360 / 60) 1s转多少度</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li>车轮<blockquote>
<p>车轮碰撞器如果需要阻力（在刚体上加）目前只知道的唯一方法</p>
</blockquote>
</li>
</ul>
<h1 id="第三十三课（unity关节的基本介绍和基本使用）"><a href="#第三十三课（unity关节的基本介绍和基本使用）" class="headerlink" title="第三十三课（unity关节的基本介绍和基本使用）"></a>第三十三课（unity关节的基本介绍和基本使用）</h1><p>unity的帮助手册 组件手册/物理组件/关节组件相关介绍</p>
<blockquote>
<p>关节必须加刚体</p>
</blockquote>
<h2 id="关节"><a href="#关节" class="headerlink" title="关节"></a>关节</h2><blockquote>
<p>链接刚体的</p>
</blockquote>
<ul>
<li><p>铰链关节(hinge Joint)</p>
<blockquote>
<p>将两个刚体束缚在一起，在两者之间产生铰链效果;</p>
</blockquote>
<p>  使用</p>
<blockquote>
<p>Axis 绕选轴开始旋转</p>
<ul>
<li>创建一个圆柱体与一个立方体;</li>
<li>调整他们的大小类是与门的形状;</li>
<li>分别添加刚体组件;</li>
<li>为圆柱体创建一个铰链关节(Hinge Joint)</li>
<li>冻结圆柱体的位置和旋转;</li>
<li>给立方体一个冲量;</li>
</ul>
</blockquote>
</li>
<li><p>固定关节(Fixed Joint)</p>
<blockquote>
<p>将两个刚体束缚在一起, 相对位置保持不变，永远不会变化;</p>
</blockquote>
<p>  使用</p>
<ul>
<li>创建2个球体,分别对2个球体加上刚体组件;</li>
<li>在其中一个球体里面加入固定关节(Fixed Joint),并关联好另外的刚体;</li>
<li>给其中一个刚体一个冲量</li>
</ul>
</li>
<li><p>弹簧关节(Spring Joint)</p>
<blockquote>
<p>将两个刚体束缚在一起, 相对位置保持不变，永远不会变化;</p>
</blockquote>
<p>  使用</p>
<ul>
<li>创建1个立方体(墙)和1个球体,分别对2个物体加上刚体组件;</li>
<li>在其中一个球体里面加入弹簧关节(Spring Joint),并关联好另外的刚体;</li>
<li>给球体一个力;</li>
</ul>
</li>
<li><p>角色关节(Character Joint)</p>
<blockquote>
<p>应用广泛的基本关节,角色关节配合Ragdoll使用,是一个扩展的球窝关节;</p>
</blockquote>
<p>  使用</p>
<ul>
<li>创建2个球体,分别对2个球体加上刚体组件;</li>
<li>在其中一个球体里面加入角色关节(Character Joint),并关联好另外的刚体;</li>
</ul>
</li>
<li><p>可配置关节(Configurable Joint)</p>
<blockquote>
<p>参数可配置，可以穿件很多灵活的关节;<br>  <a href="www.ceeger.com/Components/class-ConfigurableJoint.html">可配置关节属性</a></p>
</blockquote>
<p>  可配置关节使用</p>
<ul>
<li>创建一个立方体，创建一个球体，分别加上刚体组件;</li>
<li>选中立方体，加入可配置关节</li>
<li>X Motion, Y Motion, Z Motion 修改为Locked;</li>
<li>修改立方体的参数，让它固定位置;</li>
</ul>
</li>
</ul>
<h1 id="第三十四（关节案例分析）"><a href="#第三十四（关节案例分析）" class="headerlink" title="第三十四（关节案例分析）"></a>第三十四（关节案例分析）</h1><blockquote>
<p>固定关节如果链接多了，关节质量又不一样的话，会有回弹的效果<br>机械手夹物体<br>导入导出不会导出配置的物理配置/层级关系</p>
</blockquote>
<h1 id="第三十五（蒙皮网格与布料组件的介绍和基本使用）"><a href="#第三十五（蒙皮网格与布料组件的介绍和基本使用）" class="headerlink" title="第三十五（蒙皮网格与布料组件的介绍和基本使用）"></a>第三十五（蒙皮网格与布料组件的介绍和基本使用）</h1><blockquote>
<p>例如要模拟衣服，随风摆动，模拟布料需要用到蒙皮网格和布料;<br>蒙皮网格可以模拟出非常柔软的网格体,用于布料和角色的蒙皮功能；<br>蒙皮网格 + 布料组件能模拟出布料效果；</p>
</blockquote>
<ul>
<li>Skinned Mesh Renderer 蒙皮网格<blockquote>
<p>是一种网格渲染器,是一种渲染网格的方式;</p>
</blockquote>
</li>
<li>布料是Cloth组件;</li>
</ul>
<h1 id="第三十六课（粒子系统和基本使用）"><a href="#第三十六课（粒子系统和基本使用）" class="headerlink" title="第三十六课（粒子系统和基本使用）"></a>第三十六课（粒子系统和基本使用）</h1><ul>
<li><p>unity创建一个粒子 </p>
<ul>
<li>GameObject–&gt; Particle System;</li>
<li>创建一个节点–&gt;添加一个ParticleSystem组件;</li>
</ul>
</li>
<li><p>粒子参数</p>
<ul>
<li><p>粒子系统主体;</p>
<ul>
<li>Duration: 粒子喷射周期;</li>
<li>Looping: 是否循环喷射;</li>
<li>Prewarm: 预热(Loop状态下预产生下一周期的粒子);</li>
<li>StartDelay: 粒子喷射延迟,Prewarm无法延迟;</li>
<li>Start Lifetime: 粒子生命周期;</li>
<li>Start speed: 粒子喷射速度;</li>
<li>Start Rotation: 粒子大小;</li>
<li>Start Color: 粒子颜色；</li>
<li>Gravity Modifier: 相对与重力加速的的重力密度(缩放比);</li>
<li>Inherit Velocity: 新生粒子的继承速度;</li>
<li>Simulation Space: 粒子系统的模拟空间;</li>
<li>Play On Awake: 是否在加载的时候播放;</li>
<li>MaxParticles: 一周内发射的例子数,多与此数目停止发射;</li>
</ul>
</li>
<li><p>喷射(Emission);</p>
</li>
<li><p>形态(shape);</p>
<blockquote>
<p>决定了例子系统喷射的范围;</p>
<ul>
<li>主要的形状有:<ul>
<li>球体(Sphere)</li>
<li>半球体(HemiSphere)</li>
<li>圆锥体 Cone</li>
<li>盒子(Box) </li>
<li>网格(Mesh)</li>
<li>环形(Cricle) </li>
<li>边线(Edge)</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>生命周期内的速度偏移(velocity over lifetime);</p>
</li>
<li>生命周期内的限制速度(limit velocity over lifetime);</li>
<li>生命周期内的受力偏移(Force velocity over lifetime);</li>
<li>生命周期内的颜色(Color velocity over lifetime);</li>
<li>颜色随速度的变化(Color by Speed);</li>
<li>生命周期内的大小(Size over lifetime);</li>
<li>大小随速度变化(Size by speed);</li>
<li>生命周期内的转速(Rotation over lifetime);</li>
<li>角速度随速度变化(Rotation by Speed);</li>
<li>外部作用力(External Forces)</li>
<li>碰撞(Collision)</li>
<li>子发射系统(Sub Eimitters);</li>
<li>纹理层动画(Texture Sheet Animation);</li>
<li>渲染器(Render); </li>
</ul>
</li>
</ul>
<h1 id="第三十七课（初识shader）"><a href="#第三十七课（初识shader）" class="headerlink" title="第三十七课（初识shader）"></a>第三十七课（初识shader）</h1><h2 id="shader概述"><a href="#shader概述" class="headerlink" title="shader概述"></a>shader概述</h2><ul>
<li>Shader是给GPU执行的程序,中文叫做着色器;<ul>
<li>着色器<blockquote>
<p>在GPU画面绘制</p>
</blockquote>
</li>
</ul>
</li>
<li>着色器是运行在图形处理单元上，可以让开发人员直接操作图形硬件渲染功能；</li>
<li>shader能开发出很多好的效果，UV动画，水, 雾 等一些特效, 这些用程序开发出来比较困难，性能还不好;</li>
<li>渲染流水线, 模型投影, 定点着色;</li>
<li>shader一般主要有: <strong>固定管线着色器</strong>,  <strong>顶点片元着色器</strong>, <strong>表面着色器</strong>;<ul>
<li>固定管线着色器(慢慢会被淘汰);</li>
<li>顶点shader: 干预模型形态的shader; </li>
<li>像素shader: 干预像素着色的shader;<blockquote>
<p>模型定点运算的时候，可以加入顶点shader来干预顶点的位置;顶点着色的时候，加入像素shader来干预像素的上色;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="GPU编程语言"><a href="#GPU编程语言" class="headerlink" title="GPU编程语言"></a>GPU编程语言</h2><ul>
<li>什么是Direct3D和opengl;</li>
<li>目前面向GPU的编程语言主要有三种:<ul>
<li>HLSL 语言 通过Direct3D编写的着色器程序，只能在Direct3D里面使用;</li>
<li>Cg 语言 NVIDIA和微软合作提供的语言,与C相似，Direct3D和opengl都支持；</li>
<li>GLSL语言 支持OpenGL上编写Shader程序;</li>
</ul>
</li>
<li>Unity使用ShaderLab来进行着色程序的编写，对不同的平台进行编译，重点支持Cg语言;  </li>
</ul>
<blockquote>
<ul>
<li>Direct3D<br>win微软</li>
<li>opengl<br>安卓、Linux、win以外的平台等</li>
</ul>
</blockquote>
<ul>
<li>定义shader<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个Shader,每一个着色程序都要有一个Shader</span><br><span class="line">Shader “name” &#123; // name shader名字</span><br><span class="line">    // 定义的一些属性，定义在这里的会在属性查看器里面显示; </span><br><span class="line">    [Propeties]  </span><br><span class="line">    // 子着色器列表，一个Shader必须至少有一个子着色器; </span><br><span class="line">    Subshaders: &#123;....&#125;</span><br><span class="line">    // 如果子着色器显卡不支持，就会降级,即Fallback操作;</span><br><span class="line">    [Fallback]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>display name是在属性检查器的名字;<br>type: 这个属性的类型<br>值: 只这个属性的默认值;</p>
<ul>
<li><p>name(“display name”, type) = 值;</p>
<blockquote>
<p>name指的是属性的名字，Unity中用下划线开始_Name;</p>
<ul>
<li>类型(type):<ul>
<li>Float</li>
<li>Int</li>
<li>Color(num, num, num, num)(0 ~ 1) </li>
<li>Vector(4维向量)</li>
<li>Range(start, end)</li>
</ul>
</li>
<li>纹理属性<ul>
<li>2D: 2D纹理属性;</li>
<li>Rect: 矩形纹理属性;</li>
<li>Cube: 立方体纹理属性;</li>
<li>3D: 3D纹理属性;</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>name(“displayname”, 2D) = “name” {options}</p>
<ul>
<li>Options: 纹理属性选项<ul>
<li>TexGen:纹理生成模式,纹理自动生成纹理坐标的模式;顶点shader将会忽略这个选项; </li>
<li>ObjectLinear, EyeLinear, SphereMap, CubeReflect CubeNormal</li>
<li>LightmapMod: 光照贴图模式如果设置这个选项,纹理会被渲染器的光线贴图所影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>定义</p>
<ul>
<li>_Range (“range value”, Range(0, 1)) = 0.3; // 定义一个范围</li>
<li>_Color(“color”, Color) = (1, 1, 1, 1); // 定义一个颜色</li>
<li>_FloatValue(“float value”, Float) = 1 // 定义一个浮点</li>
<li>_MainTex (“Albedo”, Cube) = “skybox” {TexGen CubeReflect} // 定义一个立方贴图纹理属性;</li>
</ul>
</li>
</ul>
<h2 id="Subshaders"><a href="#Subshaders" class="headerlink" title="Subshaders"></a>Subshaders</h2><ul>
<li><p><code>SubShader {[Tags], [CommonState], Pass {} }</code>子着色器由 标签(Tags),通用状态,通道列表组成,它定义了一个渲染通道列表，并可选为所有通道初始化需要的通用状态;</p>
<ul>
<li>Tags {“标签1” = “value1” “key2” = “value2”}<ul>
<li>标签的类型:<ul>
<li>Queue tag 队列标签;</li>
<li>RenderType tag  渲染类型标签;</li>
<li>DisableBatching tag 禁用批处理标签;</li>
<li>ForceNoShadowCasting Tag 强制不投阴影标签;</li>
<li>IgnoreProjecttor 忽略投影标签;</li>
<li>CanUseSpriteAtlas Tag,使用精灵图集标签;</li>
<li>PreviewType Tag预览类型标签;</li>
</ul>
</li>
</ul>
</li>
<li>Pass<ul>
<li>subshader 包装了一个渲染方案，这些方案由一个个通道(Pass)来执行的，SubShader可以包括很多通道块,每个Pass都能使几何体渲染一次;</li>
<li>Pass基本语法:<ul>
<li><code>Pass { [Name and Tags] [RenderSetup] [Texture Setup]}</code>Pass块的Name引用此Pass,可以在其它着色器的Pass块中引用它，减少重复操作,<strong>Name命令必须大写</strong>;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SubShader渲染的时候，将优先渲染一个被每个通道所定义的对象。</p>
</li>
<li><p>通道的类型: </p>
<ul>
<li>RegularPass<ul>
<li>Lighting 光照: 开启关闭定点光照 On/Off</li>
<li>Material{材质块}: 材质,定义一个使用定点光照管线的材质;</li>
<li>ColorMaterial: 颜色集 计算定点光照的时使用顶点颜色;</li>
<li>SeparateSpecular: 开光状态 开启或关闭顶点光照相关的镜面高光颜色，On/Off;</li>
<li>Color 设置定点光照关闭时的所使用的颜色;</li>
<li>Fog{雾块}: 设置雾参数;</li>
<li>AlphaTest: Alpha测试</li>
<li>ZTest: 深度测试模式;</li>
<li>ZWrite: 深度写模式;</li>
<li>Blend: 混合模式 SourceBlendMode, DestBlendMode, AlphaSourcesBlendMode, AlphaDstBlendMode;</li>
<li>ColorMask 颜色遮罩: 设置颜色遮罩,颜色值可以由RGB或A或0或R,G,B,A的组合,设置为0关闭所有颜色通道渲染;</li>
<li>Offset偏移因子: 设置深度偏移;</li>
</ul>
</li>
<li>特殊通道(UsePass/GrabPass)<ul>
<li>UsePass<ul>
<li>UsePass: 插入所有来自其它着色器的给定名字的通道;</li>
<li>UsePass ”Shader/Nmae”, Name为着色器通道;</li>
<li>UsePass “Specular/BASE” // 插入Specular中为Bass的通道;</li>
</ul>
</li>
<li>GrabPass<ul>
<li>GrabPass {}: 一种特殊通道类型，他会捕获物体所在的位置的屏幕的内容，并写入一个纹理中，这个纹理能被用于后续通道中完成一些高级图像特效,后续通道可以使用_GrabTexture进行访问(访问上一次截取到的);</li>
<li>GrabPass{“纹理名称”} 捕获屏幕内容到指定纹理中，后续通道可以通过纹理名称来访问;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在通道中定义状态同时对整个子着色器可见，那么所有的通道可以共享状态;</p>
</li>
</ul>
<p>通道示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags &#123;“Queue”, “Transparent” &#125;</span><br><span class="line">    Pass &#123;</span><br><span class="line">        Lighting Off   // 关闭光照</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>shader通过通道来进行达到不同显示的渲染</p>
<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><blockquote>
<ul>
<li>降级: 定义在所有子着色器之后,如果没有任何子着色器能运行，则尝试降级;</li>
<li>Fallback “着色器名称”;</li>
<li>Fallback Off;<br><strong>没有降级，并且不会打印任何警告</strong>;</li>
</ul>
</blockquote>
<h2 id="Category分类"><a href="#Category分类" class="headerlink" title="Category分类"></a>Category分类</h2><ul>
<li>分类是渲染命令的逻辑组。例如着色器可以有多个子着色器,他们都需要关闭雾效果，和混合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 所有的shader将把 这个给设置为Mode Off</span><br><span class="line">Shader “xxxx” &#123;</span><br><span class="line">Categroy &#123;</span><br><span class="line">     Fog &#123; Mode Off &#125;</span><br><span class="line">     SubShader &#123;...&#125;</span><br><span class="line">     SubShader &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第三十八课（unity-顶点片元shader与第一个shader）"><a href="#第三十八课（unity-顶点片元shader与第一个shader）" class="headerlink" title="第三十八课（unity_顶点片元shader与第一个shader）"></a>第三十八课（unity_顶点片元shader与第一个shader）</h1><h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><ul>
<li>物体空间: 3D物体自己的坐标空间 一般设计时几何体以中心为原点,人物以双脚为原点;</li>
<li>世界空间: 3D物体在场景中的世界坐标, 整个游戏场景的空间;</li>
<li>摄像机空间: 以观察摄像机为原点的坐标系下的坐标空间;</li>
<li>投影成像  3D坐标转换到屏幕空间;</li>
</ul>
<h2 id="Unity坐标系转换"><a href="#Unity坐标系转换" class="headerlink" title="Unity坐标系转换"></a>Unity坐标系转换</h2><ul>
<li>transform.localToWorldMatrix   局部转世界的矩阵;</li>
<li>transfrom.worldToLocalMatrix  世界坐标转局部坐标矩阵;</li>
<li>MultiplyPoint, MultiplyPoint3x4 MultiplayVector 来进行坐标变换;</li>
<li>shader中 左乘unity_WorldToObject矩阵来实现世界坐标转局部坐标变换;</li>
<li>shader中左乘unity_ObjectToWorld矩阵来实现局部转世界的转换; </li>
<li>UNITY_MATRIX_MV 基本变换矩阵 x 摄像机矩阵;</li>
<li>UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵;</li>
<li>UNITY_MATRIX_V 摄像机矩阵;</li>
<li>UNITY_MATRIX_P 投影矩阵;</li>
<li>UNITY_MATRIX_VP摄像机矩阵x投影矩阵;</li>
<li>UNITY_MATRIX_T_MV (基本变换矩阵 x 摄像机矩阵) 转置矩阵;</li>
<li>UNITY_MATRIX_IT_MV(基本变换矩阵 x 摄像机矩阵) 的逆转置矩阵;</li>
<li>UNITY_MATRIX_TEXTURE0 纹理变化矩阵;</li>
</ul>
<h2 id="GPU管道流水线"><a href="#GPU管道流水线" class="headerlink" title="GPU管道流水线"></a>GPU管道流水线</h2><blockquote>
<p><img src="unity学习笔记/38_1.png" alt="图片暂时没有哦"></p>
</blockquote>
<h2 id="顶点片元着色器"><a href="#顶点片元着色器" class="headerlink" title="顶点片元着色器"></a>顶点片元着色器</h2><ul>
<li>优点<blockquote>
<ul>
<li>控制灵活</li>
</ul>
</blockquote>
</li>
<li>缺点<blockquote>
<ul>
<li>不能参与光照计算;</li>
</ul>
</blockquote>
</li>
<li>在着色器中插入Cg代码段,编写在 <code>CGPROGRAM</code> 与 <code>ENDCG</code> 之间;</li>
<li>编译指令: #pragma控制 着色器代码编译;<ul>
<li><code>#pragma vertex name</code> 将名称为 name 的函数编译为顶点着色器;</li>
<li><code>#pragma fragment name</code> 将名称为 name 的函数编译为片元着色器;</li>
</ul>
</li>
<li>参数和返回值有语义修饰</li>
</ul>
<h2 id="常用语义"><a href="#常用语义" class="headerlink" title="常用语义"></a>常用语义</h2><ul>
<li>POSITION : 位置</li>
<li>TANGENT : 切线</li>
<li>NORMAL: 法线</li>
<li>TEXCOORD0: 第一套纹理</li>
<li>TEXCOORD1: 第二套纹理</li>
<li>TEXCOORD2: 第三套纹理</li>
<li>TEXCOORD3: 第四套纹理</li>
<li><p>COLOR: 颜色</p>
</li>
<li><p>为什么加语义</p>
<blockquote>
<p>加语义是为了获取上一个工位的参数，完成之后也要语义，要传给下一个工位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    // 渲染通道</span><br><span class="line">    Pass &#123;</span><br><span class="line">        // 代码的入口</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            // 顶点着色器的入口</span><br><span class="line">            #pragma vertex my_vertex</span><br><span class="line">            // 怎么获取上一个工位的参数(语义绑定：看你需要上一个工位的什么工参数 就语义绑定什么参数)</span><br><span class="line">            // 需要获取上一个工位的 position</span><br><span class="line">            // 怎么把结果返回下一个工位(语义绑定：看你需要传递什么参数给下一个工位 就语义绑定什么参数)</span><br><span class="line">            // 需要把结果 position 给下一个工位</span><br><span class="line"></span><br><span class="line">            float4 my_vertex(float4 pos : POSITION) : POSITION&#123;</span><br><span class="line">                // UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵;把这个pos转换为 投影矩阵给下一个工位的position</span><br><span class="line"></span><br><span class="line">                // unity5.6以前的写法  </span><br><span class="line">                // o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);    </span><br><span class="line"></span><br><span class="line">                // unity5.6以后的写法</span><br><span class="line">                // o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                return UnityObjectToClipPos(pos);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 片元着色器的入口</span><br><span class="line">            #pragma fragment my_fragment</span><br><span class="line"></span><br><span class="line">            // fixed4能保存颜色的数据类型</span><br><span class="line">            // 把 color 返回给下一个工位 所有用来语义绑定 : COLOR</span><br><span class="line">            fixed4 my_fragment() : COLOR&#123;</span><br><span class="line">                // 把红色返回给下一个工位进行渲染</span><br><span class="line">                return fixed4(1.0, 1.0, 0.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="第三十九课（unity-Cg基础知识和基本使用）"><a href="#第三十九课（unity-Cg基础知识和基本使用）" class="headerlink" title="第三十九课（unity_Cg基础知识和基本使用）"></a>第三十九课（unity_Cg基础知识和基本使用）</h1><h2 id="基本类型表达式"><a href="#基本类型表达式" class="headerlink" title="基本类型表达式"></a>基本类型表达式</h2><pre><code>* 语法和C语言类是,有对应的编译器,程序是给显卡运行;
* 可以从渲染流水线中获得对应的输入;
* 指定的输出能流入下一个流水线模块;
* 操作符号和C语言一样，可以使用 +, -, * /  &lt;, &gt;, &lt;=, &gt;= 等运算;
* Cg提供了float half double 浮点类型;
* Cg 支持定点数 fixed来高效处理 某些小数;
* Cg使用int来表示整数;
* bool 数据类型来表示逻辑类型;
* sampler*,纹理对象的句柄, sampler/1D/2D/3D/CUBE/RECT
* 内置向量数据类型: float4(float, float, float, float), 向量长度不能超过4;
* 内置矩阵数据类型: float1x1 float2x3 float4x3 float4x4;不能超过4x4;
* 数组类型float a[10]; 10个float, float4 b[10], 10个float4;
* 语义绑定 float4 a : POSITION,返回值也可以语义绑定;
</code></pre><p>##　结构体与语义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct name &#123;</span><br><span class="line">    // 类型 名字; </span><br><span class="line">    // 尽量不要使用;</span><br><span class="line">    返回值 函数名称(参数) &#123;</span><br><span class="line">        // 如果成员函数里面使用，数据成员，该成员定义在函数前;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>输入语义与输出语义:<ul>
<li>语义: 一个阶段处理数据，然后传输给下一个阶段，那么每个阶段之间的接口, 例如：顶点处理器的输入数据是处于模型空间的顶点数据（位置、法向量），输出的是投影坐标和光照颜色；片段处理器要将光照颜色做为输入;C/C++用指针，而Cg通过语义绑定的形式;</li>
<li>输入语义: 绑定接收参数,从上一个流水线获得参数;</li>
<li>输出语义: 绑定输出参数到下一个流水线模块;</li>
<li>语义: 入口函数上有意义(顶点着色入口,像素着色入口)，普通的函数无意义;</li>
</ul>
</li>
</ul>
<h2 id="标准内置函数"><a href="#标准内置函数" class="headerlink" title="标准内置函数"></a>标准内置函数</h2><ul>
<li>abs(num)绝对值;</li>
<li>三角函数;</li>
<li>cross(a, b) 两个向量的叉积;</li>
<li>determinant(M)矩阵的行列式;</li>
<li>dot(a, b) 两个向量的点积;</li>
<li>floor(x)向下取整;</li>
<li>lerp(a, b, f), 在a, b之间线性插值;</li>
<li>log2(x) 基于2为底的x的对数;</li>
<li>mul(m, n): 矩阵x矩阵, 矩阵x向量, 向量x矩阵;</li>
<li>power(x, y) x的y次方;</li>
<li>radians(x) 度转弧度;</li>
<li>reflect(v, n) v 关于法线n的反射向量;</li>
<li>round(x) 靠近取整;</li>
<li>tex2D(smapler, x) 二维纹理查找</li>
<li>tex3Dproj(smapler, x) 投影三维纹理查找;</li>
<li>texCUBE 立方体贴图纹理查找;</li>
<li>distance 计算点的距离</li>
</ul>
<h2 id="Unity自带函数"><a href="#Unity自带函数" class="headerlink" title="Unity自带函数"></a>Unity自带函数</h2><ul>
<li>引用Unity自带的函数库: <code>#include “UnityCG.cginc” Unity--&gt;Edit--&gt;Data--&gt;CGIncludes;</code></li>
<li>TRANSFORM_TEX: 根据顶点的纹理坐标，计算出对应的纹理的真正的UV坐标;</li>
<li>使用属性的变量: 在shader里面需要使用属性变量还需要在shader中定义一下这个变量的类型和名字;<strong>名字要保持一致</strong>;</li>
<li>外部修改shader的编辑器上的参数值;</li>
</ul>
<h1 id="第四十课（顶点片元Shader实例-正波-UV动画）"><a href="#第四十课（顶点片元Shader实例-正波-UV动画）" class="headerlink" title="第四十课（顶点片元Shader实例_正波_UV动画）"></a>第四十课（顶点片元Shader实例_正波_UV动画）</h1><blockquote>
<p>顶点片元 Shader Unlit Shader</p>
</blockquote>
<h2 id="float4-fixed4-Time"><a href="#float4-fixed4-Time" class="headerlink" title="float4 fixed4 _Time"></a>float4 fixed4 _Time</h2><ul>
<li>float4是内置向量 (x, y, z, w);   float4 a; 访问单独成员a.x, a.y, a.z, a.w;</li>
<li>fixed4 是内置向量(r, g, b, a);   fixed4 c; color.r, color.g, color.b, color.a;</li>
<li>float3是内置向量(x, y, z);</li>
<li>fixed3 是内置向量(r, g, b);</li>
<li>float2 是内置向量(x, y);</li>
<li>_Time: 自场景加载开始所经过的时间t，4个分量分别是 (t/20, t, t<em>2, t</em>3);</li>
<li>_SinTime:  t 是时间的正弦值，4个分量分别是 (t/8, t/4, t/2, t);</li>
<li>_CosTime: t 是时间的余弦值，4个分量分别是 (t/8, t/4, t/2, t);</li>
<li>unity_DeltaTime: dt 是时间增量，4个分量的值(dt, 1/dt, smoothDt,  1/smoothDt),平滑时间，防止时间间隔起伏太大;</li>
</ul>
<h1 id="第四十一课（表面着色器的基础知识和shader结构）"><a href="#第四十一课（表面着色器的基础知识和shader结构）" class="headerlink" title="第四十一课（表面着色器的基础知识和shader结构）"></a>第四十一课（表面着色器的基础知识和shader结构）</h1><blockquote>
<p>标准的表面着色器 Standerd Surface Shader</p>
</blockquote>
<ul>
<li>表面着色器包括4个函数:<ul>
<li>顶点变换函数;</li>
<li>表面着色函数;</li>
<li>光照模型;</li>
<li>最终颜色修改函数;<blockquote>
<p>1 3 4可选<br>表面着色器最终会被编译为一个复杂的顶点着色程序;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><ul>
<li><code>#pragma surface</code> 入口函数名称 光照模型  [Options] </li>
<li>suface 后面跟 表面着色的入口函数  surf(Input IN, inout SurfaceOutput o);<ul>
<li>Input 结构附加数据<ul>
<li>Input:<strong>包含着色所需要的纹理坐标　uv纹理名字;使用第二张纹理是uv2纹理名字;</strong><blockquote>
<p>附加数据:</p>
<ul>
<li>float3 viewDir  视图方向。</li>
<li>float4 color 每个顶点的颜色插值</li>
<li>float4 screenPos 屏幕空间中的位置。</li>
<li>float3 worldPos 世界坐标空间;   </li>
<li>float3 worldRef1 世界空间中的反射向量;</li>
<li>float3 worldNormal 世界空间中的法线向量;</li>
<li>float3 worldRef1; INTERNAL_DATA 世界坐标反射向量, 但必须表面着色写入o.Normal参数;</li>
<li>float3 worldNormal; INTERNAL_DATA 世界坐标法线向量, 但必须表面着色写入o.Normal参数;</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>SurfaceOutput 结构体<ul>
<li>SurfaceOutput：<ul>
<li>half3 Albedo: 漫反射的颜色值;</li>
<li>half3 Normal: 法线坐标;</li>
<li>half3 Emission; 自发光颜色;</li>
<li>half Specular;  镜面反射系数;</li>
<li>half Gloss; 光泽系数;</li>
<li>half Alpha; 透明度系数;</li>
</ul>
</li>
<li>SurfaceOutputStandard(继承上方)：<ul>
<li>half Smoothness;    // 0=粗糙, 1=光滑</li>
<li>half Metallic;    // 0=非金属, 1=金属</li>
</ul>
</li>
<li>SurfaceOutputStandardSpecular(继承上方):<ul>
<li>fixed3 Albedo;     </li>
<li>fixed3 Specular;    </li>
<li>fixed3 Normal;     </li>
<li>half3 Emission;  </li>
<li>half Smoothness;    // 0=粗糙, 1=光滑  </li>
<li>half Occlusion;  // 遮挡(默认1)  </li>
<li>fixed Alpha;  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>光照模型： <ul>
<li>系统内置 Lambert(漫反射光照) BlinnPhong (高光光照)</li>
<li>自定义光照: 名字为Name <ul>
<li>half4 Lighting<name>(SurfaceOutput s, half3 lightDir, half atten);</name></li>
<li>half4 Lighting<name>(SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);</name></li>
<li>half4 Lighting<name>(SurfaceOutput s, half4 light);<br>可选参数(Options):</name></li>
</ul>
</li>
</ul>
</li>
<li><code>vertex: name vertex</code>顶点着色器入口函数: <ul>
<li>void <name> (inout appdata_full v) 只需改顶点着色器中的输入顶点数据;</name></li>
<li>half4 <name>(inout appdata_full v, out Input o) 修改输入顶点数据,以及为表面着色器传递数据;</name></li>
</ul>
</li>
<li><code>finalcolor: name</code> 最终颜色修改函数:<br>  void <name>(Input IN, SurfaceOutput o, inout fixed4 color);</name></li>
</ul>
<h2 id="其它可选参数"><a href="#其它可选参数" class="headerlink" title="其它可选参数"></a>其它可选参数</h2><ul>
<li>alpha: Alpha 混合模式，用户半透明着色器;</li>
<li>alphatest: varirableName Alpha测试模式，用户透明镂空着色器。</li>
<li>exclude_path:prepass 使用指定的渲染路径;</li>
<li>addshadow: 添加阴影投射器和集合通道;</li>
<li>dualforward: 将双重光照贴图用于正向渲染路径中;</li>
<li>fullforwardshadows 在正向渲染路径中支持的所有的阴影类型;</li>
<li>decal: add 附加印花着色器;</li>
<li>decal: blend 附加半透明印花着色器;</li>
<li>softvegetation 使用表面着色器，仅在Soft Vegetation 开启时被渲染;</li>
<li>noambient 不使用任何光照</li>
<li>novertexlights 在正向渲染中不适用球面调和光照或逐点光照;</li>
<li>nolightmap 在这个着色器上禁用光照贴图;</li>
<li>nodirlightmap 在这个着色器上禁用方向光照贴图;</li>
<li>noforwardadd 禁用正向渲染添加通道;</li>
<li>approxview: 对于有需要的着色器，逐顶点而不是逐像素计算规范化视线方向。</li>
<li>halfasview:  将半方向传递到光照函数中。</li>
</ul>
<h2 id="Unity坐标系转换-1"><a href="#Unity坐标系转换-1" class="headerlink" title="Unity坐标系转换"></a>Unity坐标系转换</h2><ul>
<li>transform.localToWorldMatrix   局部转世界的矩阵;</li>
<li>transfrom.worldToLocalMatrix  世界坐标转局部坐标矩阵;</li>
<li>MultiplyPoint, MultiplyPoint3x4 MultiplayVector 来进行坐标变换;</li>
<li>shader中 左乘unity_WorldToObject矩阵来实现世界坐标转局部坐标变换;</li>
<li>shader中左乘unity_ObjectToWorld矩阵来实现局部转世界的转换; </li>
<li>UNITY_MATRIX_MV 基本变换矩阵 x 摄像机矩阵;</li>
<li>UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵;</li>
<li>UNITY_MATRIX_V 摄像机矩阵;</li>
<li>UNITY_MATRIX_P 投影矩阵;</li>
<li>UNITY_MATRIX_VP摄像机矩阵x投影矩阵;</li>
<li>UNITY_MATRIX_T_MV (基本变换矩阵 x 摄像机矩阵) 转置矩阵;</li>
<li>UNITY_MATRIX_IT_MV(基本变换矩阵 x 摄像机矩阵) 的逆转置矩阵;</li>
<li>UNITY_MATRIX_TEXTURE0 纹理变化矩阵;</li>
</ul>
<h1 id="第四十二课（通用管道的通用指令-一-LOD与渲染队列）"><a href="#第四十二课（通用管道的通用指令-一-LOD与渲染队列）" class="headerlink" title="第四十二课（通用管道的通用指令(一) LOD与渲染队列）"></a>第四十二课（通用管道的通用指令(一) LOD与渲染队列）</h1><h2 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h2><p>根据不同的LOD版本使用不同版本的shader（subshader可以写多个，但是只会执行一个，如果都不执行，那么就会执行fallback “Diffuse”）</p>
<blockquote>
<p>外部设置LOD值,每个Subshader有个内部LOD值，(找到第一个大于或等于)当<strong>外部设置maximumLOD这个值大于等于这Subshader内部LOD值的时候就执行这个Subshader</strong>(根据设置LOD值来取决于执行哪一个Subshader)<br><strong>也可以说Subshader内部LOD值小于等于 外部设置maximumLOD 最大值的时候就执行这个Subshader</strong></p>
<ul>
<li>LOD Level of Detail, 根据LOD来设置使用不同版本的Shader;</li>
<li>着色器中给SubShader一个LOD值，程序来设置这个shader的LOD值，只有第一个大于等于LOD值subShader才会被执行;</li>
<li>每个shader最多只会有一个SubShader被使用;</li>
<li>通过Shader maximumLOD来设置最大的LOD值;</li>
<li>设置全局的LOD值，Shader.globalMaximumLOD;</li>
<li>Unity内置着色器分LOD等级:<ul>
<li>VertexLit kind of shaders 100</li>
<li>Decal, Reflective VertexLit 150</li>
<li>Diffuse 200</li>
<li>Difuse Detail  250</li>
<li>Bumped, Specular   300</li>
<li>BumpedSpecular  400</li>
<li>Parallax   500</li>
<li>Parallax Specular 600<br>如果需要写多个Subshader并想通过修改maximumLOD来进行改变使用哪一个shader一定要注意<br>内部Subshader的LOD值一定要<strong>从大到小排序</strong>(找到第一个小于或等于的颜色 可能进行覆盖)，不然可能会造成和想象不一样的结果</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h2><blockquote>
<p><strong>先绘制前面和2D(后向前)不一样</strong></p>
</blockquote>
<ul>
<li>渲染队列(Queue)标签可选值:<ul>
<li>Background 背景,对应的值为1000;</li>
<li>Geometry(default) 几何体对应的值为2000, 这个队列是默认的渲染队列,大多数不透明的物体;</li>
<li>AlphaTest Alpha测试,对应值为2450, alpha测试的几何体使用这种队列,它是独立于 Geometry的队列,它可以在所有固体对象绘制后更有效的渲染采用Alpha测试的对象;</li>
<li>Transparent:透明，对应值3000, 这个渲染队列在Geometry被渲染，采用从后向前的次序;<br>任何有alpha混合的对象都在这个队列里面渲染;</li>
<li>Overlay 覆盖对应值为4000, 这个渲染队列是最后渲染的物体;</li>
</ul>
</li>
<li>Unity 渲染模式: <blockquote>
<p>可通过shader设置 <code>&quot;Queue&quot;=&quot;Geometry+100&quot;</code>+不能有空格带上这个shader的物体将会被先渲染(ZTest off 的情况 关闭深度测试)</p>
<ul>
<li><strong>普通物体从前向后, Alpha从后向前</strong>;</li>
<li><strong>渲染队列的数值决定了Unity在渲染场景物体时的先后顺序(越大越先),关闭深度测试的情况下</strong>;</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="第四十三课（unity-渲染通道通用指令-二-）"><a href="#第四十三课（unity-渲染通道通用指令-二-）" class="headerlink" title="第四十三课（unity_渲染通道通用指令(二)）"></a>第四十三课（unity_渲染通道通用指令(二)）</h1><blockquote>
<p>混合模式、Alpha测试、深度测试、通道遮罩、面剔除</p>
</blockquote>
<h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><ul>
<li>在所有计算完成后，决定当前的计算结果输出到帧缓冲区时，如何混合源和目标,通常用来绘制半透明的物体;</li>
<li>Blend Off 关闭混合</li>
<li>Blend 源因子，目标因子: 配置并开启混合，产生的颜色和因子相乘，然后两个颜色相加</li>
<li>Blend 源因子,目标因子, 源因子A，目标因子A： 源因子与目标因子用户混合颜色值，源因子A，与目标因子A，用于混合alpha</li>
<li>BlendOp操作命令: 不是将颜色混合在一起，而是对他们进行操作，主要有:<br>Min, Max, Sub, RevSub</li>
<li>混合因子的类型：<ul>
<li>One 使用源或目标色完全显示出来;                 <ul>
<li>OneMinusSrcColor 阶段值 (1-源颜色的值)</li>
</ul>
</li>
<li>Zero 删除源颜色或目标颜色;                             <ul>
<li>OneMinusSrcAlpha 阶段值 (1-源颜色的Alpha值)</li>
</ul>
</li>
<li>SrcColor 这个阶段的值*源颜色值;                    <ul>
<li>OneMinusDstColor 阶段值 (1-目标颜色的值);</li>
</ul>
</li>
<li>DstColor 这个阶段的值* 帧缓冲颜色值;         <ul>
<li>OneMinusDstAlpha 阶段值 * (1-目标颜色Alpha值)</li>
</ul>
</li>
<li>DstAlpha 这个阶段的值 * 帧缓冲源Alpha值   </li>
<li>SrcAlpha 这个阶段的值 * 源颜色Alpha值</li>
</ul>
</li>
<li>一般放在放在Pass通道里面<blockquote>
<p>设置混合模式: Blend SrcAlpha OneMinusSrcAlpha;(再设置<code>&quot;Queue&quot;=&quot;Transparent&quot;</code> 可见Alpha)<br>  源因子 [SrcAlpha 这个阶段的值 * 源颜色Alpha值] + 目标因子 [OneMinusSrcAlpha 阶段值 (1-源颜色的Alpha值)]</p>
</blockquote>
</li>
</ul>
<h2 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h2><ul>
<li>Alpha测试: 阻止片元被写到屏幕的最后机会, 最终渲染出来的颜色计算出来后可通过透明度和最后一个固定值比较，如果通过测试则绘制次片元，否则丢弃此片元;</li>
<li>AlphaTest Off/On: 开启/关闭Alpha测试,默认是关闭的;</li>
<li>比较测试值的模式:<ul>
<li>Greater &gt;,  GEqual &gt;=, Less &lt;, LEqual &lt;=, Equal ==, NotEqual !=, </li>
<li>Always (永远渲染), Never(从不渲染);</li>
</ul>
</li>
<li>AlphaTest 条件 [变量] / 常数,<blockquote>
<p>变量加上[变量名]</p>
</blockquote>
</li>
<li>一般放在放在Pass通道里面;</li>
</ul>
<p>##　深度测试</p>
<ul>
<li>为了使近距离的物体挡住远距离的物体，当片元写入到缓冲的时候，需要将片元的深度值与缓冲区的深度值进行比较，测试成功写入帧缓冲区;</li>
<li>ZWrite  深度写开关, 控制是否将深度Z的片元写入缓冲区中，如果不绘制透明物体设置为On, 否则的话设置为Off，默认为On;</li>
<li>ZTest 深度测试模式: 设置深度测试的执行方式，默认为LEqual,深度测试的模式:<br>  Less &lt;, Greater &gt;, LEqual &lt;= , GEqual &gt;=, Equal ==, NotEqual !=, Always 总是绘制,关闭深度测试;</li>
<li>ZTest 条件</li>
<li>一般放在放在Pass通道里面;</li>
</ul>
<h2 id="通道遮罩"><a href="#通道遮罩" class="headerlink" title="通道遮罩"></a>通道遮罩</h2><ul>
<li>通道遮罩可以是开发人员指定渲染结果输出的通道，而不是通常情况下的RGBA四个通道;</li>
<li>可选的是RGBA的任意组合以及0，如果为0意味着不会写入到任何通道;</li>
<li>ColorMask RGBA(可选)</li>
<li>ColorMask 0什么也不输出</li>
</ul>
<h2 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h2><ul>
<li>通过不渲染背对摄像机的几何体的面来提高性能优化错误，所有的几何体都包含正面和反面</li>
<li>面剔除操作，大多数都是封闭的物体，所以不需要绘制背面;</li>
<li>面剔除操作: <ul>
<li>Cull Back: 不绘制背对摄像机的面，默认项</li>
<li>Cull Front,  不绘制面向摄像机的面,</li>
<li>Cull Off, 关闭面剔除操作</li>
</ul>
</li>
</ul>
<h1 id="第四十四课（unity-Shader抓屏通道-多条件编译-Shader注意事项）"><a href="#第四十四课（unity-Shader抓屏通道-多条件编译-Shader注意事项）" class="headerlink" title="第四十四课（unity_Shader抓屏通道_多条件编译_Shader注意事项）"></a>第四十四课（unity_Shader抓屏通道_多条件编译_Shader注意事项）</h1><h2 id="GrabPass"><a href="#GrabPass" class="headerlink" title="GrabPass"></a>GrabPass</h2><ul>
<li>使用抓屏通道, GrabPass {} 或 GrabPass { “ 纹理名称”}; _GrabTexture 变量访问</li>
<li>后续的Pass通道使用这个抓屏;</li>
<li>编写案例<ul>
<li>创建一个顶点片元着色器;</li>
<li>将这个着色器放到Overlay队列(保证绘制在最上层)</li>
<li>使用GrabPass通道截屏，并定义好变量来接收</li>
<li>设置顶点的UV坐标;</li>
<li>着色使用截图的纹理</li>
</ul>
</li>
</ul>
<h2 id="常用的gcinc"><a href="#常用的gcinc" class="headerlink" title="常用的gcinc"></a>常用的gcinc</h2><ul>
<li>cginc文件: 宏，帮助函数等，放在CGIncludes下面，开发人员可以开发自己的cginclude文件</li>
<li>常用的cginc文件: <ul>
<li>HLSL.Support.cginc 协助多平台开发的一些宏等，自动包含</li>
<li>UnityShaderVarirables.cginc 全局变量，自动包含；</li>
<li>UnityCG.cginc 常用的帮助函数;</li>
<li>AutoLight.cginc 光照和阴影功能；</li>
<li>Lighting.cginc 表面着色器的光照模型;</li>
<li>TerrainEngine.cginc 地形植被的光照着色函数;</li>
</ul>
</li>
</ul>
<h2 id="UnityCG-gcinc常用函数"><a href="#UnityCG-gcinc常用函数" class="headerlink" title="UnityCG.gcinc常用函数"></a>UnityCG.gcinc常用函数</h2><ul>
<li>UnityWorldSpaceViewDir: 给定对象空间的顶点位置朝向摄像机方向的世界坐标空间方向;</li>
<li>ObjSpaceViewDir: 给定对象空间的顶点位置朝向摄像机方向的对象空间方向;</li>
<li>ParallaxOffset: 计算用于视差法线贴图的UV偏移量;</li>
<li>Luminance: 将颜色转为亮度;</li>
<li>DecodeLightmap: 从光照贴图中解码颜色;</li>
<li>float EncodeFloatRGBA(float4 rgba): 将RGBA颜色编码为[0,1)的浮点数；</li>
<li>float4 DecodeFloatRGBA(float v): 将一个浮点数解码为RGBA的颜色;</li>
<li>UnityWorldSpaceLightDir 给定对象空间的顶点位置到光源的世界坐标空间方向;</li>
<li>ObjSpaceLightDir: 给定对象空间的顶点位置到光源的对象空间方向;</li>
</ul>
<h2 id="UsePass-通道-复用"><a href="#UsePass-通道-复用" class="headerlink" title="UsePass(通道) 复用"></a>UsePass(通道) 复用</h2><blockquote>
<p>使用复用之后的shader就算通过代码修改值，他们也只有一种shader效果，复用就算复用不能产生两种效果</p>
</blockquote>
<ul>
<li>编写过的pass可以重复使用,借助<code>UsePass &quot;ShaderPath/PASS_NAME&quot;</code></li>
<li>PASS名字要大写;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先给一个Pass(通道)一个名字 ONE</span><br><span class="line">Pass &#123;</span><br><span class="line">    name &quot;ONE&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 复用Pass(通道)</span><br><span class="line">UsePass &quot;Custom/ShaderName/ONE&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="multi-compile-编写不同版本的shader"><a href="#multi-compile-编写不同版本的shader" class="headerlink" title="multi_compile(编写不同版本的shader)"></a>multi_compile(编写不同版本的shader)</h2><ul>
<li>通过<code>multi_compile</code>编译多个版本的<code>shader</code>;</li>
<li>定义编译多个版本的开关 定义两个版本开关<ul>
<li><code>#pragma multi_compile MY_multi_1  MY_multi_2</code>;</li>
</ul>
</li>
<li>编写控制<ul>
<li><code>#ifdef MY_multi_1 #endif</code></li>
<li><code>#ifdef MY_multi_2 #endif</code></li>
</ul>
</li>
<li>使用控制<code>shader</code>编译出不同的版本 C#中控制<ul>
<li><code>Shader.EnableKeyword(&quot;MY_multi_1&quot;);</code> 打开 MY_multi_1</li>
<li><code>Shader.DisableKeyword(&quot;MY_multi_2&quot;);</code> 关闭 MY_multi_2</li>
</ul>
</li>
</ul>
<h2 id="移动平台优化"><a href="#移动平台优化" class="headerlink" title="移动平台优化"></a>移动平台优化</h2><ul>
<li>代码优化: <ul>
<li>预先计算好对应的值 sqrt(2) –&gt; 根号2 –&gt; 1.414..;</li>
<li>放心的使用向量相关操作，叉积,点击,基本都是硬件实现，很高效; </li>
<li>尽量减少函数调用减少开销;</li>
</ul>
</li>
<li>尽可能的计算放在顶点着色器中，顶点着色器的调用频率远低于片着色器；</li>
<li>几何复杂度考量：在IOS平台视口内的顶点数不要超过100K个，IOS默认的缓冲区就是就是这么大，超过这个数字，底层会做一些操作消耗更多的资源；</li>
<li>纹理大小为 2^n次方大小, 16, 64, 128, 256, 512, 1024;</li>
<li>使用适当的数据类型float &lt; half &lt; fixed(定点数); 性能</li>
<li>尽量慎用透明效果,透明效果GPU要逐像素渲染;</li>
</ul>
<h1 id="第四十五课（unity-天空盒3D拾取本地存储）"><a href="#第四十五课（unity-天空盒3D拾取本地存储）" class="headerlink" title="第四十五课（unity_天空盒3D拾取本地存储）"></a>第四十五课（unity_天空盒<em>3D拾取</em>本地存储）</h1><h2 id="天空盒（也是种材质-skybox）"><a href="#天空盒（也是种材质-skybox）" class="headerlink" title="天空盒（也是种材质 skybox）"></a>天空盒（也是种材质 skybox）</h2><ul>
<li>一个场景是由6幅正方形的纹理图无缝拼接而成, 在视野看来位于真实的视野一样;</li>
<li>两种天空盒: <ul>
<li>场景天空盒 Window-&gt;Lighting-&gt;Scene-&gt;Skybox,切换摄像机场景不改变;</li>
<li>摄像机天空盒: 摄像机上添加天空盒组件，切换摄像机，天空盒被切换; </li>
</ul>
</li>
</ul>
<h2 id="3D拾取"><a href="#3D拾取" class="headerlink" title="3D拾取"></a>3D拾取</h2><ul>
<li>游戏中需要用户触摸/点击 操作3D世界里面的3D物体，那么需要判断用户点击的是3D中的哪个物体;</li>
<li>3D拾取的原理: 从摄像机到屏幕空间的触摸点发出一条射线，这条射线第一个撞到哪个3D物体就会认为哪个3D物体被用户选择;</li>
<li>代码编写<ul>
<li>发射一条射线: Ray ray = Camera.main.ScreenPointToRay(Touch.position); </li>
<li>检测撞到那个物体: Raycast hit; bool Physics.Raycast(ray, out hit);</li>
<li>hit.transform, 获得物体的transform组件, name可以获得被碰撞的物体的名字;</li>
<li>Camera.main获取当前我们的主Camera</li>
<li>如果要拾取，需要有一个碰撞器</li>
</ul>
</li>
</ul>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ul>
<li>PlayerPrefs类: 游戏开发中需要存储本地数据，借助这个能够实现本地存储;</li>
<li>PlayerPrefs主要方法:<ul>
<li>SetInt/SetFloat, SetString:   key–&gt;value</li>
<li>GetInt/GetFloat, GetString: key–&gt;value;</li>
<li>DeleteKey/DeleteAll 删除一个key/所有数据;</li>
<li>HasKey 判断一个Key是否存在;</li>
<li>Save 保存数据;</li>
</ul>
</li>
</ul>
<h1 id="第四十六课（unity-2D-3D声音的使用）"><a href="#第四十六课（unity-2D-3D声音的使用）" class="headerlink" title="第四十六课（unity_2D_3D声音的使用）"></a>第四十六课（unity_2D_3D声音的使用）</h1><blockquote>
<p>2D全局声音，3D有距离衰减</p>
</blockquote>
<ul>
<li>声音<ul>
<li>背景音乐</li>
<li>音效;</li>
</ul>
</li>
<li>声音文件支持的格式<ul>
<li>ogg</li>
<li>mp3</li>
<li>wave</li>
<li>AIFF</li>
</ul>
</li>
<li>音频管理器<blockquote>
<p><code>Edit--&gt;ProjectSetting--&gt; Audio</code></p>
<ul>
<li>Volume: 全局播放的音量;</li>
<li>RolloffScale: 衰减因子，越大，声音衰减越快；</li>
<li>Doppler Factor: 多普勒因子;模拟多普勒效应的监听效果:0关闭, 1 高速物体的多普勒效应会 比较明显的监听的到;</li>
<li>Default Speak Mode: 设想扬声器模式;默认值为2(立体声, AudioSpeakModer);</li>
<li>SampleRate: (输出采样率);</li>
<li>DSPBufferSize: 调整DSP缓冲区大小优化延迟和性能;</li>
<li>Virutal(虚拟)/RealVoliceCount(真实): 同时播放的真实声音的数量;</li>
<li>DisableAudio: 警用音频;</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="音频监听器"><a href="#音频监听器" class="headerlink" title="音频监听器"></a>音频监听器</h2><blockquote>
<p><code>Audio Listener</code>,在主摄像机上面已经有了<br>就跟我们<strong>耳朵</strong>一样,有距离而衰减(远小近大)</p>
</blockquote>
<ul>
<li>音频监听器在3D世界中扮演话筒的角色，他接受场景中输入的音频源，通过设备的扬声器来播放声音;</li>
<li>当一个音频监听器挂载到场景中的一个游戏对象上，任何音源如果接近音频监听器，都会输出到计算机的扬声器中,每个场景中只能有一个音频监听器，一般会默认的添加到主摄像机上;</li>
<li>AudioClip: 声音文件</li>
</ul>
<h2 id="AudioSource"><a href="#AudioSource" class="headerlink" title="AudioSource"></a>AudioSource</h2><blockquote>
<p>来帮助我们播放AudioClip的</p>
</blockquote>
<ul>
<li>音频源: 在场景中播放音频剪辑,如果一个音频剪辑是一个3D，那么音频源就会在给定的位置，然后随着距离进行衰减,还可以在3D和2D之间进行切换;</li>
<li>创建一个音频源:<ul>
<li>导入要播放的声音文件;</li>
<li>创建一个节点，并加上Audio–&gt;Audio Source组件;</li>
<li>将AudioClip加入到AudioSource中；</li>
<li>代码控制播放;</li>
</ul>
</li>
<li>属性:<ul>
<li>AudioClip: 要被播放的文件;</li>
<li>Output: 音频剪辑通过音频混合器输出;</li>
<li>Mute: 是否静音;</li>
<li>Play On Wake：唤醒是否播放;</li>
<li>loop: 是否循环播放;</li>
<li>Priority: 播放的优先级，0最高，256最低(可以把很重要的优先级设置高一些)</li>
<li>Volume 音量 Pitch 音调 Stereo Pan立体声(-1左声道, 1右声道)</li>
<li>Min/Max Distance 衰减距离的 开始结束, 最小距离(声音保持最大量),最大距离(不再衰减)</li>
<li>patial Blend(空间混合), 0为2D音效(不会随距离而衰减), 1为3D音效</li>
<li>Spread: (3D)立体声在扬声器空间中的传播速度;</li>
<li>Min Distance(3D) 声音衰减的最小距离</li>
<li>Max Distance(3D) 声音衰减的最大距离<blockquote>
<p>Audio Listener 到 音频的距离 如果他们距离超过最大距离，就会很小或听不见</p>
</blockquote>
</li>
<li>衰减模式: 对数，线性核自定义模式;</li>
</ul>
</li>
</ul>
<blockquote>
<p>AudioSettings类对声音全局设置类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取配置</span><br><span class="line">AuidoConfiguratio audio_config = AudioSettings.GetConfiguration</span><br><span class="line">// ... 省略修改</span><br><span class="line">// 修改之后用Reset设置好就行了</span><br><span class="line">AudioSettings.Reset(audio_config);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>#　第四十七课（unity_水和雾特效）</p>
<h2 id="水"><a href="#水" class="headerlink" title="水"></a>水</h2><ul>
<li>Unity 自己实现了水的特效，帮助我们解决游戏中水的问题</li>
<li>Unity的水集成在了<code>Environment</code>的环境资源包里面，导入方法是 <code>Assert--&gt;Import--&gt;Environent</code>导入，需要正式版的才能看到这个菜单，我们使用别人导出来的package;</li>
<li>水分为Water与Water(Basic)两个文件夹，两个文件夹中都有一个Prefab预制体的文件，文件夹下面的有两个文件，对应Daytime(白天的水)和NightTimer(晚上的水),BasicX效果要差一些，但是占CPU比较低<blockquote>
<p>带Bsic的水质量低一些，相对的性能肯定好一些</p>
</blockquote>
</li>
<li>水是由Shader来实现的，所以要看一下水对应的shader，可以自己调节参数</li>
</ul>
<p>##　雾</p>
<p>开启Unity的雾模式</p>
<blockquote>
<p><code>window--&gt;Lighting--&gt;scene</code>勾选住<code>Fog</code></p>
<ul>
<li>Fog的模式：<ul>
<li>Linear 线性(默认)<ul>
<li>雾从start开始，接近end越浓</li>
</ul>
</li>
<li>Exponential <ul>
<li>可配置参数Density，雾的浓度，浓度越大，雾越大</li>
</ul>
</li>
<li>Exponential Squared<ul>
<li>可配置参数Density 越大表示雾越浓</li>
</ul>
</li>
</ul>
</li>
<li>Fog Color雾的颜色：可以配置雾的颜色</li>
</ul>
</blockquote>
<ul>
<li>RenderSettings类<ul>
<li>fogMode<ul>
<li>调整雾气的模式<code>enum FogMode</code></li>
</ul>
</li>
<li>fog的密度<code>fogDensity</code></li>
<li>start/end可通过fogStartDistance/fogEndDistance来设置</li>
<li>关闭雾<ul>
<li>fogMode = 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四十八课（unity-光照-二-）"><a href="#第四十八课（unity-光照-二-）" class="headerlink" title="第四十八课（unity_光照(二)）"></a>第四十八课（unity_光照(二)）</h1><ul>
<li>光照的本质:就是光的颜色和物体纹理的颜色的混合;<h2 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h2></li>
<li>点光源</li>
<li>定向光源</li>
<li>聚光灯</li>
<li><p>区域光源(只会对static的物体有效)</p>
<blockquote>
<p>区域光的范围会在场景中用黄色的光显示出来;z轴是光的方向; 光的强度会随距离衰减<br>  <strong>只能配合烘培GI使用</strong></p>
</blockquote>
<h2 id="发光材质-必须使用在static物体上才可以"><a href="#发光材质-必须使用在static物体上才可以" class="headerlink" title="发光材质(必须使用在static物体上才可以)"></a>发光材质(必须使用在static物体上才可以)</h2><blockquote>
<p>材质–&gt; Emission<br>Global Illumi –&gt; Baked<br>使用发光材质的物体就变成了一个发光体，只能对标记为static的物体有影响</p>
</blockquote>
<ul>
<li>发光材质也算是一种光源,通过给物体添加特殊的着色器，调节其自发光参数可以得到一个柔和的灯光效果。发光材质可以让物体表面发光，</li>
<li>发光材质也只能作用在被标记为static, 或LightStatic的物体上。光源的强度以2的次方速度衰减;</li>
</ul>
</li>
</ul>
<blockquote>
<p>区域光源和发光材质都是需要依赖于静态物体,只能配置烘焙GI使用</p>
</blockquote>
<h2 id="Light组件的参数"><a href="#Light组件的参数" class="headerlink" title="Light组件的参数"></a>Light组件的参数</h2><ul>
<li>Type: 灯光当前的类型;<ul>
<li>Directional: 光源为平行光</li>
<li>Point: 光源为点光源;</li>
<li>Spot: 光源为聚光灯;</li>
</ul>
</li>
<li>Baking: 全局光照模式 Realtime/Baked/Mix模式;</li>
<li>Range: 灯光所影响的最大访问，平行光不需要;</li>
<li>Color: 灯光发出光线的颜色;</li>
<li>Intensity: 灯光发射的明亮程度，0为关闭，1为最亮;</li>
<li>Bounes Intensity: 控制全局光照中光线的反弹强度。</li>
<li>Shadow Type: 灯光投影的阴影类型;</li>
<li>Cookie: 使用一个带有Alpha的纹理来制作一个遮罩，使光线在不同的地方有不同的亮度，当光源为点光源是必须为立方图纹理;</li>
<li>Draw Halo: 绘制光晕，如果勾选，光源会带有球形光晕;</li>
<li>Flare: (可选) 灯光耀斑，在光源位置绘制;</li>
<li>RenderMode: 灯光的渲染模式;<ul>
<li>Auto自动渲染模式,更具灯光亮度和当前设置的质量在运行时确定;</li>
<li>Important: 灯光会按照逐个像素渲染，用于重要的灯光特效;</li>
<li>Not Important: 灯光一最快的速度渲染;</li>
</ul>
</li>
<li>Culling Mask: 选择某些层(Layer)不受光源影响;</li>
</ul>
<h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><blockquote>
<p>光照烘培出来的贴图，贴到模型物体上，减少运算负担，对静态物体有很好的效果;</p>
</blockquote>
<ul>
<li>光照贴图的烘培<ul>
<li>将不同的物体，和光源预先烘焙出来，生成一个光照贴图。</li>
<li>将要做光照烘培的物体配置成<code>Light static</code>模式;</li>
<li>将光源的Light组件上的<code>Baking</code>选为<code>Baked</code>;</li>
<li>打开烘培窗口<code>Window--&gt;Lighting</code></li>
<li>确认无误后，在Lighting窗口中的Scene面板中选择Build进行烘培, 将Auto(自动烘培)关闭;</li>
</ul>
</li>
</ul>
<h2 id="光照烘培的参数详解"><a href="#光照烘培的参数详解" class="headerlink" title="光照烘培的参数详解"></a>光照烘培的参数详解</h2><ul>
<li>Light过滤按钮:<ul>
<li>type: 设定灯光的类型,可以将灯光设置成平行光,点光源，区域光，聚光灯;</li>
<li>Baking: 光源的烘培模式;</li>
<li>Realtime:  对场景的物体都采取实时光照;</li>
<li>Baked: 对静态物体采用烘培光照，对非静态物体不起作用；</li>
<li>Mixed:对静态物体使用烘培光照，对非静态物体使用实时光照;</li>
<li>Bounce Intensity: 调节间接光的强度(从一个物体反射到另外一个物体上的光)</li>
</ul>
</li>
<li>Render过滤按钮:<ul>
<li>Lightmap static: 游戏对象是否为static /Lightmap static，如果是游戏对象参与到GI计算光照;</li>
<li>Scale In Lightmap: 该值影响了用于选中对象的lightmap的像素数目,默认值为1.0,每个对象所占的光照图像素的比例,可以通过它来优化光照，不重要对象减少比例，重要物体来获得更多的光照图像素来优化场景;</li>
<li>Preserve UV: 保护光照图UV，若模型没在3DMax等建模软件中展示UV，必须勾选住;</li>
<li>AutoUV Max Distance: 手动设置UV最大距离;</li>
<li>AutoUV Max Angle: 手动设置UV最大角度;</li>
<li>Important GI: 让自发光物体的照射范围更大;</li>
<li>Advance Parameters: 设置光照的质量;</li>
</ul>
</li>
<li>环境光照选项(Environment)<ul>
<li>Skybox: 场景中使用的天空盒;</li>
<li>Sun: 场景中的太阳光,可以为其指定一个固定的平行光源;</li>
<li>Ambient Source: 环境光的来源(默认天空盒);</li>
<li>Ambient Intensity: 环境光的强度;</li>
<li>Ambient GI: 指定环境光的光照模式是实时光照还是烘培,若两种GI模式都没有开启，该选项没有效果;</li>
<li>Reflection Source: 反射源,可以指定反射源氏天空盒或一个自定义的立体纹理图;</li>
<li>Reflection Instensity: 反射强度，可以设置来自天空盒或立体纹理图的反射强度;</li>
<li>Reflection Bounce: 反射计算的次数; </li>
</ul>
</li>
<li>Bake GI参数:<ul>
<li>Bake Resolution: 烘培的分辨率: 若该值为10，代表每一个单位分布10个纹理像素;</li>
<li>Blake Padding: 在LightMap中不同物体烘培图的间距;</li>
<li>Compress: 是否压缩光照贴图;</li>
<li>Ambient Occlusion: 烘培光照图产生一定数量的环境阻光,环境阻光计算每一点被一定距离内的其他物体或一定距离内自身物体的挡住的遮挡程度(用来模拟物体表面环境光以及阴影的覆盖比例,达到全局光照的效果);</li>
<li>Final Gather: 控制从最终聚焦点发射出的光线的数量，较高数值可以达到更好的效果;</li>
</ul>
</li>
<li>Other 设置可以设置光晕的效果;</li>
</ul>
<h1 id="第四十九课（unity光照-三-法线贴图与阴影设置详解）"><a href="#第四十九课（unity光照-三-法线贴图与阴影设置详解）" class="headerlink" title="第四十九课（unity光照(三)法线贴图与阴影设置详解）"></a>第四十九课（unity光照(三)法线贴图与阴影设置详解）</h1><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><ul>
<li>法线贴图是凹凸贴图技术上 的一种应用,有时也称为Dot3(仿立体)凹凸纹理贴图;</li>
<li><strong>法线贴图是在不增加多边形的情况下，增强模型的细节</strong>;</li>
<li>法线贴图是高精度模型导出来的一种贴图，作用到低精度jing’d度模型上面,增强低精度模型的细节同时，又能获取很好的性能;</li>
<li><p>法线贴图的使用:</p>
<ul>
<li>模型资源:<blockquote>
<p>美术提供</p>
<ul>
<li>低精度的模型</li>
<li>法线贴图(normal)</li>
<li>漫反射贴图(diffuse);   </li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>创建两个Shaders材质: </p>
<ul>
<li><code>Legacy Shaders/Diffuse</code>(漫反射贴图)</li>
<li><code>Legacy Shaders/Bumped Diffuse</code>(法线贴图)<ul>
<li>法线贴图的材质类型一定要是 <code>normalmap</code></li>
</ul>
</li>
</ul>
</li>
<li>代码切换材质:<ul>
<li>获取到材质然后materials使用new数值来确定需要使用多少个材质，需要多少就new多少个</li>
</ul>
</li>
</ul>
<h2 id="阴影的设置-光照"><a href="#阴影的设置-光照" class="headerlink" title="阴影的设置(光照)"></a>阴影的设置(光照)</h2><ul>
<li>unity可以通过修改阴影的参数来对阴影的质量进行设置;</li>
<li>unity使用阴影贴图来显示阴影的，阴影贴图可以看作是灯光投射到场景的阴影通过纹理贴图的形式表现出来;</li>
<li><p>阴影的质量取决于两个方面: </p>
<ul>
<li>贴图分辨率(Resolution)</li>
<li>阴影的类型(Type)<ul>
<li>Hard 硬件(GPU绘制 性能更好 不是所有显卡都支持硬件阴影绘制)<ul>
<li>硬阴影是GPU运算的，不影响CPU的性能和内存;hard比较生硬，但是软阴影比硬阴影要消耗更多的资源</li>
</ul>
</li>
<li>softer 软件(会影响CPU)<ul>
<li>处理更好，但是消耗也就更大<br>Resolution设置(默认设置的是Quality设置里面的):  </li>
</ul>
</li>
<li>低质量(Low Resolution)</li>
<li>中等质量(Medium Resolution)</li>
<li>高质量(High Resolution)</li>
<li>极高质量(Very High Resolution)<blockquote>
<p>越高，越清晰，消耗也越大;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用户将阴影设置为 <code>Use Quality Settings</code>使用的是全局的设置参数:<br><code>Edit--&gt;Project Settings-&gt;Quality</code> 中和阴影相关的参数。</p>
</li>
<li><p>Shadows Type: 设置阴影的类型;</p>
</li>
<li>Shadow Resolution 阴影设置分辨率,分辨率越高，开销越大</li>
<li>Shadow Projection 阴影投射, 平行光的投射投影有两种: <ul>
<li>Close Fit渲染高分辨率阴影</li>
<li>Stable Fit渲染低分辨率阴影</li>
</ul>
</li>
<li>Shadow Distance: 相机阴影可见的最大距离,超过这个距离阴影不会被计算;提升性能，不会绘制超过范围的阴影</li>
<li>Shadow Casades : 阴影重叠，重叠数目越高，质量越好,开销越大;</li>
</ul>
<h2 id="阴影的优化"><a href="#阴影的优化" class="headerlink" title="阴影的优化"></a>阴影的优化</h2><ul>
<li>静态物体: 尽量使用光照贴图，将阴影预先烘培出来,不实时的计算阴影;</li>
<li>设置分辨率和阴影类型，适当降低开销，硬件阴影的消耗要比软件阴影的小;</li>
<li>设置阴影在摄像机范围的显示距离;</li>
<li>并非所有的显卡都支持硬件阴影,要做好测试;</li>
</ul>
<h1 id="第五十课（unity光照-四-渲染路径-颜色空间-Cookies-Flare-光照过滤）"><a href="#第五十课（unity光照-四-渲染路径-颜色空间-Cookies-Flare-光照过滤）" class="headerlink" title="第五十课（unity光照(四)渲染路径_颜色空间_Cookies_Flare_光照过滤）"></a>第五十课（unity光照(四)渲染路径_颜色空间_Cookies_Flare_光照过滤）</h1><h2 id="渲染路径和颜色空间"><a href="#渲染路径和颜色空间" class="headerlink" title="渲染路径和颜色空间"></a>渲染路径和颜色空间</h2><blockquote>
<p><code>Edit--&gt;ProjectSetting Player--&gt;Inspector--&gt;Other Setting --&gt; Rendering Path</code></p>
</blockquote>
<ul>
<li>Unity光影效果可以通过设置 渲染路径和颜色空间</li>
<li><strong>渲染路径(Rendering Path)</strong>: <strong>计算光照的着色方式</strong>;<ul>
<li><code>forward</code>: 着色时根据对应影响的灯光,每个光源着色一次,多个光源作用时会着色多次;<ul>
<li>优点: 快速，硬件要求低,快速的处理透明;</li>
<li>缺点: 每个光源都要有对应的成本,大量光源反而降低;</li>
</ul>
</li>
<li><code>Deferred</code>: 延迟渲染路径,将光的颜色着色到几何缓冲器,生成一个屏幕空间的贴图<ul>
<li>优点：大量 realttime 光源模式的时候更真实;</li>
<li>缺点：需要硬件水平要求高;</li>
</ul>
</li>
<li><code>Legacy Vertex Lit</code>: 顶点照明，所有的光照只会在顶点上计算<ul>
<li>优点：速度快，最广泛的硬件支持。</li>
<li>缺点：但是不支持阴影,法线贴图，灯光遮罩,高精度的高光等;</li>
</ul>
</li>
<li><code>Legacy Defferred</code>和<code>Defferfed</code>类似，但是是不一样的算法;Path`</li>
</ul>
</li>
<li><p><strong>颜色空间(Color Space)</strong>: 色彩空间决定采用哪种算法计算照明或材质加载时候的颜色混合</p>
<ul>
<li><code>Linear</code>颜色空间</li>
<li><code>Camma</code>颜色空间</li>
</ul>
</li>
<li><p>Cookies(光照过滤)</p>
<blockquote>
<p>会通过一张纹理图的Alpha通道来决定光照能透过什么光照射下来<br>  Cookies size 越小值越密集(控制密度)</p>
<ul>
<li>设置一下导入的纹理,在纹理属性的面板上选择Cookies <ul>
<li>配置好Cookies对应的光源类型(Light Type);  </li>
<li>可勾选住Alpha from Grayscale选项;</li>
</ul>
</li>
<li>在平行光源中只要把一张带着透明通道的纹理图或者灰度图拖动到光源上的Cookies上;</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="镜头光晕"><a href="#镜头光晕" class="headerlink" title="镜头光晕"></a>镜头光晕</h2><ul>
<li>镜头光晕又叫耀斑,模拟摄像机镜头内的一种光线折射的效果太阳对准摄像机镜头才有的效果));</li>
<li>耀斑的制作: <code>creator--&gt;Lens Flare</code>来制作一个耀斑，一般由美术和特效人员完成;</li>
<li>耀斑的使用(物体也可以加光晕): <ul>
<li>打开光源组件，将耀斑文件拖入到光源的<code>Flare</code>选项里面;</li>
<li>物体中添加耀斑组件<code>Lens Flare</code>然后关联耀斑文件资源;</li>
</ul>
</li>
<li><img src="unity学习笔记/50_1.png" alt="图片暂时没有哦"></li>
</ul>
<h1 id="第五十一课（unity光照-五-Stander着色器mobilediffuse着色器光探头的原理和使用）"><a href="#第五十一课（unity光照-五-Stander着色器mobilediffuse着色器光探头的原理和使用）" class="headerlink" title="第五十一课（unity光照(五)Stander着色器mobilediffuse着色器光探头的原理和使用）"></a>第五十一课（unity光照(五)Stander着色器<em>mobilediffuse着色器</em>光探头的原理和使用）</h1><ul>
<li><p>Mobile Diffuse</p>
<ul>
<li>漫反射着色器, 最简单的3D着色模式;</li>
<li>模型顶点，到顶点的纹理坐标，到着色的时候选择纹理上的颜色着色;</li>
<li>在光照之前，你把纹理本来的颜色着色上去，参数光照，漫反射部分;</li>
</ul>
</li>
<li><p>标准着色器(Standard)</p>
</li>
<li>基于物理学的着色是用模拟现实的方式呈现出材质和灯光之间的相互作用, 基于物理学的着色器给用户营造出连续性。;</li>
<li>为了表现出真实的灯光, 标准着色器模仿了能量存储(物体反射的光源不大于它接收的光源), Fresnel反射(视线不垂直于物体表面时夹角月小，反射越明显), 表面遮蔽;</li>
<li><p>Stander着色器的参数:</p>
<ul>
<li>Rendering Mode: 四种渲染模式;</li>
<li>Albedo: 漫反射纹理图,也可以设置颜色和透明度, 纹理颜色 + 调和颜色;</li>
<li>Metallic: 金属性，值越高，发射效果越明显;</li>
<li>Smoothness:影响反射时表面的光滑程度，值越高,反射效果越清晰;</li>
<li>Specular: 高光。颜色可以自行设置;</li>
<li>Normal Map: 法线贴图;</li>
<li>Height Map: 高度图, 通常是灰度图;</li>
<li>Occlusion: 环境遮罩贴图。</li>
<li>Emission: 自发光属性，开启后类是于一个光源，可以调节GI模式;</li>
<li>Detail Mask: 细节遮罩贴图。当某些地方不需要细节图，可以使用遮罩图进行设置。</li>
<li>Tiling: 贴图的重复次数;</li>
<li>Offset: 贴图的偏移量;</li>
<li>Secondary Maps: 细节贴图<blockquote>
<p>增强效果和细节</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Rending Mode</p>
<ul>
<li>Standard Shader有四种渲染模式;<ul>
<li>Opaque 模式:这种模式代表该着色器<strong>不支持透明通道, 物体是完全不透明的</strong>;</li>
<li>Cutout 模式:这种模式下支持透明通道，<strong>要么就透明，要么就完全不透明</strong>,图片内容是否透明,由Albedo的Alpha值和Alpha Cutoff决定的。适合制作叶子，草灯，带有透明通道的图片但不希望出半透明效果的材质;</li>
<li>Fade 模式: 褪色模式,改模式下可以操作Albedo的Color的Alpha值来操作材质的透明度，比较适合做物体<strong>渐渐淡出的动画效果</strong>, <strong>当Alpha值降低了以后,表面的高光和反色也会变淡</strong>;</li>
<li>Transparent 模式: 这种模式下的材质通过Albedo的Color的Alpha值来操作材质的透明度<br>当物体为半透明的时候,<strong>表面的高光和反色不会变淡</strong>;<blockquote>
<p>Fade和Transparent的区别在于 表面的高光和反色前者会变淡，后者不会变淡</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Occlusion Map</p>
<blockquote>
<p>遮挡图,是一种模型的表面应该接受多少间接反射的图片<br>一个表面凹凸不平的物体,在其凹下的地方应该接受较少的间接光照，遮挡图是一张灰度图。</p>
<ul>
<li>白色(255)表示完全的间接照明</li>
<li>黑色(0)表示完全不接受间接照明;<br>通过灰度图来控制间接光照的多少，来让光照的模型更加真实</li>
</ul>
</blockquote>
</li>
<li><p>Secondary Maps</p>
<ul>
<li>又叫Detail Map,材质的次级贴图，又叫细节贴图,它的作用是展示第一组贴图中没有显示的材质细节效果, Unity允许用户在一个材质上添加一个次级的漫反射贴图和法线贴图;</li>
</ul>
</li>
</ul>
<h2 id="光探头"><a href="#光探头" class="headerlink" title="光探头"></a>光探头</h2><blockquote>
<p>如果场景使用了光照贴图(对静态物体进行了烘焙)，这时候我的游戏人物走到这个静态物体边，不会受到周围环境光照的影响，这肯定是不符合逻辑的,又不能使用实时计算光照(效率消耗比较高)，光探头就是用来做这个事情的。预先把这几个场景点放若干个采集点，人物就算走到已经使用了光照贴图的环境也会受光照的影响。<br><strong>光探头作用：主要用作在静态物体烘焙之后，使我们动态物体能更好的融入静态烘焙之后的环境，更加逼真的效果。</strong></p>
</blockquote>
<ul>
<li>光照贴图都是应用于静态物体，如果一个非静态物体在烘培好的Lighting map的场景中移动，这样的不能很好的融合到烘培好的场景中，最理想是实时计算，但是达不到理想的效果,针对这种提出光探头;</li>
<li>Light Probes 的原理是在场景中放上若干采样点，收集采样点的周围的光暗信息;然后在附近的几个点围城的区域内进行插值，将插值结果作用到动态物体上;</li>
<li>Light Probes应用细节:<ul>
<li>没有必要在光影无变化的区域内布置多个采样点;</li>
<li>在动态物体的活动空间来进行部署,不必要全部空间都部署;</li>
<li>在我们的一个节点上，添加<code>Light Probes Group</code>组件,来进行部署光d探头<ul>
<li>Add Probe 添加探头</li>
<li>Duplicate Selected 复制探头<blockquote>
<p>添加探头之后需要重新烘焙才能看出效果</p>
</blockquote>
</li>
</ul>
</li>
<li>在不同光影的区域内布置</li>
</ul>
</li>
<li>MeshRender上的光探头选项:<ul>
<li>Light Probes 选项的3个: <ul>
<li>off(关闭)    </li>
<li>Blend Probes(默认)反射探针将被启用。 </li>
<li>Use Proxy Volume(光照探头代理) <blockquote>
<p>指定光照探头。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第五十二课（unity光照-六-反射探头的使用）"><a href="#第五十二课（unity光照-六-反射探头的使用）" class="headerlink" title="第五十二课（unity光照(六)反射探头的使用）"></a>第五十二课（unity光照(六)反射探头的使用）</h1><blockquote>
<p>在反射探头内的物体可被反射出来</p>
</blockquote>
<h2 id="反射探头"><a href="#反射探头" class="headerlink" title="反射探头"></a>反射探头</h2><blockquote>
<p>制作倒影</p>
</blockquote>
<ul>
<li>镜子金属等具有光滑表面的物体都会反射，而游戏中计算实时反射非常消耗CPU的资源,<br>unity5.0新增了一个反射探头的技术，通过采样点，生成反射Cubemap,然后通过特定的着色器从Cubemap中采样,就能显示反射效果了;</li>
<li>反射探头(Reflection Probe)的参数:<ul>
<li>type: 设置反射探头的类型<ul>
<li>baked 烘焙模式 静态</li>
<li>custom 烘焙模式多一些选项</li>
<li>realtime 实时模式</li>
</ul>
</li>
<li>Dynamic Object: 将场景中的没有标识为 Static的对象烘培到发射纹理中;</li>
<li>Cubemap: 烘培出来的立方体纹理图;</li>
<li>Refresh Mode 刷新模式: <ul>
<li>OnAwake只在唤醒时刷新</li>
<li>EveryFrame 每帧刷新</li>
<li>Via Scripts 有脚本控制;<br>Time slicing: 反射画面刷新频率: </li>
<li>All face at once: 9帧完成一次刷新(中等) </li>
<li>Individual Faces: 14帧完成刷新(性能消耗低) </li>
<li>no time slicing: 每帧刷新(性能消耗最大);</li>
</ul>
</li>
<li>Importance: 权重，根据权重来混合不同Probe的反射情况;</li>
<li>Intensity: 反射纹理的颜色亮度;</li>
<li>Box Projection: 若是勾选此项， Probe的Size和Origin会影响反射贴图的映射方式;</li>
<li>Size:该探头的区域大小，在该区域内所有的物体都会应用反射(需要Standard着色器);</li>
<li>Probe Origin: 反射探头原点,会影响到捕捉到的Cubemap;</li>
<li>HDR 生成Cubemap中是否使用高动态范围图像(High Dymainc Range)这也会影响探头的数据存储位置;</li>
<li>Shadown Distance: 在反射图中的阴影距离,超过该距离阴影不会被反射;</li>
<li>ClearFlags: 设置反射图中的背景是天空盒或者是单一的颜色;</li>
<li>Background: 设置背景的颜色;</li>
<li>Culling Mask: 反射剔除,决定哪些层的物体是否进行反射;</li>
<li>Using Occlustion Culling: 烘培时，是否启动遮挡剔除(一个物体被挡住看不见，是不会绘制的); </li>
<li>Clipping Plances: 反射的裁剪平面<ul>
<li>near </li>
<li>far</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="反射探头模式"><a href="#反射探头模式" class="headerlink" title="反射探头模式"></a>反射探头模式</h2><ul>
<li>Baked烘培模式: 类似于光照烘培，把反射探头设置好后,将反射信息烘培到CubeMap中，当游戏运行的时候直接使用烘培好的CubeMap;</li>
<li>Custom(自定义模式): 与Baked模式的探头的用法相同，需要手动烘培才能看到效果。Custom提供了更多的参数可以设置，如Dynamic Object，将非静态的物体烘培到发射图中，但是不会随着物体的移动而改变;CubeMap选项可以制定烘培出来的Cubemap;</li>
<li>Realtime模式: 可以实时的更新反射图,在这种类型的反射头不需要将被反射的物体勾选为Static, 能实时, 但是性能要求高;</li>
</ul>
<h2 id="位置大小"><a href="#位置大小" class="headerlink" title="位置大小"></a>位置大小</h2><ul>
<li>反射探头是由物体挂载<code>Relfection Probe</code>来决定的,位置设置完毕后需要设置大小;<ul>
<li>根据需要反射物体的大小对探针进行摆放,场景的中心，墙壁的角落, 若有一些物体比较小又有强烈的视觉效果(比如篝火), 就需要探头距离它很近能得到很好的反射效果;</li>
<li>放好探头后要设置探头的大小,探头的形状似一个轴对称的立方体,如果在立方体内有对应的着色器,其反射效果就会根据其所在的反射探头的区域进行显示。若有多个探头，根据权重进行混合;</li>
<li>默认情况下探头的原点是几何中心，可以通过<code>Probe Origin</code>参数进行偏移,一个大的物体来反射一个从边缘接近他的点。</li>
</ul>
</li>
</ul>
<h2 id="循环反射"><a href="#循环反射" class="headerlink" title="循环反射"></a>循环反射</h2><ul>
<li>循环反射: 两个物体可以都反射，那么就会形成循环反射 <code>interReflection</code></li>
<li>Unity不能无限循环下去，可以设置循环次数: <code>window--&gt;Lighting--&gt;Environment Lighting Reflection Bounes</code>来控制反射的次数, 最大反射次数为5次;</li>
</ul>
<h1 id="第五十三课（unity-光照系统-七-Realtime-BakedGI-预计算全局光照-全局光照详解）"><a href="#第五十三课（unity-光照系统-七-Realtime-BakedGI-预计算全局光照-全局光照详解）" class="headerlink" title="第五十三课（unity_光照系统(七)_Realtime_BakedGI_预计算全局光照._全局光照详解）"></a>第五十三课（unity_光照系统(七)_Realtime_BakedGI_预计算全局光照._全局光照详解）</h1><h2 id="全局光照-GI"><a href="#全局光照-GI" class="headerlink" title="全局光照 GI"></a>全局光照 GI</h2><ul>
<li>Realtime每帧都会计算光照,<strong>实时光照是不会反射的，所以它的光影显得单调</strong>;</li>
<li>Baked GI:通过烘培光照贴图的方式获得很好的光照效果，无法实时的改变光照;</li>
<li>预先计算全局光照: <code>Precumputed Realtime GI</code><blockquote>
<p>实时光照不能很好的显示间接光照的效果, 比如实时光照到一个红色的物体上。<br>红色物体发生反射,本来如果是实时不会有反射，如果使用预先光照，那么会预先计算好静态物体的反射, 让物体显示出间接光效果;</p>
</blockquote>
</li>
<li>环境光</li>
</ul>
<h2 id="预先计算全局光照-物体必须为Static，才能看到效果"><a href="#预先计算全局光照-物体必须为Static，才能看到效果" class="headerlink" title="预先计算全局光照(物体必须为Static，才能看到效果)"></a>预先计算全局光照(物体必须为Static，才能看到效果)</h2><blockquote>
<p>如果有光照射在一个物体上，这个物体会有反射光<br><strong>预先计算全局光照弥补了实时光照没有反射效果</strong></p>
</blockquote>
<ul>
<li>使用实时光照,编写场景;</li>
<li>开启预先光照选项 <code>Window ---&gt;Lighting--&gt;Scene面板--&gt;Precomputed Realtime GI</code>;</li>
<li><code>Bealtime resolution</code> 代表间接光照分辨率，值越高间接光照效果越明显;</li>
<li>运行场景，看到光源角度变化后，场景中的光影效果也是实时的;</li>
<li>通过预先光照，有效的降低了原本要在游戏中实时计算的全局光照运算数量,若用户需要在游戏中频繁的对光源修改颜色，光源方向，光源强度，一般使用预先光照;</li>
<li>预先光照也是针对静态物体而言;对于动态物体时不会计算预先光照的;</li>
<li>实时光照 + 预先光照 对静态物体生成反射效果;</li>
</ul>
<h1 id="第五十四课（unity-Mesh网格的详解）"><a href="#第五十四课（unity-Mesh网格的详解）" class="headerlink" title="第五十四课（unity_Mesh网格的详解）"></a>第五十四课（unity_Mesh网格的详解）</h1><h2 id="3D建模软件"><a href="#3D建模软件" class="headerlink" title="3D建模软件"></a>3D建模软件</h2><p>1:Autodesk 3D Studio Max 支持mac os windows;<br>2: Autodesk 3D Maya 支持windows<br>3: Cinema4D 支持mac os windows<br>4: Blender 开源跨平台的全能三维制作软件, 支持mac os windows, linux;</p>
<blockquote>
<p>Blender 开源电影</p>
</blockquote>
<p>5: Cheetah3D: 支持mac os<br>6: Unity与建模软件的单位比例:<br>   unity系统单位为m, 建模软件的m的尺寸大小不一样，所以导入的时候有差异:</p>
<table>
<thead>
<tr>
<th>软件名</th>
<th>内部米</th>
<th>导入unity后的尺寸/m</th>
<th>与Unity单位的比例关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>3Dmax</td>
<td>1</td>
<td>0.01</td>
<td>100:1</td>
</tr>
<tr>
<td>Maya</td>
<td>1</td>
<td>100</td>
<td>1:100</td>
</tr>
<tr>
<td>Cinema 4D</td>
<td>1</td>
<td>100</td>
<td>1:100</td>
</tr>
<tr>
<td>Light Wave</td>
<td>1</td>
<td>0.01</td>
<td>100:1</td>
</tr>
</tbody>
</table>
<h2 id="网格Mesh"><a href="#网格Mesh" class="headerlink" title="网格Mesh"></a>网格Mesh</h2><ul>
<li>Unity提供一个Mesh类，允许脚本来创建和修改，通过Mesh类能生成或修改物体的网格，能做出非常酷炫的物体变形特效;</li>
<li>Mesh Filter 网格过滤器从资源中拿出网格并将其传递给MeshRender,用于绘制, 导入模型的时候,Unity会自动创建一个这样的组件;<blockquote>
<p>Mesh Filter 网格是从这个模型文件里面来读取我们这个模型的数据，然后通过Mesh网格绘制出来</p>
</blockquote>
</li>
<li>Mesh 是网格过滤器实例化的Mesh, Mesh中存储物体的网格数据的属性和生成或修改物体网格的方法<blockquote>
<p>Mesh 网格负责绘制这个物体的</p>
</blockquote>
</li>
<li>顶点数组<vector3>:  每个顶点的x, y, z坐标。Vector3对象,面与面有共用的顶点,所以为了节约内存，先存顶点，然后再存三角形;</vector3></li>
<li>三角形索引数组<int>: Mesh里面每个三角形为一个面,由于面与面的顶点公用，所以，用索引来表示三角形的一个面，可以节约模型内存空间, 0, 1, 2面,对应的顶点时在顶点数组中的索引,<strong>三角形顶点的顺序为逆时针为正面</strong>。</int></li>
<li>顶点法线: 面的法线是与面垂直的线, 严格意义上讲，点是没有法线的, 在光照计算的时候,使用法线来进行光照计算，如果一个面上所有的法线都是一样，那么光着色也一样，看起来会很奇怪,所以通过某种算法，把多个面公用的顶点的法线根据算法综合插值，得到顶点法线;</li>
<li>顶点纹理坐标<vector2>: 顶点对应的纹理上的UV坐标;</vector2></li>
<li>顶点切线<vector4> 顶点切线;<h2 id="Mesh的重要属性"><a href="#Mesh的重要属性" class="headerlink" title="Mesh的重要属性"></a>Mesh的重要属性</h2></vector4></li>
<li>Mesh重要的属性:<ul>
<li>vertices 网格顶点数组;</li>
<li>normals 网格的法线数组;</li>
<li>tangents 网格的切线数组;</li>
<li>uv 网格的基础纹理坐标;</li>
<li>uv2 网格设定的第二个纹理坐标;</li>
<li>bounds 网格的包围盒;</li>
<li>Colors 网格的顶点颜色数组;</li>
<li>triangles 包含所有三角形的顶点索引数组;</li>
<li>vectexCount 网格中的顶点数量(只读的);</li>
<li>subMeshCount 子网格的数量，每个材质都有一个独立的网格列表;</li>
<li>bonesWeights: 每个顶点的骨骼权重;</li>
<li>bindposes: 绑定姿势，每个索引绑定的姿势使用具有相同的索引骨骼;</li>
</ul>
</li>
<li>Mesh重要的方法:<ul>
<li>Clear 清空所有的顶点数据和所有的三角形索引;</li>
<li>RecalculateBounds 重新计算网格的包围盒;</li>
<li>RecalculateNormals 重新计算网格的法线;</li>
<li>Optimze 显示优化的网格;</li>
<li>GetTriangles 返回网格的三角形列表;</li>
<li>SetTriangles 为网格设定三角形列表;</li>
<li>CominMeshes 组合多个网格到同一个网格;</li>
</ul>
</li>
</ul>
<h2 id="空物体通过用代码绘制模型"><a href="#空物体通过用代码绘制模型" class="headerlink" title="空物体通过用代码绘制模型"></a>空物体通过用代码绘制模型</h2><blockquote>
<p>获取Mesh Filter然后获取到模型数据,然后通过代码获取到Mesh模型数据，通过赋值重现模型</p>
<ul>
<li>先清空 Clear</li>
<li>再赋值<ul>
<li>vertices 网格顶点数组;</li>
<li>normals 网格的法线数组;</li>
<li>triangles 包含所有三角形的顶点索引数组;</li>
<li>uv 网格的基础纹理坐标;</li>
<li>tangents 网格的切线数组;</li>
</ul>
</li>
<li>再重新计算包围盒 RecalculateBounds</li>
<li>再配置MeshRender组件，配置好材质</li>
</ul>
</blockquote>
<h2 id="扩展三角形面"><a href="#扩展三角形面" class="headerlink" title="扩展三角形面"></a>扩展三角形面</h2><p><img src="unity学习笔记/54_1.png" alt="还没有图片哦"></p>
<h1 id="第五十五课（unity-旧版动画系统）"><a href="#第五十五课（unity-旧版动画系统）" class="headerlink" title="第五十五课（unity_旧版动画系统）"></a>第五十五课（unity_旧版动画系统）</h1><h2 id="旧版动画系统"><a href="#旧版动画系统" class="headerlink" title="旧版动画系统"></a>旧版动画系统</h2><blockquote>
<p>动画在Fbx模型里面，需要用美术给的动画帧数来切分动画。</p>
<ul>
<li>导入一个包含多个动画的模型文件;</li>
<li>选中模型文件的Rig tab Animation –&gt; Legacy模式(传统的/旧版);</li>
<li>根据美术给出的时间点，来分割动画;</li>
<li>Animation组件动画播放:<ul>
<li>Animation 启用自动播放时，播放的默认动画;</li>
<li>Animations 可以从脚本的访问的动画列表;</li>
<li>Play Automatically: 是否自动播放</li>
<li>Animate Physics 动画是否与物理交互;</li>
<li>Culling Type 设置动画的剔除模型: <ul>
<li>Always Animate总是播放动画, </li>
<li>Base On Renders 只有渲染在屏幕上的对象才会播放动画;</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="代码播放"><a href="#代码播放" class="headerlink" title="代码播放"></a>代码播放</h2><ul>
<li>Animation类的Play: 播放指定名称的动画;</li>
<li>Animation类的Stop:  停止播放指定名称的动画;</li>
<li>Animation类的CrossFade动画融合: 以融合模式来切换动画;<ul>
<li>动画融合能确保动画完美的过渡,两个动作之间不会有突然切换;</li>
<li>第一个参数下一个播放的名字, 切换的时间间隔, 淡入淡出的模式;</li>
<li>淡出的模式: <ul>
<li>PlayMode.StopSameLayer 淡入新动画时，只淡出与name同一层的动画,</li>
<li>PlayMode.StopAll 淡入新动画时，淡出所有的动画;</li>
</ul>
</li>
</ul>
</li>
<li>动画混合:<br>  动画混合能消减游戏创建动画数量,让一些动画只应用给身体的一部分,和其它的动画配合一起使用。一个挥手动画，空闲挥手，和行走挥手，如果没有动画混合，就要为这个挥手创建2个动画，一个是空闲的挥手，一个是行走的挥手。<br>  AddMixingTransform 进行动画混合;</li>
</ul>
<h1 id="第五十六课（unity-mecanim人形动画系统-一-Avatar动画控制器）"><a href="#第五十六课（unity-mecanim人形动画系统-一-Avatar动画控制器）" class="headerlink" title="第五十六课（unity_mecanim人形动画系统(一)Avatar动画控制器）"></a>第五十六课（unity_mecanim人形动画系统(一)<em>Avatar</em>动画控制器）</h1><h2 id="Mecanim动画"><a href="#Mecanim动画" class="headerlink" title="Mecanim动画"></a>Mecanim动画</h2><ul>
<li>旧版动画系统只能通过代码来控制动画播放,随着动画种类变多，代码复杂度也会增加，同时动画过渡也需要非常繁琐的代码控制,为了让有经验的动画师开发动画，unity推出了针对人物角色的Mecanim动画系统;</li>
<li>Mecanim支持运动重定向(Retargeting)功能,即把动画从一个角色模型应用到另一个角色模型;</li>
<li>Mecanim允许使用“肌肉”来控制不同骨骼的运动范围;</li>
<li>Mecanim动画系统三要素:<ul>
<li>Avatar: 从Mecanim系统的简化人形骨架结构到用户实际提供的骨架结构的映射;</li>
<li>Animator Controller: 动画控制器用来控制动画的播放和过渡条件</li>
<li>Animation Clip: 动画剪辑;</li>
</ul>
</li>
</ul>
<h2 id="配置Avatar"><a href="#配置Avatar" class="headerlink" title="配置Avatar"></a>配置Avatar</h2><ul>
<li>导入模型后，将模型的动画模式配置成Humanoid模式。<ul>
<li>None: 无模式, </li>
<li>Legacy: 旧版动画模式, </li>
<li>Generic 其他动画模式, </li>
<li>Humanoid 人形角色动画模式; </li>
</ul>
</li>
<li>系统将会自动生成模型对应的Avatar文件, 并作为其子对象;</li>
<li><p>大部分情况下Mecanim都能正确的生成Avatar文件,                                           <img src="unity学习笔记/56_1.png" alt="图片还没有哦"></p>
<blockquote>
<p>Configure这个前面会有一个勾,点击Config,能查看到<br>映射情况,如果有错误,就没有勾,点击Config,手动做好人形骨骼的映射。<br>完整的是绿色的，有红色的说明就是没有关联好的</p>
</blockquote>
</li>
<li><p>Mapping:</p>
<ul>
<li>Clear清除映射, </li>
<li>AutoMap自动映射;</li>
</ul>
</li>
<li><p>如果骨骼绑定正确，但是角色姿势不对（不是标准的T形）,<br>在Scene中可看到消息“Character not in T-Pose”，解决此问题<br>可通过<code>Pose-&gt;Enforce T-Pose</code>或旋转其它的骨骼。</p>
<blockquote>
<p><img src="unity学习笔记/56_2.png" alt="图片还没有哦"></p>
</blockquote>
</li>
<li><p>Muscle配置:对于过于夸张的一些动作，可以通过对骨骼限定范围来进行调整，让这个骨骼运动在这个范围内，这样，就不用重新制作动画;</p>
<ul>
<li>点击要限制的骨骼;  </li>
<li>调整骨骼的运动范围的参数;          </li>
</ul>
</li>
</ul>
<h2 id="动画控制器配置"><a href="#动画控制器配置" class="headerlink" title="动画控制器配置"></a>动画控制器配置</h2><ul>
<li>动画控制器</li>
<li>动画层</li>
<li>动画状态机<ul>
<li>动画状态机必然包含有3个动画状态单元 Any State, Exit, Entry;</li>
<li>动画状态机可以包含多个动画状态单元;</li>
<li>还可以包含子动画状态机;</li>
</ul>
</li>
<li>动画状态单元的创建:<ol>
<li>Animator窗口中鼠标右键 在菜单中选择 Create State–&gt;Empty;</li>
<li>将动画文件拖入到Animator窗口;</li>
</ol>
</li>
<li>过渡条件连接:<br>  (1)将鼠标放在状态单元上,鼠标右键–&gt;Make Transition,创建动画过渡条件，并再次点击在另一个状态单元上，完成过渡条件连接;</li>
<li>默认动画单元: <ul>
<li>idle被设置为默认动画并显示为黄色, 其他动画显示为灰色,</li>
<li>也可以在任意非默认单元上右键 Set As Default来设置默认的动画;</li>
</ul>
</li>
</ul>
<h2 id="过渡条件"><a href="#过渡条件" class="headerlink" title="过渡条件"></a>过渡条件</h2><ul>
<li>动画状态机搭建完成后，需要编写过渡条件，对过渡条件设置来播放和过渡;</li>
<li>Mecanim支持过渡参数类型Float, Int, Bool, Trigger, Parameters添加对应类型的参数</li>
<li>选中任意一个过渡条件,在属性视图中的Conditions列表中点击”+”添加参数，并为参数添加对比条件。<br> Greator, Less;</li>
<li>代码里面设置过渡条件，来控制代码播放;</li>
</ul>
<h1 id="第五十七课（unity-人形动画重定向与动画混合树）"><a href="#第五十七课（unity-人形动画重定向与动画混合树）" class="headerlink" title="第五十七课（unity_人形动画重定向与动画混合树）"></a>第五十七课（unity_人形动画重定向与动画混合树）</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li>在人形动画系统中，所有的角色动画都属于unity定义的统一的人形，而我们的角色动画都是征询这个规矩做的，Avatar文件做好映射，那么如果我们是基于人形而调的骨骼动画，动画师调出了角色A的动画，那么角色B也可以使用这个动画师做好的动画，他们使用同样的动画和动画控制器，这样简化了动画的工作，解绑了动画师和建模师之间的工作依赖。</li>
<li>传统的动画，每个模型要做一个动画，而人形动画可以解决这个问题。</li>
<li>能够使包体大小变小。</li>
</ul>
<h2 id="角色动画的混合"><a href="#角色动画的混合" class="headerlink" title="角色动画的混合"></a>角色动画的混合</h2><ul>
<li>游戏开发过程中,有时候会有将两个动画混合成一个动画的需求,比如编写一个边跑边招手的动作,开发好了跑步的动作，和招手的动作，按照传统的方式需要重新再开发一个动作，Unity提供了角色动画的混合，能把两个动画合成一个新的动画;</li>
<li>混合动画基于混合动画树完成，混合动画树是 动画状态的其中一种，可以加入到动画状态机，可以看作是混合后新的一个动画;</li>
<li>创建步骤: <ul>
<li>创建Blend Tree,  create—&gt; From New Blend Tree,</li>
<li>添加要混合的动画到动画列表，可以添加，也可以删除;</li>
<li>配置混合参数，来进行混合。</li>
<li>BlendTree支持子树</li>
</ul>
</li>
</ul>
<h2 id="动画混合算法"><a href="#动画混合算法" class="headerlink" title="动画混合算法"></a>动画混合算法</h2><ul>
<li>1D混合方式: 最简单常用的混合方式,每个被混合的子动画都会被分配一个可以修改的Float的值,开发人员可以修改这个值来改变混合动画的效果，混合结果中比例越大，就越靠近那个动画;</li>
<li>2D Simple Directional混合方式:以两个混合参数作为混合结果的横竖坐标值,混合的动画以正方形的方式混合在面板中。各自的混合比例用正方型外围的圆圈表现出来;每个动画的分布也以颜色的深浅表现出来;</li>
<li>2D Freeform Directional混合方式:每个源动画都有一个放射性的显示面板,颜色越白权重越大。反之越小,可以通过移动源动画点，对现实面板进行调整;</li>
<li>2D Freeform Cartesian混合方式: 源动画相连渐变表示,混合面板中颜色的深浅表示了各自动化的在混合动画中的权重;</li>
</ul>
<h1 id="第五十八课-unity-动画单元代码控制-代码生成动画控制器"><a href="#第五十八课-unity-动画单元代码控制-代码生成动画控制器" class="headerlink" title="第五十八课(unity_动画单元代码控制_代码生成动画控制器)"></a>第五十八课(unity_动画单元代码控制_代码生成动画控制器)</h1><h2 id="动画状态代码控制"><a href="#动画状态代码控制" class="headerlink" title="动画状态代码控制"></a>动画状态代码控制</h2><ul>
<li>每个动画状态，比如进入状态，离开状态, 等都有可能需要代码来参与和处理，比如，进入这个动画单元后做哪些事情，来开这个动画单元后做哪些事情，为了解决这个问题,unity允许每个动画单元来绑定一个脚本代码，这个脚本代码必须继承于StateMachineBehaviour;</li>
<li>可以在动画状态的Add Behaviour上添加挂载一个脚本到动画状态;</li>
<li>StateMachineBehaviour主要接口:<ul>
<li>OnStateEnter: 当动画开始播放的时候被调用;</li>
<li>OnStateUpdate: 每帧都会被调用;</li>
<li>OnStateExit:  当动画结束播放的时候被调用;</li>
<li>OnStateMove: 当动画被移动的时候调用;</li>
<li>OnStateIK: 当动画触发逆向运动学时调用此方法;</li>
</ul>
</li>
</ul>
<h2 id="代码生成动画控制器"><a href="#代码生成动画控制器" class="headerlink" title="代码生成动画控制器"></a>代码生成动画控制器</h2><blockquote>
<p>10个状态，每2个状态之间需要建立两两的联系，那么这个动画控制器就会有100个过渡条件，那么这个时候最好的方式是代码自动的生成动画控制器;</p>
</blockquote>
<ul>
<li>扩展编辑器，来动态生成这个动画控制器，不用手动的去修改;</li>
<li>扩展编辑器的相关的API:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// CreateAnimCtrl.cs</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEditor.Animations;</span><br><span class="line"></span><br><span class="line">// 添加菜单选项 // 例如 Assets/Create/CreateAnimCtrl</span><br><span class="line">[MenuItem(&quot;菜单路径&quot;)]</span><br><span class="line"></span><br><span class="line">static void Run()&#123;</span><br><span class="line">    // 入口函数</span><br><span class="line">    Debug.Log(&quot;called...&quot;);</span><br><span class="line"></span><br><span class="line">    // Step1 生成我们的动画控制文件(动画控制器)</span><br><span class="line">    // Assets/res/code_anim.controller 创建的文件路径以及名字</span><br><span class="line">    AnimatorController ctrl  = UnityEditor.Animations.AnimatorController.CreateAnimatorControllerAtPath(&quot;Assets/res/code_anim.controller&quot;);</span><br><span class="line">    // Step2 获取我们的动画状态机</span><br><span class="line">    AnimatorStateMachine state_machine = ctrl.layers[index].stateMachine;</span><br><span class="line"></span><br><span class="line">    // Step3 创建我们的动画状态</span><br><span class="line">    AnimatorState[] state = new AnimatorState[10];</span><br><span class="line">    for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line"></span><br><span class="line">        // 添加进状态机里面</span><br><span class="line">        state[i] = state_machine.AddState(&quot;state&quot; + i);</span><br><span class="line"></span><br><span class="line">        // 加载AnimationClip:  path动画路径文件名  </span><br><span class="line">        AnimationClip anim = AssertDatabase.LoaderAssetAtPath(&quot;path&quot;, typeof(AnimationClip)) as AnimationClip;</span><br><span class="line">        // 为每个状态指定动画:</span><br><span class="line">        state[i].motion = anim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 两两动画组合过度</span><br><span class="line">    for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">        for(int j = 0;j &lt; 10;j++)&#123; // i --&gt; j Transition</span><br><span class="line">            // 创建每个过渡的控制变量</span><br><span class="line">            ctrl.AddParameter(i + &quot;switch&quot; + j, AnimatorControllerParameterType.Trigger);</span><br><span class="line"></span><br><span class="line">            // 添加每一个过度动画需要的条件</span><br><span class="line">            AnimatorStateTransition trans = state[i].AddTransition(state[j], false);</span><br><span class="line">            trans.AddCondition(AnimatorConditionMode.If, 0, i + &quot;switch&quot; + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置一个默认动画状态;</span><br><span class="line">    state_machine.defaultState = state[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第五十九课（unity-地形的创建）"><a href="#第五十九课（unity-地形的创建）" class="headerlink" title="第五十九课（unity_地形的创建）"></a>第五十九课（unity_地形的创建）</h1><h2 id="地形的基本组件"><a href="#地形的基本组件" class="headerlink" title="地形的基本组件"></a>地形的基本组件</h2><ul>
<li>创建一个地形Object:  GameObject—&gt; 3D Object–&gt;Terrain;</li>
<li>这个节点包含了两个组件,Terrain 和 Terrain Collider;</li>
<li>Terrain Collider 地形与物理引擎方面的组件,实现了地形的物理模拟,似的其他的挂载了物理碰撞器的物体能够与地形进行物理交互;</li>
<li>Terrain Collider的参数含义:<ul>
<li>Material: 该地形的物理材质, 通过改变参数可以分别开发出像戈壁滩，软草地之类的效果;</li>
<li>Terrain Data: 地形数据,用户存储该地形的地势以及其他的信息;</li>
<li>Enable Tree Colliders: 开启树木参与碰撞检测;(一般是去掉的)</li>
</ul>
</li>
<li>Terrain 组件中有一排按钮分别对应了地形引擎的各项操作和设置;</li>
</ul>
<h3 id="Terrain"><a href="#Terrain" class="headerlink" title="Terrain"></a>Terrain</h3><h4 id="Raise-And-Lower-Terrain-升高-下降地形"><a href="#Raise-And-Lower-Terrain-升高-下降地形" class="headerlink" title="Raise And Lower Terrain(升高/下降地形)"></a>Raise And Lower Terrain(升高/下降地形)</h4><ul>
<li>Brushes: 画笔样式，使用不同样式绘制对应的地形;</li>
<li>Brush Size: 画笔大小,其实际含义为画笔直径长度，单位为m;</li>
<li>Opacity: 画笔透明度,值越大，调整的强度越大，反之越小;</li>
<li>点击和拖动鼠标可以使得鼠标点过的地方突起，同时按下shift,可以实现下凹的功能;</li>
<li>没有经过操作的是没有办法拉低的，水平面是动不了的;</li>
</ul>
<h4 id="Paint-Height-涂料高度"><a href="#Paint-Height-涂料高度" class="headerlink" title="Paint Height(涂料高度)"></a>Paint Height(涂料高度)</h4><ul>
<li>Brushes: 画笔样式。使用不同的画笔样式，可以绘制出相应样式的地形;</li>
<li>BrushSize: 画笔的大小长度为米为单位;</li>
<li>Opacity: 画笔的透明度，值越大，调整的强度越大，反之越小;</li>
<li>Height: 制定高度值;</li>
<li>Flatten: 使得整个地形的高度值都设置为指定的高度值，使得整个上移和下沉;</li>
</ul>
<h4 id="Smooth-Height-平滑高度"><a href="#Smooth-Height-平滑高度" class="headerlink" title="Smooth Height(平滑高度)"></a>Smooth Height(平滑高度)</h4><ul>
<li>Smooth Height:在处理过程中某些地形比较突兀，山峰过于锐利,需要对地形做平滑处理</li>
<li>Brushes: 画笔样式。使用不同的画笔样式，可以绘制出相应样式的地形;</li>
<li>BrushSize: 画笔的大小长度为米为单位;</li>
<li>Opacity: 画笔的透明度，值越大，调整的强度越大，反之越小;</li>
</ul>
<h4 id="地形灰度图-导入灰度图制作地形，可以用psd文件"><a href="#地形灰度图-导入灰度图制作地形，可以用psd文件" class="headerlink" title="地形灰度图(导入灰度图制作地形，可以用psd文件)"></a>地形灰度图(导入灰度图制作地形，可以用psd文件)</h4><ul>
<li>Unity将内置的地形引擎将地形的高度信息以灰度的形式保存到一张灰度图里面;</li>
<li>优点:<ul>
<li>存储空间小; </li>
<li>和其他的地形工具配合使用;</li>
</ul>
</li>
<li>灰度图的使用:<ul>
<li>打开Photoshop, 设置图片的宽度为33x33(1 + 32 * x, 当x = 1时为33) 32的整数倍 + 1;</li>
<li>制作高度图片后，将图片保存为Raw的格式;</li>
<li>点击Terrain Setting: 导入(Heightmap–&gt;Import Raw)刚才生成的Raw格式的灰度图，然后就会生成相应的高度图</li>
<li>也可以把当前的地形到处高度图给其他的人使用;</li>
</ul>
</li>
</ul>
<h4 id="Paint-Texture（地形贴图）"><a href="#Paint-Texture（地形贴图）" class="headerlink" title="Paint Texture（地形贴图）"></a>Paint Texture（地形贴图）</h4><ul>
<li>设置好地形的贴图，画笔经过的地方，都会将纹理贴到对应的地形上;</li>
<li>Brushes: 画笔样式;</li>
<li>Textures: 可绘制的纹理;</li>
<li>BrushSize: 画笔大小;</li>
<li>Opacity: 画笔透明度，值越大调整的强度就越大，反之越小;</li>
<li>Target Strength: 画笔涂抹的强度值，改值得范围为0~1,代表了地形原来的混合比例;</li>
<li>Unity也支持psd图片的格式(Photoshop的源文件格式),打包的时候会生成图片。方便了开发;</li>
</ul>
<h4 id="Place-Trees（植树-可用预制体）"><a href="#Place-Trees（植树-可用预制体）" class="headerlink" title="Place Trees（植树 可用预制体）"></a>Place Trees（植树 可用预制体）</h4><ul>
<li>可以通过涂画的方式来对树木进行种植,只要提供单个树目，就可以铺设;</li>
<li>Place Trees 参数:<ul>
<li>Trees: 树木对象的预制体对象;</li>
<li>Brush Size: 画笔大小，单位为米;</li>
<li>Tree Density: 植树密度，每次植树时参生树木的棵数;</li>
<li>Tree Height: 树木的高度，可以指定也可以随机分配;</li>
<li>Lock Width to Height: 是否锁定横纵比例,保持原始高度;</li>
<li>Tree Width: 树木的宽度。</li>
</ul>
</li>
</ul>
<h4 id="Place-Details（植草-可以用psd文件-纹理-、预制体）"><a href="#Place-Details（植草-可以用psd文件-纹理-、预制体）" class="headerlink" title="Place Details（植草 可以用psd文件(纹理)、预制体）"></a>Place Details（植草 可以用psd文件(纹理)、预制体）</h4><ul>
<li>功能与Place Trees相似;</li>
<li>Place Details 参数:<ul>
<li>Brushes: 画笔样式;</li>
<li>Brush Size: 画笔大小，单位为米;</li>
<li>Details: 纹理对象列表。</li>
<li>Opacity: 画笔的透明度, 值越大，强度越大;</li>
<li>Target Strength: 画笔的涂抹强度,该值的范围为0~1。</li>
</ul>
</li>
</ul>
<h4 id="TerrainSettings"><a href="#TerrainSettings" class="headerlink" title="TerrainSettings"></a>TerrainSettings</h4><ul>
<li>Draw: 是否显示地形;</li>
<li>PixelError: 像素误差,地形的绘制精度，值越大细节越少;</li>
<li>Base Map Dist 基础图距, 当与地形距离超过该值时，则以低分辨率来显示(远处细节减少，节省性能);</li>
<li>Cast Shadows:是否进行阴影投射;</li>
<li>Materials: 材质类型: 标准，漫反射, 高光，自定义(自己指定材质);</li>
<li>Reflection Probes: 反射探头的类型: 关闭,混合探头, 混合以及天空盒探头,一般；</li>
<li>Tickness:物理引擎中该地形可碰撞的厚度;</li>
<li>Draw:  是否显示花草树木;</li>
<li>Bake Light Probes For Tree: 烘培光照探头到树木上;</li>
<li>Detial Distance: 细节距离，与相机键的细节可现实的距离值(超过这个距离不显示);</li>
<li>Collect Detail Patches: 进行细节补丁的收集;</li>
<li>Detail Density: 细节的密度程度;</li>
<li>Tree Distance: 树木的可视距离;</li>
<li>Billboard Start: 标志板的起点(公告板，总是在最前，有的树可以调整距离让它一直在前，节约性能，因为只用了一张图片就可做出树木的效果)，比标志版形式出现的树木与摄像机的距离;</li>
<li>Fade Length: 渐变长度;</li>
<li>Max Mesh Trees:允许出现的网格类型的树木的最大数量;</li>
<li>Speed: 风吹过草地的风速;</li>
<li>Size: 模拟风能影响的范围;</li>
<li>Bending:草被封能吹弯的程度;</li>
<li>Grass Tint: 草地总着色量的值;</li>
<li>Terrain Width/Height/Length 地形的宽度/高度/总长度;</li>
<li>Heightmap Resolution地形灰度值的精度;</li>
<li>Detial Resolution: 细节精度值，越大，细节越精细;</li>
<li>Detial Resolution per patch: 每小块地形设置的精度值;</li>
<li>Control Texture Resolution: 将不同的纹理插值绘制到地形上时设置的精度值;</li>
<li>Base Texture Resolution:在地形上绘制基础纹理时采用的精度值;</li>
<li>Heightmap 高度图</li>
</ul>
<h1 id="第六十课（拖尾渲染器的使用）"><a href="#第六十课（拖尾渲染器的使用）" class="headerlink" title="第六十课（拖尾渲染器的使用）"></a>第六十课（拖尾渲染器的使用）</h1><h2 id="拖尾渲染器-Trall-Renderer"><a href="#拖尾渲染器-Trall-Renderer" class="headerlink" title="拖尾渲染器(Trall Renderer)"></a>拖尾渲染器(Trall Renderer)</h2><ul>
<li>游戏中炮弹后面的拖尾, 以及汽车轮胎拖痕等绚丽特效,unity提供了拖尾渲染器;</li>
<li>拖尾渲染器的属性:<ul>
<li>Materials: 用户渲染拖尾的材质数组。</li>
<li>Size: 在材质数组总共有多少元素。</li>
<li>Element 0:用户渲染拖尾的材质的引用;个数由Size决定;</li>
<li>Time:  拖尾的长度,以s为单位;</li>
<li>Start Width: 开始位置拖尾的宽度;</li>
<li>End Width: 结束位置的拖尾宽度;</li>
<li>Colors: 拖尾长度颜色渐变的拖尾数组,也可以在这些颜色中使用Alpha;</li>
<li>Color0 ~Color4 拖尾的颜色，从开始到结束;</li>
<li>Min Vertex Distance:  拖尾锚点之间的最小距离（越小精度越高，性能也就差一些，越大精度越低）;</li>
<li>AutoDesturct: 将这一项设置为允许,来使物体在静止时候后拖尾即将被销毁;</li>
</ul>
</li>
</ul>
<h2 id="使用事项"><a href="#使用事项" class="headerlink" title="使用事项"></a>使用事项</h2><ul>
<li>Materials材质:<br>  使用一个包含粒子着色器的材质，材质使用的贴图必须是平方尺寸,在size属性中可以设置材质的个数,在Element属性中添加材质;</li>
<li>Trail Width: 拖尾宽度，配合时间属性可以调节他显示和表现;</li>
<li>Trail Colors: 通过5种颜色和透明度组合循环变化拖尾,使用这些颜色能控制头部和尾部之间进行渐变;</li>
<li>Min Vertex Distance最小顶点距离;<br>  最小顶点距离决定了包含拖尾的物体在一个拖尾段实例化之前必须经过的距离,较小的值将更频繁的创建拖尾段, 生成更平滑的拖尾，性能有损失，较大的值将显示出更多的锯齿段,找一个满足效果的最大的值;</li>
<li>使用注意:<ul>
<li><strong>使用拖尾渲染器不能使用其他的渲染器</strong>,(一般创建一个空节点，添加拖尾渲染组件,将拖尾要跟随的物体设置为拖尾的父亲)</li>
<li>最好使用粒子材质，这样可以达到更好的效果;<br><img src="unity学习笔记/60_1.png" alt="还没有图片哦"></li>
</ul>
</li>
</ul>
<h1 id="第六十一课（unity-navmesh网格导航寻路）"><a href="#第六十一课（unity-navmesh网格导航寻路）" class="headerlink" title="第六十一课（unity_navmesh网格导航寻路）"></a>第六十一课（unity_navmesh网格导航寻路）</h1><h2 id="烘焙网格导航"><a href="#烘焙网格导航" class="headerlink" title="烘焙网格导航"></a>烘焙网格导航</h2><ul>
<li>将地图元素标记为 <code>Navigation Static</code></li>
<li>调出Navigation 导航窗口,<code>Window--&gt;Navigation</code>, 在改窗口下按下Bake按钮,进行网格导航烘培;<br>  <img src="unity学习笔记/61_1.png" alt="还没有图片哦"><br>  <img src="unity学习笔记/61_2.png" alt="还没有图片哦"></li>
<li>被标记为<code>Navigation Static</code>的对象，都会出现青色的导航网格层,同时在Assets目录下会生成Pathing文件<code>NavMesh.asset</code></li>
</ul>
<h2 id="Nav-mesh-agent（代理器挂载到要寻路的物体）"><a href="#Nav-mesh-agent（代理器挂载到要寻路的物体）" class="headerlink" title="Nav mesh agent（代理器挂载到要寻路的物体）"></a>Nav mesh agent（代理器挂载到要寻路的物体）</h2><ul>
<li>代理器,角色或NPC(非玩家控制角色)关联好这个组件就能够使用这个组件在在地图上行走;</li>
<li>nav mesh agent 参数:<ul>
<li>Radius 代理器半径;</li>
<li>Speed代理器移动速度;</li>
<li>Acceleration 代理器加速度;</li>
<li>Angular Speed代理器角速度;</li>
<li>Stop distance 代理器到达时与目标的距离; </li>
<li>Auto Tranver OffMesh Link 是否穿过自定义路线;</li>
<li>AutoBaking 是否自动停止无法达到目的地的路线;</li>
<li>Auto Repath: 原有路线发生变化的时候，是否重新寻路;</li>
<li>Height: 代理器的高度;</li>
<li>Base Offset: 代理器相对导航网格的偏移;</li>
<li>Obstacle AvoidanceType: 代理器回避级别;</li>
<li>Avoidance Priority 代理器回避优先级;</li>
<li>Area Mask: 代理器可使用的导航网格层,unity对导航网格层以2^0, 2^1次对第0层第1层进行编码, Walkable是各层数据的和，比如3，可以在第0层和第1层移动;</li>
</ul>
</li>
</ul>
<h2 id="自定义路线-Off-Mesh-Link"><a href="#自定义路线-Off-Mesh-Link" class="headerlink" title="自定义路线(Off Mesh Link)"></a>自定义路线(Off Mesh Link)</h2><ul>
<li>为了满足复杂的地形而提供的特殊组件,开发人员可以自行设计所需路线,该路线会并入到导航网络中;一并参与寻路计算;</li>
<li>Off Mesh Link含义:<ul>
<li>Start:  定义路线的起始位置信息(有一个小圆圈，表示路搭好了);</li>
<li>End 自定义路线的目标位置信息(有一个小圆圈，表示路搭好了);</li>
<li>Cost Override: 自定义路线的成本覆盖;</li>
<li>Bi directional 自定义路线是否允许双线穿越（可走向start也可以走向end）;</li>
<li>Activated: 是否激活改路线;</li>
</ul>
</li>
<li>自定义Area Type:<ul>
<li>Walkable: 这个区域可以行走;</li>
<li>Not Walkable: 这个区域不可以行走;</li>
<li>Jump: 可跳过，将会自动生成auto-generated Off-Mesh Links<h2 id="动态障碍物（Nav-mesh-obstacle）"><a href="#动态障碍物（Nav-mesh-obstacle）" class="headerlink" title="动态障碍物（Nav mesh obstacle）"></a>动态障碍物（Nav mesh obstacle）</h2></li>
</ul>
</li>
<li>导航代理在移动过程中会忽略碰撞体，所以就会穿越动态的障碍物，为了防止这个情况的发生，Unity 3D提供了一个NavMesh Obstacle组件来提供对动态障碍物的支持,这样就可以设置英雄不被穿越的效果;</li>
<li>Navmesh obstacle 参数含义:<br> (1) Radius: 动态障碍物的半径;<br> (2) Height:   动态障碍物的高度;<br> (3) Move Threshold: 动态障碍物移动阈值;<br> (4) Carve: 是否允许被代理穿越;</li>
</ul>
<h1 id="第六十二课（unity-协程-多线程-WWW类）"><a href="#第六十二课（unity-协程-多线程-WWW类）" class="headerlink" title="第六十二课（unity_协程_多线程_WWW类）"></a>第六十二课（unity_协程_多线程_WWW类）</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li>在主进程中开启另外一段逻辑处理，来协同当前程序的执行,但与多线程不同都是在主线程里面执行的,通过StartCoroutine方法来启动一个协程;</li>
<li><p>StartCoroutine是MonoBehaviour的一个方法,改方法可以启动一个协程,协程必须要是一个<br>IEnumerator 作为返回值的方法;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 用协程的方式来执行这个函数(这个协程)</span><br><span class="line">StartCoroutine(fun_name());</span><br><span class="line"></span><br><span class="line">// 协程的入口</span><br><span class="line">IEnumerator fun_name()&#123;</span><br><span class="line">    // 协程的代码</span><br><span class="line">    // yield中断协程程序</span><br><span class="line">    yield return null;</span><br><span class="line">    // 协程结束以后的代码</span><br><span class="line"></span><br><span class="line">    // 协程里面也可以启动协程</span><br><span class="line">    StartCoroutine(fun_other());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 协程的入口</span><br><span class="line">IEnumerator fun_other()&#123;</span><br><span class="line">    // 协程的代码</span><br><span class="line">    // yield中断协程程序</span><br><span class="line">    // 等3s再中断协程</span><br><span class="line">    yeild return new WaitForSeconds(3);</span><br><span class="line">    // 协程结束以后的代码 等待3s再执行后面的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协同程序可以使用yield 关键字来中断协同程序;</p>
</li>
<li>协程也可以启动一个协程;</li>
<li>WaitForSeconds(): 等待多长时间后中断协程;</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>using System.Thread;</li>
<li>创建一个线程: (函数名就行了，不用括号)<ul>
<li>Thread r = new Thread(callback_name);  </li>
<li>r.start(); 启动运行线程;</li>
</ul>
</li>
<li>线程回掉函数 void run() {}</li>
<li>多个线程访问同一个数据的时候，会发生”冲突”(没有锁，如果两个线程同时修改这个公共数据，没有办法确定到底是哪一个线程修改的),需要线程安全的方式来访问;</li>
<li><p>线程锁是在访问公共数据的时候，先去获得这个锁，没有获得锁的线程将会被挂起,指导这个锁被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">死锁</span><br><span class="line">    A线程拿了锁A，再等拿锁B</span><br><span class="line">    B线程拿了锁B，再等拿锁A</span><br><span class="line">    A等着，B也等着，就造成了死锁</span><br><span class="line">    解决方案：如果多个线程里面要获取多个锁的时候，为了避免死锁，要按相同的循序拿谁抢到就谁先执行</span><br><span class="line">    A线程拿了锁A，再等拿锁B</span><br><span class="line">    B线程拿了锁A，再等拿锁B(谁抢到就谁先执行)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 创建一个锁</span><br><span class="line">public static Object  o = new Object();</span><br><span class="line"></span><br><span class="line">lock(o) // 如果没有拿到这个锁 线程就会挂起等待，只有获取到了锁才会继续执行</span><br><span class="line">&#123; // 获得了这个锁</span><br><span class="line">//线程安全的执行代码</span><br><span class="line">&#125;;</span><br><span class="line">// 括号结束以后，就释放了这个锁，其他的线程就可以拿到这个锁</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程休眠: Thread.Sleep(单位为ms);</p>
</li>
<li>多线程之间要避免死锁;</li>
</ul>
<h3 id="WWW网络类"><a href="#WWW网络类" class="headerlink" title="WWW网络类"></a>WWW网络类</h3><ul>
<li>WWW w = new WWW(url); 创建一个w</li>
<li>WWW(url)会在后台下载url数据;</li>
<li>yeild return w来在协程里等待下载完成;</li>
<li>完成后可以继续处理;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator http_baidu()&#123;</span><br><span class="line">    // 抓取百度网页</span><br><span class="line">    WWW w = new WWW(&quot;www.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">    // 网络抓取是需要时间，在后台抓取网络数据，一段时候以后，才能完成抓取完整个数据</span><br><span class="line">    yeild return w;</span><br><span class="line"></span><br><span class="line">    // 抓取完成网络数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="第六十三课（unity-AssetBundle的使用详解）"><a href="#第六十三课（unity-AssetBundle的使用详解）" class="headerlink" title="第六十三课（unity_AssetBundle的使用详解）"></a>第六十三课（unity_AssetBundle的使用详解）</h1><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><ul>
<li>Unity能用户存储资源的一种压缩格式的打包集合,他可以存任意一种Unity引擎可以识别的资源: 模型，音频，纹理图，动画, 开发者自定义的二进制文件; 安装包小，更新资源;</li>
<li>AssetBundle开发步骤:<ul>
<li>创建AssetBundle: 项目的资源打包AssetBundle的集合里面;</li>
<li>部署到web服务器, 让客户端下载我们的AssetBundle;</li>
<li>加载AssetBundle, 加载里面的资源;</li>
<li>卸载AssetBundle, 压缩包，镜像;</li>
</ul>
</li>
</ul>
<h2 id="AssetBundle创建"><a href="#AssetBundle创建" class="headerlink" title="AssetBundle创建"></a>AssetBundle创建</h2><ul>
<li>Assets窗口的资源才可以打包;</li>
<li>创建一个AssetBundle文件,它的名字固定式小写如果有大写系统也会换成小写;</li>
<li>AssetBundle可以设置一个Varaint(资源类型)，就是一个后缀。可以通过后缀来设置不同分辨率的资源;</li>
</ul>
<h3 id="配置AssetBundle打包-将要打包的资源配置好即可"><a href="#配置AssetBundle打包-将要打包的资源配置好即可" class="headerlink" title="配置AssetBundle打包(将要打包的资源配置好即可)"></a>配置AssetBundle打包(将要打包的资源配置好即可)</h3><ul>
<li>将一个资源打入到AssetsBundle: 点击资源，选择对应的AssetBundle就可以了;<ul>
<li><img src="unity学习笔记/63_1.png" alt="还没有图片哦"></li>
</ul>
</li>
<li>编写代码导出AssetBundle文件:<ul>
<li>using UnityEditor; 引入编辑器操作的名字空间; 继承Editor</li>
<li>调用Api:<ul>
<li>BuildPipeline.BuildAssetBundles(outpath, BuildAssetBundleOptions, BuildTarget);<ul>
<li>outpath 打包好的资源路径<blockquote>
<p>文件夹的路径需要手动创建，否者会报错;</p>
</blockquote>
</li>
<li>BuildAssetBundleOptions 一般设置为None就好 </li>
<li>BuildTarget 打包好的资源准备在哪一个平台上用(windows、ios、android…)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用buildmap来对指定的资源进行打包"><a href="#使用buildmap来对指定的资源进行打包" class="headerlink" title="使用buildmap来对指定的资源进行打包;"></a>使用buildmap来对指定的资源进行打包;</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// outpath 打包好的资源路径 文件夹的路径需要手动创建，否者会报错;</span><br><span class="line">BuildPipeline.BuildAssetBundles(outpath, AssetsBoundlesBuild[], BuildAssetBundleOptions, BuildTarget);</span><br><span class="line"></span><br><span class="line">//定义AssetBuild数组</span><br><span class="line">AssetBundleBuild[] buildMap = new AssetBundleBuild[2]; </span><br><span class="line"></span><br><span class="line">//打包的资源包名称，开发者可以随便命名</span><br><span class="line">buildMap[0].assetBundleName = &quot;resources&quot;;      </span><br><span class="line"></span><br><span class="line">//定义字符串，用来记录此资源包文件名称</span><br><span class="line">string[] resourcesAssets = new string[2]; </span><br><span class="line">//将需要打包的资源名称赋给数组      </span><br><span class="line">resourcesAssets[0] = &quot;resources/1.prefab&quot;;                 </span><br><span class="line">resourcesAssets[1] = &quot;resources/MainO.cs&quot;;</span><br><span class="line"></span><br><span class="line">buildMap[0].assetNames = resourcesAssets;//将资源名称数组赋给AssetBuild</span><br><span class="line"></span><br><span class="line">//打包资源并导出</span><br><span class="line">BuildPipeline.BuildAssetBundles(&quot;Assets/AssetBundles&quot;, buildMap, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);</span><br></pre></td></tr></table></figure>
<h2 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h2><ul>
<li>创建一个webserver, 配置好静态路径的位置，将生成的AssetBundle拷贝到服务器上;</li>
<li>生成Url路径后测试AssetBundle下载;</li>
<li>课程以node.js的express框架搭建的webserver为例来进行部署;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建服务器目录--&gt;在目录打开命令窗口安装 npm install express 安装 express</span></span><br><span class="line"><span class="comment">// www_root 放置资源的文件夹</span></span><br><span class="line"><span class="comment">// 创建js文件编写代码进行部署服务器</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 把静态文件路径 设置成服务器路径</span></span><br><span class="line">app.use(express.static(path.join(process.cwd(), <span class="string">"www_root"</span>)));</span><br><span class="line"><span class="comment">// 启用6868端口</span></span><br><span class="line">app.listen(<span class="number">6868</span>); <span class="comment">// http://127.0.0.1:6868/bundle_test  bundle_test 包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在命令窗口执行js脚本</span></span><br><span class="line"><span class="comment">// 使用 http://127.0.0.1:6868/bundle_test 访问看是否能找到要下载的文件 如果找到了 说明部署成功</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AssetBundle下载"><a href="#AssetBundle下载" class="headerlink" title="AssetBundle下载"></a>AssetBundle下载</h2><ul>
<li><p>非缓冲下载: 创建一个WWW的实例来下载AssetBundle;</p>
<ul>
<li>使用协程下载AssetBundle,</li>
<li>使用WWW的URL接口来下载;<blockquote>
<p>不能使用 WWW 对象去下载一个已经被加载进来的<code>AssetBundle</code>(使用www之前要确保支援已卸载干净);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写一个协程准备下载</span><br><span class="line">IEnumerator use_bundle()</span><br><span class="line">&#123;</span><br><span class="line">    WWW w = new WWW(&quot;http://127.0.0.1:6868/bundle_test&quot;);</span><br><span class="line"></span><br><span class="line">    yield return w;</span><br><span class="line"></span><br><span class="line">    // 内存镜像</span><br><span class="line">    AssetBundle assetBundle = w.assetBundle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>缓冲下载(传一个版本号，版本号不一样才会去下载,这个版本号自己定的):</p>
<blockquote>
<p>下载之后存到本地，如果再次下载版本号没变就从本地获取</p>
</blockquote>
<ul>
<li>使用WWW类的<code>LoadFromCacheOrDownload</code>来实现下载AssetBundle, 当再次下载的时候，只有当版本低或不存在的时候才下载;<blockquote>
<p>web平台缓冲的大小是50M， IOS/android缓冲的大小为4GB;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="AssetBundle加载使用-内存镜像"><a href="#AssetBundle加载使用-内存镜像" class="headerlink" title="AssetBundle加载使用(内存镜像)"></a>AssetBundle加载使用(内存镜像)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 内存镜像</span><br><span class="line">AssetBundle assetBundle = w.assetBundle;</span><br><span class="line">// 使用单个资源</span><br><span class="line">// 资源所在的路径名字可在打包好的 `*.manifest` 文件下看`Assets`下面就是文件列表</span><br><span class="line">assetBundle.LoadAsset(&quot;路径&quot;); </span><br><span class="line"></span><br><span class="line">// 加载所有的资源</span><br><span class="line">assetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用完记得卸载，看需求是全部卸载还是保留已加载的</p>
</blockquote>
<h2 id="AssetBundle卸载"><a href="#AssetBundle卸载" class="headerlink" title="AssetBundle卸载"></a>AssetBundle卸载</h2><ul>
<li>卸载<ul>
<li>AssetBoundle.Unload(false);<blockquote>
<p>false: 卸载内存镜像不卸载Asset内存实例;</p>
</blockquote>
</li>
<li>AssetBoundle.Unload(true);<blockquote>
<p>true: 卸载内存镜像以及Asset的内存实例;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="第六十四课（专题-一-DOTween插件使用）"><a href="#第六十四课（专题-一-DOTween插件使用）" class="headerlink" title="第六十四课（专题(一)DOTween插件使用）"></a>第六十四课（专题(一)DOTween插件使用）</h1><blockquote>
<p>补间动画</p>
</blockquote>
<h2 id="安装DOTween"><a href="#安装DOTween" class="headerlink" title="安装DOTween"></a>安装DOTween</h2><ul>
<li><a href="http://dotween.demigiant.com/getstarted.php" rel="external nofollow noopener noreferrer" target="_blank">官网</a></li>
<li>将DOTween解压后复制到项目的任意目录下(Editor, Plugins or Resources除外);</li>
<li>运行DOTween的Setup: 菜单栏的 Tools/Demigiant;</li>
<li>在代码里面 加上  DOTween的名字空间 using DG.Tween;</li>
<li>安装完DOTween插件后，很多组件能够支持Tween;</li>
</ul>
<h2 id="DOTween组件扩展"><a href="#DOTween组件扩展" class="headerlink" title="DOTween组件扩展"></a>DOTween组件扩展</h2><ul>
<li>其他的组件扩展了Tween接口: <a href="http://dotween.demigiant.com/documentation.php" rel="external nofollow noopener noreferrer" target="_blank">详情见文档</a><ul>
<li>AudioMixer  </li>
<li>AudioSource</li>
<li>Camera</li>
<li>Light</li>
<li>Material:</li>
<li>Rigidbody: </li>
<li>Rigidbody2D:</li>
<li>Transfrom</li>
</ul>
</li>
<li>Transfrom组件:<blockquote>
<p>会返回一个Tweener t</p>
<ul>
<li>组件实例.DOMove: 平移;</li>
<li>组件实例.DOScale: 缩放;</li>
<li>组件实例.DORotate 旋转;</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Tweener常用操作"><a href="#Tweener常用操作" class="headerlink" title="Tweener常用操作"></a>Tweener常用操作</h2><ul>
<li><p>常用的播放控制函数</p>
<ul>
<li>组件实例.DOPause();  暂停一个Tween;</li>
<li>组件实例.DOPlay/DOPlayBackwards/DOPlayForward; 播放/向后/向前</li>
<li>组件实例.DOKill; // 删掉Tween; 默认是自己删掉的</li>
</ul>
</li>
<li><p>设置循环次数</p>
<ul>
<li>t.SetLoop(num); <ul>
<li>num为-1，一直循环;</li>
</ul>
</li>
</ul>
</li>
<li>Tweener 常用的事件:<ul>
<li>OnStart(callback_name); 开始的时候</li>
<li>OnComplete(callback_name); 完成的时候</li>
<li>OnKill(callback_name); 删掉的时候</li>
<li>OnUpdate(callback_name); 播放的时候<blockquote>
<p>OnComplete，o如果是小写，直接 += 函数(跟委托一样)，如果是大写就填回调函数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Sequence队列"><a href="#Sequence队列" class="headerlink" title="Sequence队列"></a>Sequence队列</h2><ul>
<li>创建一个队列容器:  <ul>
<li>Sequence seq = DOTween.Sequence()</li>
</ul>
</li>
<li>将Tween加入到容器队列 <ul>
<li>seq.Append(tween);</li>
</ul>
</li>
<li>设置队列容器的循环次数;<ul>
<li>seq.SetLoops(num); num为-1，一直循环;</li>
</ul>
</li>
<li>插入一个并行的Tween<ul>
<li>seq.Insert(“插到哪一个位置”,Tween)</li>
</ul>
</li>
</ul>
<h2 id="Ease缓动效果"><a href="#Ease缓动效果" class="headerlink" title="Ease缓动效果"></a>Ease缓动效果</h2><ul>
<li>Tweener设置缓动动画:<ul>
<li>SetEase(效果类型,缓动的持续时间);</li>
</ul>
</li>
<li>效果类型:<ul>
<li>OutBack: 快速移动超出目标，然后慢慢回到目标点;</li>
<li>…..</li>
</ul>
</li>
</ul>
<h1 id="第六十五课（专题-二-游戏中的模型描边和Shader切换）"><a href="#第六十五课（专题-二-游戏中的模型描边和Shader切换）" class="headerlink" title="第六十五课（专题(二)游戏中的模型描边和Shader切换）"></a>第六十五课（专题(二)游戏中的模型描边和Shader切换）</h1><h2 id="模型描边"><a href="#模型描边" class="headerlink" title="模型描边"></a>模型描边</h2><blockquote>
<p>1: LOL里面的模型描边效果:<br><img src="unity学习笔记/65_1.png" alt="还没有图片哦"><br>2: 可以找到模型描边的Shader,推荐使用(Toony):<br>一组第三方的Shader, 帮我们解决了模型描边的问题 </p>
</blockquote>
<h2 id="代码里面切换Shader"><a href="#代码里面切换Shader" class="headerlink" title="代码里面切换Shader"></a>代码里面切换Shader</h2><blockquote>
<p>加载shader是会有开销的，如果这个shader没有使用，是会被释放的</p>
</blockquote>
<ul>
<li>关联要切换Shader的材质</li>
<li>代码加载对应的Shader:   Shader.Find(“Shader的名字”);</li>
<li>切换材质对应的Shader;  Matrix.shader = Shader</li>
</ul>
<blockquote>
<p>在运行的时候，去加载shader 耗CPU 预先把这个shader加载好就可以了，unity就有一个机制，把常用的shader设置告诉他，那么他会帮你把这个shader常驻内存。<br>常用的shader，提前加载好。</p>
</blockquote>
<ul>
<li>将最常用的Shader, 放到Unity的Always Include里 –&gt; 优化检查</li>
<li><code>Edit--&gt; ProjectSetting --&gt; Graphics   --&gt;   Always-included Shaders</code><blockquote>
<p>Specify a list of Shaders that will always be stored along with the project, even if nothing in your scenes actually uses them. It is important to add shaders used by streamed AssetBundles to this list to ensure they can be accessed. 让这些Shader很重要，在开始的时候加载，常驻内存;</p>
</blockquote>
</li>
</ul>
<h1 id="第六十六课（专题-三-常用数据结构与JSON处理）"><a href="#第六十六课（专题-三-常用数据结构与JSON处理）" class="headerlink" title="第六十六课（专题(三)常用数据结构与JSON处理）"></a>第六十六课（专题(三)常用数据结构与JSON处理）</h1><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><ul>
<li>类型[] 名字 = new  类型[数量]{“初始化的值”, “”, ‘’”}; 如果有初始值也可以省略大小;</li>
<li>优点:<ul>
<li>内存连续，速度快;</li>
</ul>
</li>
<li>缺点:<ul>
<li>大小固定;    </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string[] str = new string[]&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125; // string[3]</span><br><span class="line">int[] i = new int[100];</span><br></pre></td></tr></table></figure>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>灵活但是相对的性能会对应有所消耗</p>
</blockquote>
<ul>
<li>属于 System.Collections 命令空间</li>
<li>ArrayList l = new ArrayList();</li>
<li>操作:<ul>
<li>添加 Add(数据), 修改[index] = 内容</li>
<li>删除 RemoveAt(index)</li>
</ul>
</li>
<li>优点:<ul>
<li>不用固定大小;</li>
<li>可以存放任意类型;</li>
</ul>
</li>
<li>缺点<blockquote>
<p>把所有对象都当做Object来处理，读取的时候需要强制转换一下</p>
<ul>
<li>由于存放不同类型的数据，导致很多看不见的性能消耗, 多次转换等;</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List<t></t></h2><ul>
<li>属于 using System.Collections.Generic; 命令空间</li>
<li>List<t> l = new List<t>();</t></t></li>
<li>操作:<ul>
<li>添加 Add(数据),</li>
<li>修改[index] = 内容</li>
<li>删除 RemoveAt(index);</li>
</ul>
</li>
<li>优点:<ul>
<li>不用固定大小;</li>
<li>存储的类型是泛型模板，比较灵活, 每个对象实例只能存储一个类型;</li>
</ul>
</li>
</ul>
<h2 id="字典-Dictionary-lt-K-T-gt"><a href="#字典-Dictionary-lt-K-T-gt" class="headerlink" title="字典 Dictionary&lt;K, T&gt;"></a>字典 Dictionary&lt;K, T&gt;</h2><ul>
<li>属于 using System.Collections.Generic; 命令空间</li>
<li>Dictionary&lt;KT, VT&gt; l = new Dictionary&lt;KT, VT&gt;();  key –&gt; value</li>
<li>操作:<ul>
<li>添加 Add(数据)</li>
<li>修改[key] = 内容</li>
<li>删除 RemoveAt(index);</li>
</ul>
</li>
<li>优点:<ul>
<li>不用固定大小;</li>
<li>存储的类型是泛型模板，比较灵活, 每个dict只能存储一个类型;</li>
<li>key也是泛型 string, int …. </li>
</ul>
</li>
</ul>
<h2 id="json数据格式"><a href="#json数据格式" class="headerlink" title="json数据格式"></a>json数据格式</h2><ul>
<li>JSON (JavaScript Object Notation)<br>  随着JavaScript的流行与互联网应用，JavaScript里面最强大的数据类型Object，使用起来极其的方便，为了能更好的做数据交换，设计了JSON协议,能够将JavaScript里面的Object,变成可以阅读的文本数据及JSON数据格式。实现JavaScript里面的Object与JSON的转换，Object对象转换成JSON数据以后，方便传输与存储,JSON变为Object方便对象重建;</li>
<li>python语言, Lua语言等其它的脚本语言都有类是于JavaScript的Object数据结构，所以JSON数据能在其它的语言里面也非常方便的使用;</li>
<li>JSON采用完全独立于语言的文本格式(string)，易于阅读与编写以及解析与生成,在很多时候数据交换都采用JSON, 数据—&gt;JSON–&gt;传输,存储—&gt;解码JSON–&gt;数据</li>
<li>上面的过程又叫序列化与反序列化;</li>
</ul>
<h2 id="Json数据格式"><a href="#Json数据格式" class="headerlink" title="Json数据格式"></a>Json数据格式</h2><ul>
<li>JSON Object {};   里面为key: value;</li>
<li>value为数字, 11.0, 12, 0, <ul>
<li>value为bool true, false</li>
<li>value为数组 [ 值, bool, 数组, Object]</li>
<li>value 为Object { key: value}</li>
</ul>
</li>
<li>Unity 5.3.x以后自带的Json数据解析器</li>
<li>Unity 5.3以前可以使用第三方的C#库LitJSon;</li>
</ul>
<h2 id="Unity5-3-JSON序列化"><a href="#Unity5-3-JSON序列化" class="headerlink" title="Unity5.3 JSON序列化"></a>Unity5.3 JSON序列化</h2><ul>
<li>序列化与反序列化:  内存数据–&gt;文件存储介质;   文件存储介质—&gt;内存数据</li>
<li><p>Unity序列化:  </p>
<ul>
<li><p>把要序列化的对象声明称: </p>
<blockquote>
<p>只会序列化public的</p>
<ul>
<li>[System.Serializable], </li>
<li>using System; [Serializable]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[System.Serializable]</span><br><span class="line">class my_object&#123;</span><br><span class="line">    public int a = 10;</span><br><span class="line">    public int b = 20;</span><br><span class="line">    public string name = &quot;nihao&quot;;</span><br><span class="line">    // 不是public 又想序列化</span><br><span class="line">    [SerializeField] // 可序列化的字段</span><br><span class="line">    bool is_object = true;</span><br><span class="line">    public int[] int_array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JSON 序列化</span><br><span class="line">my_object obj = new my_object();</span><br><span class="line">obj.int_array = new int[]&#123;1,2,3&#125;;</span><br><span class="line"></span><br><span class="line">// 接收转换过来的json字符串</span><br><span class="line">string json_string = JsonUtility.ToJson(obj);</span><br><span class="line"></span><br><span class="line">// JSON反序列化</span><br><span class="line">my_object new_obj = new my_object();</span><br><span class="line">obj.int_array = new int[]&#123;1,2,3&#125;;</span><br><span class="line">// 把字符串json_string转换为Object并赋值到new_obj</span><br><span class="line">JsonUtility.FromJsonOverwrite(json_string, new_obj);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>JsonUtility.ToJson(object); // 将对象(object)转成json字符串;</p>
</li>
<li>将Json字符串的数据覆盖到对象 JsonUtility.FromJsonOverwrite(json_str, obj);</li>
<li>当Unity序列化你的脚本的时候，它将仅仅序列化公有域。如果作为附加你也想要Unity去序列化你的一个私有域，你可以添加SerializeField（序列化域）属性给这个域。</li>
<li>JSON数组:   </li>
<li>JSON对象:</li>
</ul>
</li>
</ul>
<h1 id="第六十七课（专题-四-Unity常用目录和代码加载资源）"><a href="#第六十七课（专题-四-Unity常用目录和代码加载资源）" class="headerlink" title="第六十七课（专题(四)Unity常用目录和代码加载资源）"></a>第六十七课（专题(四)Unity常用目录和代码加载资源）</h1><h2 id="编辑器扩展目录（Editor）"><a href="#编辑器扩展目录（Editor）" class="headerlink" title="编辑器扩展目录（Editor）"></a>编辑器扩展目录（Editor）</h2><ul>
<li>Editor文件夹 <ul>
<li>Editor文件夹可以在根目录下，也可以在子目录里，夹就可以;</li>
<li>Editor下面放的所有资源文件或者脚本文件都不会被打进发布包中，并且脚本也只能在编辑时使用;</li>
<li>一些工具类的脚本放在这里，或者是一些编辑时用的DLL, 类似技能编辑器，那么编辑器的代码放在这里;</li>
</ul>
</li>
<li>Editor Default Resources<ul>
<li>Editor Default Resources 注意中间是有空格的, 它必须放在Project视图的根目录下</li>
<li>Editor Default Resources: 把编辑器用到的一些资源放在这里，比如图片、文本文件、等等; 和Editor文件夹一样都不会被打到最终发布包里，仅仅用于开发时使用;<br>EditorGUIUtility.Load来读取该资源:<br>TextAsset text = EditorGUIUtility.Load(“test.txt”) as TextAsset;</li>
</ul>
</li>
</ul>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul>
<li>Plugins 文件夹:<ul>
<li>如果做手机游戏开发一般 andoird 或者 ios 要接一些sdk 可以把sdk依赖的库文件 放在这里 比如 .so .jar .a 文件</li>
<li>该目录下的文件会被打包到安装包里面;</li>
</ul>
</li>
<li>StreamingAssets 文件夹:<ul>
<li>这个文件夹下的资源会全都打包在.apk或者.ipa</li>
<li>它不会压缩原封不动的打包进去</li>
<li>并且它是一个只读的文件夹，就是程序运行时只能读，不能写的</li>
<li>Application.streamingAssetsPath 它会根据当前的平台选择对应的路径，只可读不可写</li>
</ul>
</li>
</ul>
<h2 id="Resources目录"><a href="#Resources目录" class="headerlink" title="Resources目录"></a>Resources目录</h2><ul>
<li>可以在根目录下，也可以在子目录里，只要名子叫Resources就可以。比如目录：/xxx/xxx/Resources</li>
<li>Resources文件夹下的资源不管你用还是不用都会被打包进.apk或者.ipa,使用代码加载的资源必须放在Resouces目录下</li>
<li>Resource.Load ：编辑时和运行时都可以通过Resource.Load来直接读取<blockquote>
<p>尽量不要使用，因为不知道这个资源是否会放在 assetBundle 如果放在这里面那么Resources目录就要移出这个文件，如果移出了，那么使用这个读取到Resources目录下的资源文件不存在就会报错，不利于后期维护，所有我们会自己封装一个资源加载类我们的资源是从Resource目录下读取，还是assetbundle下读取;</p>
</blockquote>
</li>
<li>AssetDatabase.LoadAssetAtPath()：它可以读取Assets目录下的任意文件夹下的资源，它只能在编辑时用。它的路径是”Assets/xx/xx.xxx” 必须是这种路径，并且要带文件的后缀名;<blockquote>
<p>如果打包了，就不能用了</p>
</blockquote>
</li>
</ul>
<h2 id="Unity资源管理"><a href="#Unity资源管理" class="headerlink" title="Unity资源管理"></a>Unity资源管理</h2><ul>
<li>不在代码里面动态加载的，或放到assetBundle里的资源，尽量不要放在Resources文件夹下;</li>
<li>Resouces文件夹使用和不使用的资源都会被打入包中，所以在打包的时候，要把通过assetbundle来加载的资源或不使用的资源，移出Resources目录，然后再打包;</li>
<li>必须要封装一个资源加载的类，来封装好从Resource目录下读取，还是assetbundle下读取;</li>
</ul>
<h1 id="第六十八课（专题-五-移动的汽船）"><a href="#第六十八课（专题-五-移动的汽船）" class="headerlink" title="第六十八课（专题(五)移动的汽船）"></a>第六十八课（专题(五)移动的汽船）</h1><h2 id="船的虚拟摇杆移动"><a href="#船的虚拟摇杆移动" class="headerlink" title="船的虚拟摇杆移动"></a>船的虚拟摇杆移动</h2><p><img src="unity学习笔记/68_3.png" alt="图片还没有哦"></p>
<h2 id="船在水中的摇摆"><a href="#船在水中的摇摆" class="headerlink" title="船在水中的摇摆"></a>船在水中的摇摆</h2><p><img src="unity学习笔记/68_1.png" alt="图片还没有哦"></p>
<blockquote>
<p>r &gt;= 4 &amp;&amp; r &lt;= 180;左区间  r &lt; (360 - 4) &amp;&amp; r &gt;= 180 右区间</p>
</blockquote>
<h2 id="摄像机跟随"><a href="#摄像机跟随" class="headerlink" title="摄像机跟随"></a>摄像机跟随</h2><p><img src="unity学习笔记/68_2.png" alt="图片还没有哦"></p>
<h1 id="第六十九课（unity-专题-六-Unity道具金币拾取）"><a href="#第六十九课（unity-专题-六-Unity道具金币拾取）" class="headerlink" title="第六十九课（unity_专题(六)Unity道具金币拾取）"></a>第六十九课（unity_专题(六)Unity道具金币拾取）</h1><blockquote>
<p>分层<br>配置好物体碰撞关系<br>必须有一个是刚体</p>
</blockquote>
<h1 id="第七十课（unity-专题-七-音乐音效管理）"><a href="#第七十课（unity-专题-七-音乐音效管理）" class="headerlink" title="第七十课（unity_专题(七)音乐音效管理）"></a>第七十课（unity_专题(七)音乐音效管理）</h1><h2 id="sound-manager"><a href="#sound-manager" class="headerlink" title="sound_manager"></a>sound_manager</h2><ul>
<li>全局唯一的sound_manager;</li>
<li>在场景里面创建一个物体(做为声音的根节点)，而且设置这个物体场景切换也不会删除;</li>
<li>编写接口播放背景音乐play_music;</li>
<li>编写接口播放背景音效play_effect; // 2D声音</li>
<li>音乐和音效内部实现都是一样的, 只不过要把url分组管理, 音效为一组，音乐为一组;</li>
<li>提供开关音效接口set_mute(),并将值写入本地;</li>
<li>提供开关背景音乐接口switch_music(),并将值写入本地;</li>
<li>添加一个play_effect接口在指定的坐标出访一个声音, 可以用于3D音效;</li>
<li>添加一个接口停止掉背景音乐stop_music(url);</li>
<li>添加一个接口删除掉播放的背景音乐clear_music(url), clear_effect(url);</li>
<li>声音文件来自Resouce还是assetBundle，可以通过资源管理来封装，目前从Resource里面加载;</li>
<li>加一个脚本，每隔0.5秒扫描一次已经播放完的声音组件,将它disable;</li>
</ul>
<h1 id="第七十一课（unity-专题-八-Unity漩涡特效切换）"><a href="#第七十一课（unity-专题-八-Unity漩涡特效切换）" class="headerlink" title="第七十一课（unity_专题(八)Unity漩涡特效切换）"></a>第七十一课（unity_专题(八)Unity漩涡特效切换）</h1><h2 id="Mesh-材质-Shader"><a href="#Mesh-材质-Shader" class="headerlink" title="Mesh 材质 Shader"></a>Mesh 材质 Shader</h2><ul>
<li>Mesh 是网格数据;</li>
<li>Shader渲染算法;</li>
<li>材质是给渲染算法的输入数据;</li>
<li>代码修改材质参数,能修改给渲染算法的数据从而获得不同的效果;</li>
</ul>
<blockquote>
<p>纹理会自动对齐到2^N方，如果想要原始大小，可以设置Advance –&gt; Non Power of 2 –&gt; None</p>
</blockquote>
<h2 id="旋涡特效"><a href="#旋涡特效" class="headerlink" title="旋涡特效"></a>旋涡特效</h2><ul>
<li>创建一个Shader: Unlit–&gt;Shader;</li>
<li>漩涡特效分析:<ul>
<li>纹理坐标的范围[0, 1];</li>
<li>扭曲顶点的纹理坐标, 扭曲的角度+波及的半径;</li>
<li>将扭曲的角度与半径数据绑定到材质;</li>
<li>设置扭曲的角速度, 随着时间的推移加大扭曲角度;</li>
<li>设置波及范围的速度，随着时间的推移不断的加大波及半径;</li>
<li>编写代码来控制参数，实现动态的旋转;</li>
</ul>
</li>
<li><p>扭曲代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 把这个两个参数绑定到编辑器</span><br><span class="line">// shader的输入数据绑定到我们的材质，进行代码动态修改</span><br><span class="line">Properties&#123;</span><br><span class="line">    radius(&quot;Radius&quot;,Float) = 0.0</span><br><span class="line">    angle(&quot;Angle&quot;, Float) = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外面也要定义</span><br><span class="line">float radius;// 扭曲的半径</span><br><span class="line">float angle;// 扭曲的弧度</span><br><span class="line"></span><br><span class="line">// 顶点uv变化</span><br><span class="line">// uv变化 获得顶点的纹理坐标[0，1]</span><br><span class="line">float2 uv = v.uv;</span><br><span class="line"></span><br><span class="line">// 扭曲的半径</span><br><span class="line">radius = 0.5f;  </span><br><span class="line">// 扭曲的弧度</span><br><span class="line">angle = 1.0f;</span><br><span class="line"></span><br><span class="line">// 需要把这个两个参数绑定到编辑器</span><br><span class="line">// radius,angle控制我们扭曲的效果 所有如果想要旋涡动画就得不停的修改这两个参数</span><br><span class="line"></span><br><span class="line">// 改变uv坐标的原点</span><br><span class="line">// 原来是 左下角为原点 0，0 右上角 1，1 改为了中心为原点  左下角-0.5,-0.5 右上角 0.5，0.5</span><br><span class="line">// 因为旋涡是从中间开始的</span><br><span class="line">uv -= float2(0.5, 0.5);</span><br><span class="line"></span><br><span class="line">// 计算当前坐标的长度，当前坐标到纹理中心的距离</span><br><span class="line">float dist = length(uv);</span><br><span class="line">// 计算出距离百分比</span><br><span class="line">float percent = (radius - dist) / radius;</span><br><span class="line">if ( percent &lt; 1.0 &amp;&amp; percent &gt;= 0.0)  &#123; // 在半径范围之内进行扭曲</span><br><span class="line">    // 扭曲算法</span><br><span class="line">	float theta = percent * percent * angle * 8.0;</span><br><span class="line">	float s = sin(theta);</span><br><span class="line">	float c = cos(theta);</span><br><span class="line">	uv = float2(dot(uv, float2(c, -s)), dot(uv, float2(s, c)));</span><br><span class="line">&#125;</span><br><span class="line">// 变换回我们的纹理坐标寻址的原点</span><br><span class="line">uv += float2(0.5, 0.5);</span><br><span class="line"></span><br><span class="line">o.uv = uv;</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋涡粗糙就扩展顶点就行了</p>
</li>
</ul>
<h1 id="第七十二课（unity-专题-九-Unity场景导出与导入）"><a href="#第七十二课（unity-专题-九-Unity场景导出与导入）" class="headerlink" title="第七十二课（unity_专题(九)Unity场景导出与导入）"></a>第七十二课（unity_专题(九)Unity场景导出与导入）</h1><h2 id="天空盒的位置"><a href="#天空盒的位置" class="headerlink" title="天空盒的位置"></a>天空盒的位置</h2><ul>
<li>可以挂载摄像机（场景编辑器看不见，但是游戏画面有天空盒）</li>
<li>可以配置全局（场景编辑器能看到天空盒）</li>
</ul>
<h2 id="场景导出案例"><a href="#场景导出案例" class="headerlink" title="场景导出案例"></a>场景导出案例</h2><ul>
<li>准备好Unity 4.7赛车游戏的赛车场景;</li>
<li>将属于场景的物体，导出成预制体;</li>
<li>将预制体导入到自己的场景;</li>
<li>检查导入后的正确性;<blockquote>
<p>模型网格如果出现missing(Mesh)说明就没有正确关联到模型网格，需要手动修改</p>
</blockquote>
</li>
<li>导入天空盒;</li>
<li>如果有雾的话配置好雾;</li>
<li>打开光源,烘培出静态光照;</li>
</ul>
<h1 id="第七十四课（unity-专题-十-Unity-FPS第一人称射击类游戏）"><a href="#第七十四课（unity-专题-十-Unity-FPS第一人称射击类游戏）" class="headerlink" title="第七十四课（unity_专题(十)Unity_FPS第一人称射击类游戏）"></a>第七十四课（unity_专题(十)Unity_FPS第一人称射击类游戏）</h1><h2 id="AudioSource-的两个方法-Play-和-PlayOneShot-有什么区别"><a href="#AudioSource-的两个方法-Play-和-PlayOneShot-有什么区别" class="headerlink" title="AudioSource 的两个方法 Play 和 PlayOneShot 有什么区别"></a>AudioSource 的两个方法 Play 和 PlayOneShot 有什么区别</h2><p>play 和 playOneShot 最大的区别是：</p>
<ul>
<li>play 每次只能播放一次，也就是说假如短时间内假如你有播放多次和多种音效的需求时。play 只会把音效打断，然后重新播放指定音效。</li>
<li>playOneShot 就是为了解决播放多种和多次音效的问题而生的（个人观点），这函数不管你目前有没有正在播放音效，它都会另起炉灶播放指定的音效，并且不会打断当前正在播放的音效（这是重点，谨记！）。还能设置它的音量，不会像 AudioSource 组件里的 Volume 属性那样对音量有限制。<blockquote>
<p>播放点击枪声的时候，play回造成枪声没播放完就重头开始，效果不佳，playOneShot可以解决这个问题</p>
</blockquote>
</li>
</ul>
<h1 id="第七十九课（unity-专题-十一-ARPG游戏摇杆控制角色行走）"><a href="#第七十九课（unity-专题-十一-ARPG游戏摇杆控制角色行走）" class="headerlink" title="第七十九课（unity_专题(十一)ARPG游戏摇杆控制角色行走）"></a>第七十九课（unity_专题(十一)ARPG游戏摇杆控制角色行走）</h1><h2 id="人物操作方式"><a href="#人物操作方式" class="headerlink" title="人物操作方式"></a>人物操作方式</h2><ul>
<li>在ARPG游戏中,主角人物在摇杆下控制行走;</li>
<li>主角人物遇到障碍物(碰撞器)将不会穿越过去;</li>
<li>摇杆控制主角人物8个方向的行走;</li>
<li>CharacterController 角色控制器组件: 让你在受制于碰撞的情况下很容易的进行运动，而不用处理刚体。角色控制器不受力的影响，仅当你调用Move函数时才运动。它执行运动，但是受制于碰撞。 </li>
<li>调用角色控制器的Move函数移动角色;</li>
<li>根据摇杆的方向旋转人物动画;</li>
</ul>
<h2 id="CharacterController组件-角色控制器"><a href="#CharacterController组件-角色控制器" class="headerlink" title="CharacterController组件(角色控制器)"></a>CharacterController组件(角色控制器)</h2><ul>
<li>属性面板属性:<ul>
<li>Slope Limit: 角色碰撞器只能爬比这个指定角度低的斜坡:(degree)</li>
<li>Step Offset: 上楼梯模式，小于Step Offset 值得台阶，可以直接上去;</li>
<li>Skin Width: 两个碰撞器可以互相渗透深入皮肤宽度， 建议设置成radius的10%;</li>
<li>Min Move Distance: 调用Move函数移动的最小移动量,如果移动距离比这个小,将不移动;</li>
<li>center: 相对与transform的位置角色叫胶囊体中心;</li>
<li>height: 胶囊体高度;</li>
<li>Radius: 胶囊体的半径;      </li>
</ul>
</li>
<li>碰撞检测:<blockquote>
<p>只会和使用了CharacterController组件的物体产生碰撞</p>
<ul>
<li>void OnControllerColliderHit(ControllerColliderHit hit) {<br>}</li>
</ul>
</blockquote>
</li>
<li>重要方法:<ul>
<li>Move(Vec3 offset): 移动的距离;</li>
</ul>
</li>
</ul>
<h2 id="弧度-顺时针角度是负的，逆时针角度是正的"><a href="#弧度-顺时针角度是负的，逆时针角度是正的" class="headerlink" title="弧度(顺时针角度是负的，逆时针角度是正的)"></a>弧度(顺时针角度是负的，逆时针角度是正的)</h2><p><img src="unity学习笔记/74_1.png" alt="还没有图片哦"></p>
<h1 id="unity-安卓打包"><a href="#unity-安卓打包" class="headerlink" title="unity_安卓打包"></a>unity_安卓打包</h1><h2 id="java安装好sdk之后新建两个环境变量"><a href="#java安装好sdk之后新建两个环境变量" class="headerlink" title="java安装好sdk之后新建两个环境变量"></a>java安装好sdk之后新建两个环境变量</h2><ul>
<li>JAVA_HOME </li>
<li><p>PATH</p>
<blockquote>
<p>目录都选择sdk的目录即可cmd命令窗口输入java或javac即可查看是否配置好如果为出现<code>内部或外部命令，也不是可运行的程序
或批处理文件</code>说明已经配置好了</p>
</blockquote>
</li>
<li><p>一般不直接打包apk</p>
<ul>
<li>配置好之后点击build即可</li>
</ul>
</li>
<li><p>一般导出一个安卓工程勾选下面的选项然后点击Export即可导出</p>
<ul>
<li>Google Android Project</li>
<li>Development Build</li>
</ul>
</li>
<li><p>Run In Background (如果鼠标移出unity点到其他应用，unity程序就会停止，勾选则就是表示可以在后台运行，打包的时候一般都是勾选这个的)</p>
</li>
<li><p>Android Studio打包安卓工程文件</p>
</li>
</ul>
<h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><blockquote>
<p>lua 解释器<br>luac lua字节码编译器 lua代码 –&gt; lua字节码<br>使用</p>
<ul>
<li><code>luac o &quot;编译出来的文件名&quot; &quot;需要编译的文件&quot;</code></li>
</ul>
</blockquote>
<h2 id="lua表中的"><a href="#lua表中的" class="headerlink" title="lua表中的"></a>lua表中的</h2><p>返回连续数字索引的长度()</p>
<blockquote>
<p><strong>lua数组索引是从1开始的</strong><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">a[<span class="number">11</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(#a); <span class="comment">-- 5  因为连续的数字索引只有5个</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>数组（连续数字索引）</p>
</blockquote>
<p>ipairs 遍历lua表中的数组部分(连续的数字索引)<br>pairs 遍历lua表中所有的数据</p>
<h2 id="table的sort比较函数"><a href="#table的sort比较函数" class="headerlink" title="table的sort比较函数"></a>table的sort比较函数</h2><blockquote>
<p>lua 排序中的比较函数必须要保证排序是稳定的<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    <span class="comment">--[[ 从大到小 大的返回true</span></span><br><span class="line"><span class="comment">        if a &gt; b then</span></span><br><span class="line"><span class="comment">            return true</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return false</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line">    <span class="comment">--[[ 从小到大 小的返回true</span></span><br><span class="line"><span class="comment">        if a &lt; b then</span></span><br><span class="line"><span class="comment">            return true</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return false</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line">    <span class="comment">--[[ 排序中的比较函数必须要保证排序是稳定的</span></span><br><span class="line"><span class="comment">        if math.random &lt; b then --这样是会报错的 不用这种做随机打乱一个数组数据</span></span><br><span class="line"><span class="comment">            return true</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return false</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="解开数组（unpack）"><a href="#解开数组（unpack）" class="headerlink" title="解开数组（unpack）"></a>解开数组（unpack）</h2><p>a,b,_,c,d,e,f = unpack(“数组”)</p>
<blockquote>
<p>把数组里面的值解开到a对应索引1，b为2，后面的同理，不用的用 _ 去接即可</p>
</blockquote>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="require装载lua脚本（不用加后缀）"><a href="#require装载lua脚本（不用加后缀）" class="headerlink" title="require装载lua脚本（不用加后缀）"></a>require装载lua脚本（不用加后缀）</h3><p>require(“lua_file_name”) 或 require “lua_file_name”</p>
<blockquote>
<p>可以用一个返回值来接收,如果装载的lua脚本有return那么这个返回值就是脚本里面return的数据</p>
</blockquote>
<blockquote>
<p>require只会装载执行一次,多次require也只会装载并执行一次lua脚本<br>第二次require的时候，会发现已经装载过了，直接返回第一次装载的返回值</p>
</blockquote>
<p>local 关键字的只能在挂载内部使用，如果想在外部使用</p>
<ul>
<li>第一种就是不适用local关键字</li>
<li>第二种就是使用return 返回一个函数名即可使用这个函数</li>
</ul>
<blockquote>
<p>上面的方法需要在使用模块脚本里面，都要使用require来装载，才可以调用得到装载脚本里面的方法，这样相对如果多个脚本使用就比较麻烦</p>
</blockquote>
<h3 id="全局模块module（全局包）"><a href="#全局模块module（全局包）" class="headerlink" title="全局模块module（全局包）"></a>全局模块module（全局包）</h3><p>在lua脚本开头写上这个前缀<code>module(&quot;模块名字&quot;, package,seeall)</code>，只要在一个脚本里面使用require装载这个脚本，其他lua脚本无须再装载，也是可以使用这个装载脚本里面的方法的</p>
<blockquote>
<p>不过上面再其他脚本使用前需要加上<code>模块名字.xxx</code></p>
</blockquote>
<h3 id="dofile装载脚本（需要加后缀）"><a href="#dofile装载脚本（需要加后缀）" class="headerlink" title="dofile装载脚本（需要加后缀）"></a>dofile装载脚本（需要加后缀）</h3><p>dofile会对读入的模块编译执行，每调用dofile一次，都会重新编译执行一次<br><a href="https://blog.csdn.net/lf_2016/article/details/78272558" rel="external nofollow noopener noreferrer" target="_blank">require 和 dofile 的区别</a>require只会执行一次，dofile调用几次执行几次</p>
<p><a href="https://www.cnblogs.com/luguoshuai/p/10474117.html" rel="external nofollow noopener noreferrer" target="_blank">lua的Module</a></p>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a.test</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"a.test"</span>,self)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a.test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b:test</span><span class="params">()</span></span> <span class="comment">-- 隐士传递self参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"b:test"</span>,self) <span class="comment">-- 可以顺利拿到self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b:test() <span class="comment">-- 调用的是表的实例self 就是这个表的实例 使用 ： 会隐士绑定self</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b.test2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"b:test"</span>,self) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b:test2() <span class="comment">-- 无法正常拿到self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.test(b) -- 显示传递 也是可以拿到的</span></span><br><span class="line">b.test() <span class="comment">-- 无法正常拿到self  即使是：定义的函数，调用函数的时候不使用 ：也是无法正常拿到self的</span></span><br></pre></td></tr></table></figure>
<h3 id="self机制需要正常运行，需要两个点"><a href="#self机制需要正常运行，需要两个点" class="headerlink" title="self机制需要正常运行，需要两个点"></a>self机制需要正常运行，需要两个点</h3><ul>
<li>定义的函数必须使用 ： 才会有隐式的传递self</li>
<li>调用的时候也需要使用：</li>
<li>显示传递</li>
</ul>
<h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> mtable = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = &#123;</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(a, mtable) <span class="comment">-- 设置元表 a的元表是mtable 设置mtable为a的元表</span></span><br><span class="line"><span class="built_in">getmetatable</span>(a) <span class="comment">-- 获得a的元表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.a) <span class="comment">-- 打印为100 自己表里面找不到就会去元表的__index表里面去找</span></span><br></pre></td></tr></table></figure>
<p>元表里面有一个非常重要的key : <strong>index<br><strong>特点</strong>：<br>当我门搜索一个表的key的使用，如果没有搜索得到，lua解释器就会去这个表里面的元表里面的</strong>index这个key锁对应的表里面来查找</p>
<h2 id="模拟面向对象的语法"><a href="#模拟面向对象的语法" class="headerlink" title="模拟面向对象的语法"></a>模拟面向对象的语法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> base = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:new</span><span class="params">(instant)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> instant <span class="keyword">then</span> <span class="comment">-- 类的实例 没有就创建一个</span></span><br><span class="line">        instant = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instant, &#123;<span class="built_in">__index</span> = self&#125;) <span class="comment">-- 把这个实例的元表设置成 base 这样 这个实例就相当于有了可以访问base的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instant</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = base:new() <span class="comment">-- 这个base表就是new的self(实例)</span></span><br><span class="line"><span class="comment">-- 在new函数里面把新创建的实例表的元表变成了self，这样如果在这个实例里面找不到相关的函数，就会去这个元表的__index表里面去找，相应的就找到了self（也就是base表）</span></span><br><span class="line">b:test() <span class="comment">-- 所有可以用b访问base里面的成员函数 这时候的self对象就是我们的实例b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加数据成员</span></span><br><span class="line"><span class="keyword">local</span> c = base:new(&#123;</span><br><span class="line">    name=<span class="string">"name"</span>,</span><br><span class="line">    age=<span class="number">33</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c.name) <span class="comment">-- 实在&#123;name="name",age=33,&#125;这个基础上扩展的元表所有不用加:也是可以的，访问数据成员不需要：</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结<br>面向对象的基本步骤</p>
<ul>
<li>定义一个表（类） – 相当于定义一个类 class</li>
<li>定义一个实例的表 – new_instant = class:new();</li>
<li>为这个实例的表添加一个元表，并且元表__index指向这个定义的表self（这个类）</li>
<li>利用self机制，表的实例调用函数的时候,隐式的帮我们传递了实例的表为self到函数里面<br>  表的实例(new_instant):表的函数(test)</li>
</ul>
</blockquote>
<h2 id="继承、重载"><a href="#继承、重载" class="headerlink" title="继承、重载"></a>继承、重载</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> base = &#123;&#125; <span class="comment">-- 基类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test2"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:test3</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"base:test3"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base:new</span><span class="params">(instant)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> instant <span class="keyword">then</span> <span class="comment">-- 类的实例 没有就创建一个</span></span><br><span class="line">        instant = &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instant, &#123;<span class="built_in">__index</span> = self&#125;) <span class="comment">-- 把这个实例的元表设置成 base 这样 这个实例就相当于有了可以访问base的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instant</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> man = base:new() <span class="comment">-- 把man实例的元表设置成父类(base)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man:test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"man:test"</span>,self);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重载base的test3函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man:test3</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"man:test3"</span>,self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 子类里面调用父类函数</span></span><br><span class="line">    base.test3(self) <span class="comment">-- 显示传递一次self即可</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个new调用的方法其实是base里面的方法因为man的元表__index已经设置成了base</span></span><br><span class="line"><span class="comment">-- 而new里面的self就不再是base的了，而是实例man的self</span></span><br><span class="line"><span class="keyword">local</span> p = man:new() <span class="comment">-- 子类的实例p</span></span><br><span class="line"><span class="comment">-- 下面的self 都是p的</span></span><br><span class="line">p:test() <span class="comment">-- p --&gt; man找到打印 man:test</span></span><br><span class="line">p:test2() <span class="comment">-- p --&gt; man --&gt; base 找到打印 base:test2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--p --&gt; man --&gt; base --&gt;一直找下去直到找到，没有找到那么就会报错</span></span><br><span class="line">p:test3() <span class="comment">-- p里面是没有的接下来去man去找，找到了就返回 所有打印的是 man:test3 这样我们就重载了基类的函数</span></span><br></pre></td></tr></table></figure>
<h1 id="Lua热更新"><a href="#Lua热更新" class="headerlink" title="Lua热更新"></a>Lua热更新</h1><h2 id="资源管理与lua框架开发基本原则"><a href="#资源管理与lua框架开发基本原则" class="headerlink" title="资源管理与lua框架开发基本原则"></a>资源管理与lua框架开发基本原则</h2><h3 id="全新资源管理模式"><a href="#全新资源管理模式" class="headerlink" title="全新资源管理模式"></a>全新资源管理模式</h3><ol>
<li>unity资源管理方式阶段（<strong>打完包之后，资源无法更新了</strong>）<ul>
<li>编辑器编辑资源，我们如果要用代码加载资源就使用Resources.Load来代码加载资源</li>
<li>用代码加载的资源放在resources目录</li>
<li>不用代码直接加载资源放在resources以外的文件夹下</li>
<li>打包的时候，resources的资源，全部会打入发布包</li>
<li>其他文件下的资源，根据场景依赖或者是resources下的资源依赖进行选择性打包，没有被使用的非resources下的资源就不会被打包进去</li>
</ul>
</li>
<li>虽然外面无法更新代码，我是否有办法更新我的资源呢，再我们不重新安装的情况下 Unity就有了我们的AssetBundle的更新模式<ul>
<li>安装包里面带了资源 + 下载AssetBundle包的资源</li>
<li>如果是AB包资源，那么就用ab包模式加载资源，否者就还是走resources模式</li>
</ul>
</li>
<li>随着游戏越来越复杂，包体积越来越大，2G~3G的美术资源 包体就非常的大，所有我们有了空包，空包里面什么资源都没有，启动的时候去加载ab包，其他时候什么都没有，这样安装包就比较小，很多游戏第一次安装完之后，就需要下载一个很大的资源包<ul>
<li>a 所有资源再也没有放resources里面</li>
<li>b 放resources里面反倒成了一个负担，打空包的时候，你不希望打资源，但是如果放在resources里面，他还是会全部打包进去</li>
<li>c 有一些小型游戏(50~60M，资源在包体，渠道出的带宽)，资源在服务器上是自己出带宽，为了节约带宽，希望把这个初始资源包带入安装包，那么还是走assetbundle机制，但是我们会选择把assetbundle放在StreamingAssets文件夹下</li>
<li>StreamingAssets里面的ab包可以被游戏加载进来，不走三方服务器，只要放在StreamingAssets文件夹下也能加载到游戏资源</li>
</ul>
</li>
<li>你只更新资源，不更新代码，总归不是个事，比如做个营销活动(世界杯),等活动结束，要恢复回来，就需要更新代码<ul>
<li>热更框架：脚本的模式，游戏里面内置一个脚本解释器，解释执行我们的脚本，我们开发就用这个脚本，脚本资源也会是一种”资源”，也会把代码打包在ab包里面，一般我们会代码单独的打包成ab包。有些可能就区分为(框架的ab包 + 业务逻辑的ab包) 根据自己的情况是否需要把所有脚本代码做成ab</li>
<li>热更方式：脚本模式，内置一个脚本解释器 + 运行起来（插入版本检测，来更新最新的代码）动态装载脚本代码，在解释执行<ol>
<li>lua:lua解释器 + lua脚本 —&gt;我们采用的<ul>
<li>主流使用C#开发，用lua打补丁<blockquote>
<p>lua打补丁：比如 C#代码set_name有bug，我们就使用lua给这个函数set_name(){lua 代码 不走原来C#的代码了} 进行打补丁，检测到有lua补丁，就不走原来的C#代码直接走lua补丁代码</p>
</blockquote>
</li>
<li>主流全部用纯lua开发，底层的C#的框架代码(采用lua打补丁)，所有的业务逻辑和C#没有关系了，直接使用Lua开发(一般使用这个)</li>
</ul>
</li>
<li>C#：C#解释器(C# light) + C#脚本</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="基本设计的原理原则"><a href="#基本设计的原理原则" class="headerlink" title="基本设计的原理原则"></a>基本设计的原理原则</h3><ol>
<li>完全取消resources资源加载方式，采用ab包进行加载资源（但是总不可能在日常开发的时候总是从ab包里面进行资源加载）<ul>
<li>Editor下的一个开发模式，我们编写一些接口，不真正的去加载ab包(调用加载ab包的接口是没有用的，但是我们会走这个流程)<ul>
<li>加载资源：编辑器模式下运行才有效的函数来装载资源<code>AssetDatabase.LoadAssetAtPath</code>加载ab包的时候什么都不干，所有就可以来正常的开发业务逻辑了</li>
<li>正式运行模式：从ab包里面进行读取装载资源，就走标准的模式(标准的流程)</li>
</ul>
</li>
</ul>
</li>
<li>我们要<strong>支持打空包</strong>，所以这个时候的资源，不能把依赖打包到我们的安卓包里面<ul>
<li>我们会从场景依赖打入资源，场景里面就不能放任何东西</li>
<li>resources的依赖，去掉了resources，就不会存在了，打空包就非常方便了</li>
</ul>
</li>
<li>我们会把资源打成单独的包出来，放单独的文件夹下，假设你要把第一个版本的资源打包进行，这时候我们就会编写脚本，直接将这个资源包复制到StreamingAssets文件夹下</li>
<li>热更新代码，热更资源，普通节点上不带任何代码</li>
<li>场景只放启动节点代码，启动代码 –&gt; 启动C#框架 –&gt; 加载lua脚本 –&gt; lua代码业务逻辑</li>
<li>对于我们的lua开发，完全支持C#的开发习惯也用组件开发，也有Update等</li>
</ol>
<h3 id="热更与资源管理模块的设计演示"><a href="#热更与资源管理模块的设计演示" class="headerlink" title="热更与资源管理模块的设计演示"></a>热更与资源管理模块的设计演示</h3><ul>
<li>在我们编辑器上我们会设置模式(这个模式存在Editor本地读写里面)<ul>
<li>Editor模式</li>
<li>开发模式</li>
</ul>
</li>
<li>我们打包发布的时候：ab(平台(android、ios) + 渠道(百度、360)) AssetBundles<blockquote>
<p>ab包是要区分平台和渠道的</p>
</blockquote>
</li>
<li><p>最终我们是要将代码作为资源打包到ab包里面的，我们使用AssetsPackage(资源 + 代码)文件夹来存放资源包 + 代码<br>  打ab包的时候全部打的是AssetsPackage下的资源，和开发就没什么关系了</p>
<blockquote>
<p>lua代码不是unity的ab包识别的类型.lua的资源 使用工具 把.lua –&gt;转换 .lya.bytes 类型放在AssetsPackage</p>
</blockquote>
</li>
<li><p>我们指定我们要打包ab包，打包的时候有一个包的数据库管理（根据一个配置文件来打包）</p>
</li>
<li>ab包会根据渠道输出到一个单独的路径</li>
<li>查看打包出来的结果</li>
<li>打包资源的时候会生成一个文本资源.map映射(哪个资源在哪个ab包，资源的路径，AssetsMap)</li>
<li>我们会开启一个模式：测试这个资源包</li>
</ul>
<h3 id="纯lua开发的注意事项与性能瓶颈"><a href="#纯lua开发的注意事项与性能瓶颈" class="headerlink" title="纯lua开发的注意事项与性能瓶颈"></a>纯lua开发的注意事项与性能瓶颈</h3><ul>
<li>做游戏开发的时候80%、90%性能开销、渲染都是(底层)C#写好的组件 + 物理引擎 –&gt; lua(20%~10%) –&gt; 性能是可接受的，lua –&gt; 接近C# lua开发怎么都是解释执行，所有性能要低一些</li>
<li>lua开发编写算法(负载的算法)的时候 –&gt; 尽可能使用C#来做算法，不要使用lua来写（核心算法，不会有很大的改变）<blockquote>
<p>不用lua写算法，使用C#</p>
</blockquote>
</li>
<li>lua调用C#、C#调用lua 经过漫长的数据交互和函数调用的过程 –&gt;性能开销比较大，尽量减少这个lua和C#的交互<blockquote>
<p>减少lua和C#的交互</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>做一个纯lua框架 + 完整的ab包资源 + 其他功能(自己扩展)</p>
</blockquote>
<h2 id="项目创建与Lua启动流程"><a href="#项目创建与Lua启动流程" class="headerlink" title="项目创建与Lua启动流程"></a>项目创建与Lua启动流程</h2><ul>
<li>创建项目，规范项目目录结构<ul>
<li>创建一个AssetsPackage文件夹，用来放资源，所有的资源和资源ab打包我们都会放在这个文件夹下</li>
<li>创建一个Scripts文件夹，用来放C#的代码</li>
<li>创建一个LuaScripts文件夹，开发的时候我们要存放Lua脚本代码</li>
<li>Scenes 用来存放场景</li>
<li>StreamingAssets 用来存放我们的本地的ab包资源，可以加载ab包，同时可以打包到安装包里面去</li>
<li>Editor 编辑器扩展代码</li>
<li>做一个启动脚本，用空物体来挂一个脚本</li>
</ul>
</li>
<li>搭建xLua开发环境<ul>
<li><a href="https://github.com/Tencent/xLua" rel="external nofollow noopener noreferrer" target="_blank">xLua github</a>下载源码</li>
<li>xLua的Assets文件夹里面的文件copy到untiy项目的Assets文件夹下即可</li>
</ul>
</li>
<li>编写代码启动Lua虚拟机<ul>
<li>LuaEnv 是lua解释器的上下文的运行环境，lua解释器的运行环境的数据，都会依赖luaenv</li>
<li>重新添加一个lua代码装载器，到lua解释器，那么它装载lua文件的时候，就会使用这个装载器<blockquote>
<p>因为开发的时候我们载入的是luascripts的lua代码，在发布的时候我们装载的是被打入assetbundle包的lua代码</p>
</blockquote>
</li>
<li>CustomLoader 一个是编辑器模式 一个是assetbundle模式<blockquote>
<p>装载lua文件的时候就会调用这个函数</p>
</blockquote>
</li>
</ul>
</li>
<li>重载Lua装载器<ul>
<li>luaEnv.AddLoader</li>
<li><blockquote>
<p>参数说明：luaEnv.AddLoader(loader)<br>   loader 类型为 delegate byte[] CustomLoader(ref string filepath)<br>   当一个文件被 require 时，这个 loader 会被回调,其参数就是require的参数<br>   如果该 loader 找到文件，可以将其读进内存，返回一个 byte 数组。<br>   如果需要支持调试的话，而filepath要设置成 IDE 能找到的路径（相对或者绝对都可以）</p>
</blockquote>
</li>
</ul>
</li>
<li>编写Lua启动脚本<ul>
<li>luaEnv.DoString(scriptContent)</li>
<li><blockquote>
<p>参数说明：scriptContent 代码文本内容</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="lua的组件开发模式"><a href="#lua的组件开发模式" class="headerlink" title="lua的组件开发模式"></a>lua的组件开发模式</h2><h3 id="lua启动脚本开发入口"><a href="#lua启动脚本开发入口" class="headerlink" title="lua启动脚本开发入口"></a>lua启动脚本开发入口</h3><ul>
<li>Update、FixedUpdate、LateUpdate<blockquote>
<ul>
<li>ApplicationQuit</li>
<li>Update</li>
<li>FixeUpdate</li>
<li>LateUpdate</li>
</ul>
</blockquote>
</li>
</ul>
<p>main.lua加上这些入口、xLuaMgr 调用这些接口，实现lua拥有Update、FixedUpdate、LateUpdate函数功能</p>
<h3 id="lua组件化开发模式设计理念"><a href="#lua组件化开发模式设计理念" class="headerlink" title="lua组件化开发模式设计理念"></a>lua组件化开发模式设计理念</h3><blockquote>
<p>大家都习惯了组件开发<br>lua调用unity的接口，非常方便</p>
</blockquote>
<ul>
<li>组件化<ul>
<li>组件化 + 真正的在unity添加组件，然后通过组件再转载lua脚本</li>
<li>组件化 + 不通过unity + 纯lua组件开发的模式<ul>
<li>我们自己定义lua组件，自己”添加”lua组件到gameObject()</li>
<li>我们用lua脚本来驱动update、fixedupdate、lateupdate 通过这种方式然后实现组件实例</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lua组件类基类的设计"><a href="#lua组件类基类的设计" class="headerlink" title="lua组件类基类的设计"></a>lua组件类基类的设计</h3><p>所有的lua组件实例都继承LuaBehaviour<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回一个基类为base的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LuaExtend</span><span class="params">(base)</span></span></span><br><span class="line">    <span class="keyword">return</span> base:new();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> LuaBehaviour = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LuaBehaviour:new</span><span class="params">(instant)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> instant <span class="keyword">then</span></span><br><span class="line">        instant = &#123;&#125; <span class="comment">-- 类的实例</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instant, &#123;<span class="built_in">__index</span> = self&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instant;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 两个成员函数 尽量和unity 习惯保持一致</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LuaBehaviour:init</span><span class="params">(obj)</span></span></span><br><span class="line">    self.transform = obj.transform</span><br><span class="line">    self.gameObject = obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> LuaBehaviour;</span><br></pre></td></tr></table></figure></p>
<p>新建一个LuaComponentMgr的模块来管理lua的组件实例</p>
<h2 id="lua调用unity"><a href="#lua调用unity" class="headerlink" title="lua调用unity"></a>lua调用unity</h2><blockquote>
<p>unity在C#中的名字空间 UnityEngine<br>unity在Lua中的名字空间 CS.UnityEgine</p>
</blockquote>
<h3 id="lua调用unity-1"><a href="#lua调用unity-1" class="headerlink" title="lua调用unity"></a>lua调用unity</h3><ul>
<li>我要获取unity对象里面的数据成员：obj.transform, obj.gameObject, obj.xxxx</li>
<li>调用unity对象里面的成员函数 obj:xxx()</li>
</ul>
<h3 id="AddComponent-unity组件"><a href="#AddComponent-unity组件" class="headerlink" title="AddComponent(unity组件)"></a>AddComponent(unity组件)</h3><blockquote>
<p>self.gameObject:AddComponent(“填组件名字就行了”) 已废弃<br>self.gameObject:GetComponent(“填要获取组件名字就行了”)</p>
</blockquote>
<h3 id="unity导出接口给lua使用"><a href="#unity导出接口给lua使用" class="headerlink" title="unity导出接口给lua使用"></a>unity导出接口给lua使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using XLua;</span><br><span class="line"></span><br><span class="line">// 表示这个文件将要被导出给lua使用</span><br><span class="line">[LuaCallCSharp]</span><br><span class="line">public class ResMgr : UnitySingleton&lt;ResMgr&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public override void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        base.Awake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AssetsBundles打包管理的使用"><a href="#AssetsBundles打包管理的使用" class="headerlink" title="AssetsBundles打包管理的使用"></a>AssetsBundles打包管理的使用</h2><p><a href="unity学习笔记/lua_10_1.png">图片还没有哦</a></p>
<h2 id="GC与AssetsBundles步骤详解"><a href="#GC与AssetsBundles步骤详解" class="headerlink" title="GC与AssetsBundles步骤详解"></a>GC与AssetsBundles步骤详解</h2><h3 id="Editor-–-gt-XLuaMenu-文件下做的事情"><a href="#Editor-–-gt-XLuaMenu-文件下做的事情" class="headerlink" title="Editor –&gt; XLuaMenu 文件下做的事情"></a>Editor –&gt; XLuaMenu 文件下做的事情</h3><blockquote>
<p>复制lua文件<br>修改后缀名</p>
</blockquote>
<ul>
<li>AssetsPackage所有的资源部 lua代码也会是一个资源 .lua文件 ab包(需要把.lua转为 .lua.bytes 作为二进制打进去)</li>
<li>LuaScripts开发模式下的lua代码 拷贝到AssetsPackage 并且将所有.lua转为 .lua.bytes</li>
</ul>
<h3 id="不同开关模式的详解（Switch-Model）"><a href="#不同开关模式的详解（Switch-Model）" class="headerlink" title="不同开关模式的详解（Switch Model）"></a>不同开关模式的详解（Switch Model）</h3><blockquote>
<p>Editor –&gt; AssetBundle –&gt; AssetbundleMenultems.cs 所有的资源管理菜单都在这里</p>
</blockquote>
<ul>
<li>Editor模式 直接重LuaScripts里面加载代码</li>
<li>切换到模拟模式，我们是从assetbundle里面进行加载资源</li>
<li>发布模式从assetbundle里面进行加载资源</li>
</ul>
<h3 id="渠道和版本管理"><a href="#渠道和版本管理" class="headerlink" title="渠道和版本管理"></a>渠道和版本管理</h3><ul>
<li>GameChannel.cs 渠道配置文件 项目有哪一些渠道就可以写哪一些渠道</li>
<li>Editor –&gt; PackageBuild –&gt; PackageTool.cs 文件 负责包版本的管理 Tool菜单功能</li>
<li>EditorUserBuildSettings 编译目标的一个配置打包时候 unity的配置 activeBuildTarget 当前选择的一个build目标</li>
<li>获取当前渠道 PackageUtils –&gt; GetCurSelectedChannel</li>
</ul>
<h2 id="Assetbundle打包配置与源码详解"><a href="#Assetbundle打包配置与源码详解" class="headerlink" title="Assetbundle打包配置与源码详解"></a>Assetbundle打包配置与源码详解</h2><ul>
<li><p>AssetBundle打包配置操作</p>
<ul>
<li><p>Editor/AssetBundle/Database/AssetsPackage –&gt; Lua.asset(对象数据直接存到文件里面)</p>
<blockquote>
<p>.asset文件指定了我们的哪个文件打包哪些文件到我们的assetbundle里面、打包的方式有哪些<br>如果你的文件夹没有被指定打包生成assetbundle，那么在这个文件夹下就会有一个按钮 –&gt; create AssetBundleDipatch</p>
</blockquote>
</li>
<li><p>打包类型：</p>
<ul>
<li>root 就是以这个文件夹为根目录，来打包assetbundle; lua.assetbundle 路径/名字.assetbundle</li>
<li>Children 文件夹下的每个孩子</li>
<li>Children Folders Only 只会打包文件夹</li>
<li>Children files Only 只会打包文件</li>
</ul>
</li>
</ul>
</li>
<li>Unity ScriptableObject详解生成.asset<br>ScriptableObject C#对象如果你继承自 ScriptableObject 那么你就会很方便的写入数据到.asset文件<br>AssetBundleDispatcherConfig.cs –&gt; 打包的时候的一个配置生成.asset</li>
<li>按钮扩展在<code>AssetBundleDispatcherInspector.cs</code>里面</li>
</ul>
<p>打包的时候，可以做资源检查，Run All Checks 我们就是根据.asset文件来检查我们的资源包下面的文件夹是否都有<br>(1) 运行Lua脚本拷贝，将我们lua脚本拷贝到我们的AssetsPackages文件夹下<br>(2) 清理掉不用的assetbundle的名字 重新创建assetbundle的名字</p>
<h2 id="AssetBundle打包流程分析"><a href="#AssetBundle打包流程分析" class="headerlink" title="AssetBundle打包流程分析"></a>AssetBundle打包流程分析</h2><h2 id="AssetBundle资源加载"><a href="#AssetBundle资源加载" class="headerlink" title="AssetBundle资源加载"></a>AssetBundle资源加载</h2><ul>
<li>AssetBundleManager是一个单例，所以要在开始节点上添加这个节点</li>
</ul>
<h2 id="lua热更dome"><a href="#lua热更dome" class="headerlink" title="lua热更dome"></a>lua热更dome</h2><h3 id="热更流程"><a href="#热更流程" class="headerlink" title="热更流程"></a>热更流程</h3><ol>
<li>会从私有数据目录下，来读取我们的版本信息(如果没有读到就会去StreamingAssets文件夹去读取)<blockquote>
<p>优先从我们的热更的下载目录下读，如果没有再从StreamingAssets目录下读取  </p>
</blockquote>
</li>
<li>提前下载好最新的资源到私有可写目录，那么我们用的加载就是最新的assetbundle</li>
<li>从本地读取版本信息，就会得到一个版本号</li>
<li>从服务器读取一个版本信息</li>
<li>把本地的版本与服务器的版本进行比对，比对完成以后如果要更新，我们就获取这个更新列表</li>
<li>更新列表：当前的哪些资源变动了，我们可以通过hash值来比较，如果不一样，就放入下载路径，将资源下载下来，下载好了以后就进入游戏，我们游戏里面，从本地加载的ab包是最新的，这样就热更完成了。</li>
</ol>
<h4 id="搭建一个简单的webserver"><a href="#搭建一个简单的webserver" class="headerlink" title="搭建一个简单的webserver"></a>搭建一个简单的webserver</h4><ul>
<li>安装好node.js</li>
<li>进入命令窗口node-v查看node版本<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建服务器目录--&gt;在目录打开命令窗口安装 npm install express 安装 express</span></span><br><span class="line"><span class="comment">// www_root 放置资源的文件夹</span></span><br><span class="line"><span class="comment">// 创建js文件编写代码进行部署服务器</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 把静态文件路径 设置成服务器路径 http://127.0.0.1:6868/Resources —— www_root/Resources</span></span><br><span class="line">app.use(express.static(path.join(process.cwd(), <span class="string">"www_root"</span>)));</span><br><span class="line"><span class="comment">// 启用监听6868端口</span></span><br><span class="line">app.listen(<span class="number">6868</span>); <span class="comment">// http://127.0.0.1:6868/Resources/lua.assetbundle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在命令窗口执行js脚本</span></span><br><span class="line"><span class="comment">// 使用 http://127.0.0.1:6868/Resources/lua.assetbundle 访问看是否能找到要下载的文件 如果找到了 说明部署成功</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NGUI"><a href="#NGUI" class="headerlink" title="NGUI"></a>NGUI</h2><p>一般NGUI界面开发流程<br>1）美术设计界面，提供切图，效果图给到程序<br>2）用NGUI搭建静态界面<br>3）将搭建好的静态界面拖到Project视图上—–形成一个预制体prefeb<br>4）通过代码调用 来初始化和显示预先配置好的界面，实现界面的切换</p>
<h2 id="NGUI-字体"><a href="#NGUI-字体" class="headerlink" title="NGUI - 字体"></a>NGUI - 字体</h2><ul>
<li>ShrinkContent<ul>
<li>总是显示所有文字，根据当前的width和height进行缩放</li>
</ul>
</li>
<li>ClampContent<ul>
<li>一看到Clamp就想起Clamp函数，也就是不管文本多少个字，根据当前的width和height来显示，超出部分 不显示</li>
</ul>
</li>
<li>ResizeFreely<ul>
<li>会对当前的文字长度和行数来调整，UILabel的width和height，基本上是只在一行显示，超出的部分不显示</li>
</ul>
</li>
<li>ResizeHeight<ul>
<li>保持宽度不变，必要时增加高度。</li>
</ul>
</li>
</ul>
<ul>
<li><p>Spacing</p>
<ul>
<li><p>X：设置字与字之间到间隔，可以为负数，设置得当可以反序</p>
</li>
<li><p>Y： 设置行与行之间的间隔。</p>
</li>
</ul>
</li>
<li><p>Gradient ：</p>
<ul>
<li>设置 渐变字</li>
</ul>
</li>
<li><p>Max Lines：</p>
<ul>
<li>用来控制最多要多少行。用0表示不限制。如果设置成n的话，那么超过n的行的文字将不会显示！</li>
</ul>
</li>
<li><p>可以使用BBCode标记</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[b]Bold[/b]                      粗体</span><br><span class="line">[i]italic[/i]                  斜体</span><br><span class="line">[u]underline[/u]               下划线</span><br><span class="line">[s]strikethrough[/s]         删除线</span><br><span class="line">AA[sub]sub[/sub]               下标</span><br><span class="line">BB[sup]sup[/sup]               上标</span><br><span class="line">[00ff00]设置颜色[-]           设置显示颜色</span><br><span class="line"></span><br><span class="line">[url=http://www.cnblogs.com/mrzivchu/][u]博客[/u][/url] 链接</span><br><span class="line"></span><br><span class="line">例如设置颜色：</span><br><span class="line">UILabel的Text内容为：[99ff00]n[-]gui: tools</span><br></pre></td></tr></table></figure>
<ul>
<li>第三方的字体制作工具<ul>
<li><a href="http://www.angelcode.com/products/bmfont/" rel="external nofollow noopener noreferrer" target="_blank">BMFont</a></li>
<li><a href="http://childhood.logdown.com/posts/190580/-details-using-shoebox-produce-bitmap-fonts" rel="external nofollow noopener noreferrer" target="_blank">shoebox</a></li>
</ul>
</li>
</ul>
<h2 id="NGUI-精灵-图集"><a href="#NGUI-精灵-图集" class="headerlink" title="NGUI - 精灵/图集"></a>NGUI - 精灵/图集</h2><ul>
<li><p>IPanel</p>
<ul>
<li>用来收集和管理它下面所有widget的组件。通过widget的geometry创建实际的draw call。</li>
<li><p>没有panel所有东西都不能够被渲染出来。如果你对Unity熟悉，你可以把UIPanel当做Renderer。</p>
</li>
<li><p>所有panel都有一个Depth值，会影响所有它包含的widget。如果你的UI有很多窗口，那么最好每个窗口有一个panel。</p>
</li>
<li><p>Panel上的depth权重会远远高于每一个widget的depth权重，所以保证panel不要使用同样的depth。如果使用同样的depth在panel上，那么draw call会被自动拆分来保证渲染顺序，所以会增加更多的draw call。</p>
</li>
<li>Alpha属性影响所有在panel下面的widget。所以可以用它来淡出整个窗口。</li>
<li>如果你的UI需要被灯光影响，需要勾选上Normals。</li>
<li>如果创建了一个有很多geometry的scrollable panel，你需要勾选Cull选项来减少三角形的数目。这样也可能降低性能，因为widget的可视性需要每次update都检验一次。</li>
<li><p>勾选Static选项来告诉NGUI这个panel下面的widget不会被移动，这样可以提高性能。NGUI会忽略所有的position/rotation/scale改变。所以在运行时移动widget不会有效——所以小心使用。</p>
</li>
<li><p>如果要调试由panel创建的draw calls，Show All选项可能帮助到你。你会看到由panel创建的所有draw call，以渲染顺序排序。每个draw call会包括它使用到material的详细信息，那个widget用的这个material，甚至可以让你关闭某些draw call来让你查询某些问题。</p>
</li>
<li><p>Panel会根据dimensions自动Clip所有它的子节点。使用这个功能需要选择Clipping下拉列表中的任意选项，之后调整Scene View中紫色矩形的尺寸，就像调整widget的尺寸一样。通过这样做你可以把一个panel放到Scroll View中，让他轻松的拖拽。</p>
</li>
<li><p>注意clipping的panel不能嵌套。每个panel只能clip自己管理的widget，如果一个panel在另外一个panel里面，只有一个会影响到里面的widget。这个限制以后会去掉。</p>
</li>
<li><p>默认NGUI中panel的Render Queues从3000开始往上增加。你可以通过Render Q来修改。如果你想在两个panel中间增加粒子，只要修改两个panel的render queue一个高于粒子，一个低于粒子即可。如果想要让所有的draw call使用和NGUI 2.x版本的渲染方式一样，使用z轴而不是depth。</p>
</li>
<li>那么给panel的Render Q指定为Explicit。（NGUI 2.x用的是3000）。</li>
<li>如果你找和Anchors相关的文档，可以看基类——UIRect。</li>
</ul>
</li>
<li><p>小贴士</p>
<ul>
<li>一个动力学Rigidbody会自动增加到你的panel上，因为对于Unity来说这样会提升性能。移动静态的collider会有很多消耗性能的操作，但是移动rigidbody就不会。</li>
</ul>
</li>
<li><p>UIPanel 和 uiwidget 工具</p>
<ul>
<li>UIPanel会产生drawcall,而widget不会，widget依赖于父节点来产生drawcall</li>
<li>panel有裁切区域，widget没有</li>
<li>当panel有裁切区域，Anchors对齐功能才可用，widget不用</li>
<li>widget下的depth没用，会按它的父panel的depth算，panel下的depth就是自己的</li>
<li><a href="http://tasharen.com/ngui/docs/class_u_i_panel.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></li>
</ul>
</li>
</ul>
<h2 id="NGUI-锚点-帧动画-Tween动画-Checkbox复选框-Button事件回调-Slider滑动条"><a href="#NGUI-锚点-帧动画-Tween动画-Checkbox复选框-Button事件回调-Slider滑动条" class="headerlink" title="NGUI_锚点_帧动画_Tween动画_Checkbox复选框_Button事件回调_Slider滑动条"></a>NGUI_锚点_帧动画_Tween动画_Checkbox复选框_Button事件回调_Slider滑动条</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 添加按钮事件</span><br><span class="line">this.GetComponent&lt;UIButton&gt;().onClick.Add(new EventDelegate(this.OnClickButton2));</span><br><span class="line"></span><br><span class="line">// 获得按钮物体，添加事件</span><br><span class="line">UIEventListener.Get(this.gameObject).onClick = OnClickButton3;</span><br><span class="line"></span><br><span class="line">// 添加按钮事件</span><br><span class="line">EventDelegate.Add(GetComponent&lt;UIButton&gt;().onClick, AddOnClick5);</span><br></pre></td></tr></table></figure>
<h2 id="NGUI-打字机效果Tab商城背包之Scrollview1（基于panel）"><a href="#NGUI-打字机效果Tab商城背包之Scrollview1（基于panel）" class="headerlink" title="NGUI_打字机效果Tab商城背包之Scrollview1（基于panel）"></a>NGUI_打字机效果<em>Tab商城</em>背包之Scrollview1（基于panel）</h2><ul>
<li>打字机效果<blockquote>
<p>游戏中的新手引导或人物的对话功能中</p>
<ul>
<li>UILabel</li>
<li>TypewriterEffect</li>
</ul>
</blockquote>
</li>
<li>Tab功能<blockquote>
<p>实现商城功能必备</p>
<ul>
<li>Toggle</li>
<li>ToggledObjects + Box Collider</li>
</ul>
</blockquote>
</li>
<li>ScrollView滚动视图，基于UIPanel实现<blockquote>
<p>实现商城功能必备</p>
<ul>
<li>Drag Scroll View</li>
<li>Center On Click</li>
</ul>
</blockquote>
</li>
</ul>

      
    </div>
    
    
    
    
    
    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/a & (a - 1)的含义.html" rel="next" title="a & (a - 1)的含义">
                <i class="fa fa-chevron-left"></i> a & (a - 1)的含义
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/逻辑英语.html" rel="prev" title="逻辑英语">
                逻辑英语 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>

    <div> 
          
            

          
    </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://image.tjl-myblog.cn:4455/images/wechatpay.jpg" alt="游戏人生 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://image.tjl-myblog.cn:4455/images/alipay.jpg" alt="游戏人生 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    
    <div>
      
        <div>

    <div style="text-align:center;color: #ccc;font-size:22px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>

</div>
      
    </div>
    
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=RA-5c258bb101609862" async="async"></script>
</div>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MTg1Ny8xODQwMw"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://image.tjl-myblog.cn:4455/images/avatar.jpeg" alt="游戏人生">
            
              <p class="site-author-name" itemprop="name" style="text-align: center;">游戏人生</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/tangjialang" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1522848509t@gmail.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/1522848509t" target="_blank" title="Google" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/yourname" target="_blank" title="YouTube" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yourname" target="_blank" title="Twitter" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/weixin" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-superpowers"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/89024bda3356" target="_blank" title="简书" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-book"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/" target="_blank" title="微博" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/" target="_blank" title="知乎" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-zhihu"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank" rel="external nofollow noopener noreferrer">Web前端导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chuangzaoshi.com/code" title="创造狮导航" target="_blank" rel="external nofollow noopener noreferrer">创造狮导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank" rel="external nofollow noopener noreferrer">前端书籍资料</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://e.xitu.io/" title="掘金酱" target="_blank" rel="external nofollow noopener noreferrer">掘金酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="V2EX" target="_blank" rel="external nofollow noopener noreferrer">V2EX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="印记中文" target="_blank" rel="external nofollow noopener noreferrer">印记中文</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#unity-第一课（初识unity）"><span class="nav-number">1.</span> <span class="nav-text">unity 第一课（初识unity）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开源框架"><span class="nav-number">1.1.</span> <span class="nav-text">开源框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于mono的两大项目："><span class="nav-number">1.2.</span> <span class="nav-text">基于mono的两大项目：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unity-第二课（unity场景树渲染体系物理体系）"><span class="nav-number">2.</span> <span class="nav-text">unity 第二课（unity场景树渲染体系物理体系）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unity组件开发的优点"><span class="nav-number">2.1.</span> <span class="nav-text">unity组件开发的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#场景树"><span class="nav-number">2.2.</span> <span class="nav-text">场景树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图像世界"><span class="nav-number">2.3.</span> <span class="nav-text">图像世界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理世界"><span class="nav-number">2.4.</span> <span class="nav-text">物理世界</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unity-第三课-Unity-C-的基本结构-类-成员-类的函数"><span class="nav-number">3.</span> <span class="nav-text">unity 第三课 (Unity C#的基本结构_类_成员_类的函数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组件代码入口"><span class="nav-number">3.1.</span> <span class="nav-text">组件代码入口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unity第四课-Unity-C-表达式-条件-循环-函数传参-out关键字"><span class="nav-number">4.</span> <span class="nav-text">unity第四课 (Unity C#表达式_条件_循环_函数传参_out关键字)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#out和ref"><span class="nav-number">4.1.</span> <span class="nav-text">out和ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unity第五课-Unity-C-构造函数调用基类继承-多态-重载"><span class="nav-number">5.</span> <span class="nav-text">unity第五课 (Unity_C#构造函数调用基类继承_多态_重载)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数"><span class="nav-number">5.1.</span> <span class="nav-text">虚函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六课（Unity-C-数组-string-static-const-泛型编程-名字空间）"><span class="nav-number">6.</span> <span class="nav-text">第六课（Unity_C#数组_string_static_const_泛型编程_名字空间）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态变量（static）、const、readonly"><span class="nav-number">6.1.</span> <span class="nav-text">静态变量（static）、const、readonly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型编程（和C-的模板很像）"><span class="nav-number">6.2.</span> <span class="nav-text">泛型编程（和C++的模板很像）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间（）"><span class="nav-number">6.3.</span> <span class="nav-text">命名空间（）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七课-（unity-transform组件一）"><span class="nav-number">7.</span> <span class="nav-text">第七课 （unity_transform组件一）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相对坐标-绝对坐标"><span class="nav-number">7.1.</span> <span class="nav-text">相对坐标/绝对坐标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八课-（unity-transform组件二）"><span class="nav-number">8.</span> <span class="nav-text">第八课 （unity_transform组件二）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九课-（unity-transform组件三）"><span class="nav-number">9.</span> <span class="nav-text">第九课 （unity_transform组件三）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十课（C-的结构体、属性、ref）"><span class="nav-number">10.</span> <span class="nav-text">第十课（C#的结构体、属性、ref）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一课（unity-几何体-材质-FBX-package导入导出）"><span class="nav-number">11.</span> <span class="nav-text">第十一课（unity_几何体_材质_FBX_package导入导出）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unity2017-3-0导入模型，模型无法修改材质问题"><span class="nav-number">11.1.</span> <span class="nav-text">unity2017.3.0导入模型，模型无法修改材质问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二课（unity-Camera-摄像机详解）"><span class="nav-number">12.</span> <span class="nav-text">第十二课（unity_Camera 摄像机详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制流水线"><span class="nav-number">12.1.</span> <span class="nav-text">绘制流水线</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#遮挡剔除-Occlusion-Culling-默认开启"><span class="nav-number">13.</span> <span class="nav-text">遮挡剔除 (Occlusion Culling) 默认开启</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三课（unity-初识光源一）"><span class="nav-number">14.</span> <span class="nav-text">第十三课（unity_初识光源一）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#光属性"><span class="nav-number">14.1.</span> <span class="nav-text">光属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#光源模式"><span class="nav-number">14.2.</span> <span class="nav-text">光源模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十四课（unity-UGUI-Canvas详解）"><span class="nav-number">15.</span> <span class="nav-text">第十四课（unity_UGUI_Canvas详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2D元素充满屏幕-3D摄像机做2D"><span class="nav-number">15.1.</span> <span class="nav-text">2D元素充满屏幕(3D摄像机做2D)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#image组件"><span class="nav-number">15.2.</span> <span class="nav-text">image组件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十五课（unity-UGUI-RectTransform组件与UI屏幕适配）"><span class="nav-number">16.</span> <span class="nav-text">第十五课（unity_UGUI_RectTransform组件与UI屏幕适配）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十六课（Unity-UGUI-Image与Sprite-2D-and-UI-）"><span class="nav-number">17.</span> <span class="nav-text">第十六课（Unity_UGUI_Image与Sprite(2D_and_UI)）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十七课（Unity-UGUI-RawImage与Texture和Button）"><span class="nav-number">18.</span> <span class="nav-text">第十七课（Unity_UGUI_RawImage与Texture和Button）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十八课（Unity-UGUI-Mask-布局-Text组件）"><span class="nav-number">19.</span> <span class="nav-text">第十八课（Unity_UGUI_Mask_布局_Text组件）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十九课（Unity-UGUI-Solider-Toggle-InputTextfiled组件）"><span class="nav-number">20.</span> <span class="nav-text">第十九课（Unity_UGUI_Solider_Toggle_InputTextfiled组件）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十课（Unity-Recttransform-stretch-预制体-ScrollView）"><span class="nav-number">21.</span> <span class="nav-text">第二十课（Unity_Recttransform_stretch_预制体_ScrollView）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十一课（Unity-Input输入详解）"><span class="nav-number">22.</span> <span class="nav-text">第二十一课（Unity_Input输入详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取虚拟轴的值"><span class="nav-number">22.1.</span> <span class="nav-text">获取虚拟轴的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟按键-判断按键有没有按下"><span class="nav-number">22.2.</span> <span class="nav-text">虚拟按键 判断按键有没有按下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断鼠标有没有按下"><span class="nav-number">22.3.</span> <span class="nav-text">判断鼠标有没有按下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Input-Manager参数"><span class="nav-number">22.4.</span> <span class="nav-text">Input Manager参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十二课（Unity-帧动画播放组件）"><span class="nav-number">23.</span> <span class="nav-text">第二十二课（Unity_帧动画播放组件）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十三课（Unity定时器事件委托节点操作）"><span class="nav-number">24.</span> <span class="nav-text">第二十三课（Unity定时器事件委托节点操作）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十四课（Unity-BmpFont的使用和第一个编辑器扩展功能）"><span class="nav-number">25.</span> <span class="nav-text">第二十四课（Unity_BmpFont的使用和第一个编辑器扩展功能）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#手动计算字模"><span class="nav-number">25.1.</span> <span class="nav-text">手动计算字模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展编辑器自动计算字摸（字体模型库）"><span class="nav-number">25.2.</span> <span class="nav-text">扩展编辑器自动计算字摸（字体模型库）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十五课（Unity物理引擎的使用-一-）"><span class="nav-number">26.</span> <span class="nav-text">第二十五课（Unity物理引擎的使用(一)）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑-Camera跟随玩家）"><span class="nav-number">27.</span> <span class="nav-text">第二十六课（Unity刚体组件键盘控制人物跑动跳跃物理地形编辑_Camera跟随玩家）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十七课（Unity碰撞管理与碰撞检测）"><span class="nav-number">28.</span> <span class="nav-text">第二十七课（Unity碰撞管理与碰撞检测）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#物体碰撞器"><span class="nav-number">28.1.</span> <span class="nav-text">物体碰撞器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（二十八-amp-二十九）一个2D项目（飞机大战）"><span class="nav-number">29.</span> <span class="nav-text">（二十八&amp;二十九）一个2D项目（飞机大战）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RequireComponent-typeof-Componentname"><span class="nav-number">29.1.</span> <span class="nav-text">[RequireComponent(typeof(Componentname))]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第030课（Unity3D物理引擎-一-刚体碰撞器材质）"><span class="nav-number">30.</span> <span class="nav-text">第030课（Unity3D物理引擎(一)刚体碰撞器材质）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AddForce（世界坐标方向的力）"><span class="nav-number">30.1.</span> <span class="nav-text">AddForce（世界坐标方向的力）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AddRelativeForce（相对坐标方向的力，模型坐标）"><span class="nav-number">30.2.</span> <span class="nav-text">AddRelativeForce（相对坐标方向的力，模型坐标）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AddTorque（世界坐标方向力）"><span class="nav-number">30.3.</span> <span class="nav-text">AddTorque（世界坐标方向力）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AddRelativeTorque（相对坐标方向力，模型坐标）"><span class="nav-number">30.4.</span> <span class="nav-text">AddRelativeTorque（相对坐标方向力，模型坐标）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理管理器"><span class="nav-number">30.5.</span> <span class="nav-text">物理管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理形状-碰撞器"><span class="nav-number">30.6.</span> <span class="nav-text">物理形状/碰撞器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理材质"><span class="nav-number">30.7.</span> <span class="nav-text">物理材质</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十一课（Unity3D物理引擎-二-刚体碰撞检测配置与触发器配置）"><span class="nav-number">31.</span> <span class="nav-text">第三十一课（Unity3D物理引擎(二)刚体碰撞检测配置与触发器配置）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十二课（unity-自带摇杆与车轮碰撞器的使用）"><span class="nav-number">32.</span> <span class="nav-text">第三十二课（unity_自带摇杆与车轮碰撞器的使用）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十三课（unity关节的基本介绍和基本使用）"><span class="nav-number">33.</span> <span class="nav-text">第三十三课（unity关节的基本介绍和基本使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关节"><span class="nav-number">33.1.</span> <span class="nav-text">关节</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十四（关节案例分析）"><span class="nav-number">34.</span> <span class="nav-text">第三十四（关节案例分析）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十五（蒙皮网格与布料组件的介绍和基本使用）"><span class="nav-number">35.</span> <span class="nav-text">第三十五（蒙皮网格与布料组件的介绍和基本使用）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十六课（粒子系统和基本使用）"><span class="nav-number">36.</span> <span class="nav-text">第三十六课（粒子系统和基本使用）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十七课（初识shader）"><span class="nav-number">37.</span> <span class="nav-text">第三十七课（初识shader）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shader概述"><span class="nav-number">37.1.</span> <span class="nav-text">shader概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPU编程语言"><span class="nav-number">37.2.</span> <span class="nav-text">GPU编程语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties"><span class="nav-number">37.3.</span> <span class="nav-text">Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Subshaders"><span class="nav-number">37.4.</span> <span class="nav-text">Subshaders</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fallback"><span class="nav-number">37.5.</span> <span class="nav-text">Fallback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Category分类"><span class="nav-number">37.6.</span> <span class="nav-text">Category分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十八课（unity-顶点片元shader与第一个shader）"><span class="nav-number">38.</span> <span class="nav-text">第三十八课（unity_顶点片元shader与第一个shader）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#坐标空间"><span class="nav-number">38.1.</span> <span class="nav-text">坐标空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity坐标系转换"><span class="nav-number">38.2.</span> <span class="nav-text">Unity坐标系转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPU管道流水线"><span class="nav-number">38.3.</span> <span class="nav-text">GPU管道流水线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顶点片元着色器"><span class="nav-number">38.4.</span> <span class="nav-text">顶点片元着色器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用语义"><span class="nav-number">38.5.</span> <span class="nav-text">常用语义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三十九课（unity-Cg基础知识和基本使用）"><span class="nav-number">39.</span> <span class="nav-text">第三十九课（unity_Cg基础知识和基本使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本类型表达式"><span class="nav-number">39.1.</span> <span class="nav-text">基本类型表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准内置函数"><span class="nav-number">39.2.</span> <span class="nav-text">标准内置函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity自带函数"><span class="nav-number">39.3.</span> <span class="nav-text">Unity自带函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十课（顶点片元Shader实例-正波-UV动画）"><span class="nav-number">40.</span> <span class="nav-text">第四十课（顶点片元Shader实例_正波_UV动画）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#float4-fixed4-Time"><span class="nav-number">40.1.</span> <span class="nav-text">float4 fixed4 _Time</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十一课（表面着色器的基础知识和shader结构）"><span class="nav-number">41.</span> <span class="nav-text">第四十一课（表面着色器的基础知识和shader结构）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#入口函数"><span class="nav-number">41.1.</span> <span class="nav-text">入口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它可选参数"><span class="nav-number">41.2.</span> <span class="nav-text">其它可选参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity坐标系转换-1"><span class="nav-number">41.3.</span> <span class="nav-text">Unity坐标系转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十二课（通用管道的通用指令-一-LOD与渲染队列）"><span class="nav-number">42.</span> <span class="nav-text">第四十二课（通用管道的通用指令(一) LOD与渲染队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LOD"><span class="nav-number">42.1.</span> <span class="nav-text">LOD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染队列"><span class="nav-number">42.2.</span> <span class="nav-text">渲染队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十三课（unity-渲染通道通用指令-二-）"><span class="nav-number">43.</span> <span class="nav-text">第四十三课（unity_渲染通道通用指令(二)）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#混合模式"><span class="nav-number">43.1.</span> <span class="nav-text">混合模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alpha测试"><span class="nav-number">43.2.</span> <span class="nav-text">Alpha测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道遮罩"><span class="nav-number">43.3.</span> <span class="nav-text">通道遮罩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面剔除"><span class="nav-number">43.4.</span> <span class="nav-text">面剔除</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十四课（unity-Shader抓屏通道-多条件编译-Shader注意事项）"><span class="nav-number">44.</span> <span class="nav-text">第四十四课（unity_Shader抓屏通道_多条件编译_Shader注意事项）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GrabPass"><span class="nav-number">44.1.</span> <span class="nav-text">GrabPass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的gcinc"><span class="nav-number">44.2.</span> <span class="nav-text">常用的gcinc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UnityCG-gcinc常用函数"><span class="nav-number">44.3.</span> <span class="nav-text">UnityCG.gcinc常用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UsePass-通道-复用"><span class="nav-number">44.4.</span> <span class="nav-text">UsePass(通道) 复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multi-compile-编写不同版本的shader"><span class="nav-number">44.5.</span> <span class="nav-text">multi_compile(编写不同版本的shader)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动平台优化"><span class="nav-number">44.6.</span> <span class="nav-text">移动平台优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十五课（unity-天空盒3D拾取本地存储）"><span class="nav-number">45.</span> <span class="nav-text">第四十五课（unity_天空盒3D拾取本地存储）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#天空盒（也是种材质-skybox）"><span class="nav-number">45.1.</span> <span class="nav-text">天空盒（也是种材质 skybox）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3D拾取"><span class="nav-number">45.2.</span> <span class="nav-text">3D拾取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地存储"><span class="nav-number">45.3.</span> <span class="nav-text">本地存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十六课（unity-2D-3D声音的使用）"><span class="nav-number">46.</span> <span class="nav-text">第四十六课（unity_2D_3D声音的使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#音频监听器"><span class="nav-number">46.1.</span> <span class="nav-text">音频监听器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AudioSource"><span class="nav-number">46.2.</span> <span class="nav-text">AudioSource</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#水"><span class="nav-number">46.3.</span> <span class="nav-text">水</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十八课（unity-光照-二-）"><span class="nav-number">47.</span> <span class="nav-text">第四十八课（unity_光照(二)）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#光源类型"><span class="nav-number">47.1.</span> <span class="nav-text">光源类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发光材质-必须使用在static物体上才可以"><span class="nav-number">47.2.</span> <span class="nav-text">发光材质(必须使用在static物体上才可以)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Light组件的参数"><span class="nav-number">47.3.</span> <span class="nav-text">Light组件的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#光照贴图"><span class="nav-number">47.4.</span> <span class="nav-text">光照贴图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#光照烘培的参数详解"><span class="nav-number">47.5.</span> <span class="nav-text">光照烘培的参数详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四十九课（unity光照-三-法线贴图与阴影设置详解）"><span class="nav-number">48.</span> <span class="nav-text">第四十九课（unity光照(三)法线贴图与阴影设置详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#法线贴图"><span class="nav-number">48.1.</span> <span class="nav-text">法线贴图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阴影的设置-光照"><span class="nav-number">48.2.</span> <span class="nav-text">阴影的设置(光照)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阴影的优化"><span class="nav-number">48.3.</span> <span class="nav-text">阴影的优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十课（unity光照-四-渲染路径-颜色空间-Cookies-Flare-光照过滤）"><span class="nav-number">49.</span> <span class="nav-text">第五十课（unity光照(四)渲染路径_颜色空间_Cookies_Flare_光照过滤）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染路径和颜色空间"><span class="nav-number">49.1.</span> <span class="nav-text">渲染路径和颜色空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜头光晕"><span class="nav-number">49.2.</span> <span class="nav-text">镜头光晕</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十一课（unity光照-五-Stander着色器mobilediffuse着色器光探头的原理和使用）"><span class="nav-number">50.</span> <span class="nav-text">第五十一课（unity光照(五)Stander着色器mobilediffuse着色器光探头的原理和使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#光探头"><span class="nav-number">50.1.</span> <span class="nav-text">光探头</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十二课（unity光照-六-反射探头的使用）"><span class="nav-number">51.</span> <span class="nav-text">第五十二课（unity光照(六)反射探头的使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射探头"><span class="nav-number">51.1.</span> <span class="nav-text">反射探头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射探头模式"><span class="nav-number">51.2.</span> <span class="nav-text">反射探头模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位置大小"><span class="nav-number">51.3.</span> <span class="nav-text">位置大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环反射"><span class="nav-number">51.4.</span> <span class="nav-text">循环反射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十三课（unity-光照系统-七-Realtime-BakedGI-预计算全局光照-全局光照详解）"><span class="nav-number">52.</span> <span class="nav-text">第五十三课（unity_光照系统(七)_Realtime_BakedGI_预计算全局光照._全局光照详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局光照-GI"><span class="nav-number">52.1.</span> <span class="nav-text">全局光照 GI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预先计算全局光照-物体必须为Static，才能看到效果"><span class="nav-number">52.2.</span> <span class="nav-text">预先计算全局光照(物体必须为Static，才能看到效果)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十四课（unity-Mesh网格的详解）"><span class="nav-number">53.</span> <span class="nav-text">第五十四课（unity_Mesh网格的详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3D建模软件"><span class="nav-number">53.1.</span> <span class="nav-text">3D建模软件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网格Mesh"><span class="nav-number">53.2.</span> <span class="nav-text">网格Mesh</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mesh的重要属性"><span class="nav-number">53.3.</span> <span class="nav-text">Mesh的重要属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空物体通过用代码绘制模型"><span class="nav-number">53.4.</span> <span class="nav-text">空物体通过用代码绘制模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展三角形面"><span class="nav-number">53.5.</span> <span class="nav-text">扩展三角形面</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十五课（unity-旧版动画系统）"><span class="nav-number">54.</span> <span class="nav-text">第五十五课（unity_旧版动画系统）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#旧版动画系统"><span class="nav-number">54.1.</span> <span class="nav-text">旧版动画系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码播放"><span class="nav-number">54.2.</span> <span class="nav-text">代码播放</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十六课（unity-mecanim人形动画系统-一-Avatar动画控制器）"><span class="nav-number">55.</span> <span class="nav-text">第五十六课（unity_mecanim人形动画系统(一)Avatar动画控制器）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mecanim动画"><span class="nav-number">55.1.</span> <span class="nav-text">Mecanim动画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置Avatar"><span class="nav-number">55.2.</span> <span class="nav-text">配置Avatar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动画控制器配置"><span class="nav-number">55.3.</span> <span class="nav-text">动画控制器配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过渡条件"><span class="nav-number">55.4.</span> <span class="nav-text">过渡条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十七课（unity-人形动画重定向与动画混合树）"><span class="nav-number">56.</span> <span class="nav-text">第五十七课（unity_人形动画重定向与动画混合树）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重定向"><span class="nav-number">56.1.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#角色动画的混合"><span class="nav-number">56.2.</span> <span class="nav-text">角色动画的混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动画混合算法"><span class="nav-number">56.3.</span> <span class="nav-text">动画混合算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十八课-unity-动画单元代码控制-代码生成动画控制器"><span class="nav-number">57.</span> <span class="nav-text">第五十八课(unity_动画单元代码控制_代码生成动画控制器)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动画状态代码控制"><span class="nav-number">57.1.</span> <span class="nav-text">动画状态代码控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码生成动画控制器"><span class="nav-number">57.2.</span> <span class="nav-text">代码生成动画控制器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五十九课（unity-地形的创建）"><span class="nav-number">58.</span> <span class="nav-text">第五十九课（unity_地形的创建）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#地形的基本组件"><span class="nav-number">58.1.</span> <span class="nav-text">地形的基本组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Terrain"><span class="nav-number">58.1.1.</span> <span class="nav-text">Terrain</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Raise-And-Lower-Terrain-升高-下降地形"><span class="nav-number">58.1.1.1.</span> <span class="nav-text">Raise And Lower Terrain(升高/下降地形)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Paint-Height-涂料高度"><span class="nav-number">58.1.1.2.</span> <span class="nav-text">Paint Height(涂料高度)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Smooth-Height-平滑高度"><span class="nav-number">58.1.1.3.</span> <span class="nav-text">Smooth Height(平滑高度)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地形灰度图-导入灰度图制作地形，可以用psd文件"><span class="nav-number">58.1.1.4.</span> <span class="nav-text">地形灰度图(导入灰度图制作地形，可以用psd文件)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Paint-Texture（地形贴图）"><span class="nav-number">58.1.1.5.</span> <span class="nav-text">Paint Texture（地形贴图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Place-Trees（植树-可用预制体）"><span class="nav-number">58.1.1.6.</span> <span class="nav-text">Place Trees（植树 可用预制体）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Place-Details（植草-可以用psd文件-纹理-、预制体）"><span class="nav-number">58.1.1.7.</span> <span class="nav-text">Place Details（植草 可以用psd文件(纹理)、预制体）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TerrainSettings"><span class="nav-number">58.1.1.8.</span> <span class="nav-text">TerrainSettings</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十课（拖尾渲染器的使用）"><span class="nav-number">59.</span> <span class="nav-text">第六十课（拖尾渲染器的使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#拖尾渲染器-Trall-Renderer"><span class="nav-number">59.1.</span> <span class="nav-text">拖尾渲染器(Trall Renderer)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用事项"><span class="nav-number">59.2.</span> <span class="nav-text">使用事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十一课（unity-navmesh网格导航寻路）"><span class="nav-number">60.</span> <span class="nav-text">第六十一课（unity_navmesh网格导航寻路）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#烘焙网格导航"><span class="nav-number">60.1.</span> <span class="nav-text">烘焙网格导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nav-mesh-agent（代理器挂载到要寻路的物体）"><span class="nav-number">60.2.</span> <span class="nav-text">Nav mesh agent（代理器挂载到要寻路的物体）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义路线-Off-Mesh-Link"><span class="nav-number">60.3.</span> <span class="nav-text">自定义路线(Off Mesh Link)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态障碍物（Nav-mesh-obstacle）"><span class="nav-number">60.4.</span> <span class="nav-text">动态障碍物（Nav mesh obstacle）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十二课（unity-协程-多线程-WWW类）"><span class="nav-number">61.</span> <span class="nav-text">第六十二课（unity_协程_多线程_WWW类）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#协程"><span class="nav-number">61.1.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">61.2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WWW网络类"><span class="nav-number">61.2.1.</span> <span class="nav-text">WWW网络类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十三课（unity-AssetBundle的使用详解）"><span class="nav-number">62.</span> <span class="nav-text">第六十三课（unity_AssetBundle的使用详解）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle"><span class="nav-number">62.1.</span> <span class="nav-text">AssetBundle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle创建"><span class="nav-number">62.2.</span> <span class="nav-text">AssetBundle创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置AssetBundle打包-将要打包的资源配置好即可"><span class="nav-number">62.2.1.</span> <span class="nav-text">配置AssetBundle打包(将要打包的资源配置好即可)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用buildmap来对指定的资源进行打包"><span class="nav-number">62.2.2.</span> <span class="nav-text">使用buildmap来对指定的资源进行打包;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部署服务器"><span class="nav-number">62.3.</span> <span class="nav-text">部署服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle下载"><span class="nav-number">62.4.</span> <span class="nav-text">AssetBundle下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle加载使用-内存镜像"><span class="nav-number">62.5.</span> <span class="nav-text">AssetBundle加载使用(内存镜像)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle卸载"><span class="nav-number">62.6.</span> <span class="nav-text">AssetBundle卸载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十四课（专题-一-DOTween插件使用）"><span class="nav-number">63.</span> <span class="nav-text">第六十四课（专题(一)DOTween插件使用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装DOTween"><span class="nav-number">63.1.</span> <span class="nav-text">安装DOTween</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOTween组件扩展"><span class="nav-number">63.2.</span> <span class="nav-text">DOTween组件扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tweener常用操作"><span class="nav-number">63.3.</span> <span class="nav-text">Tweener常用操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sequence队列"><span class="nav-number">63.4.</span> <span class="nav-text">Sequence队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ease缓动效果"><span class="nav-number">63.5.</span> <span class="nav-text">Ease缓动效果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十五课（专题-二-游戏中的模型描边和Shader切换）"><span class="nav-number">64.</span> <span class="nav-text">第六十五课（专题(二)游戏中的模型描边和Shader切换）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模型描边"><span class="nav-number">64.1.</span> <span class="nav-text">模型描边</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码里面切换Shader"><span class="nav-number">64.2.</span> <span class="nav-text">代码里面切换Shader</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十六课（专题-三-常用数据结构与JSON处理）"><span class="nav-number">65.</span> <span class="nav-text">第六十六课（专题(三)常用数据结构与JSON处理）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-Array"><span class="nav-number">65.1.</span> <span class="nav-text">数组(Array)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">65.2.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">65.3.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典-Dictionary-lt-K-T-gt"><span class="nav-number">65.4.</span> <span class="nav-text">字典 Dictionary&lt;K, T&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#json数据格式"><span class="nav-number">65.5.</span> <span class="nav-text">json数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Json数据格式"><span class="nav-number">65.6.</span> <span class="nav-text">Json数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity5-3-JSON序列化"><span class="nav-number">65.7.</span> <span class="nav-text">Unity5.3 JSON序列化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十七课（专题-四-Unity常用目录和代码加载资源）"><span class="nav-number">66.</span> <span class="nav-text">第六十七课（专题(四)Unity常用目录和代码加载资源）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编辑器扩展目录（Editor）"><span class="nav-number">66.1.</span> <span class="nav-text">编辑器扩展目录（Editor）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Plugins"><span class="nav-number">66.2.</span> <span class="nav-text">Plugins</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resources目录"><span class="nav-number">66.3.</span> <span class="nav-text">Resources目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity资源管理"><span class="nav-number">66.4.</span> <span class="nav-text">Unity资源管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十八课（专题-五-移动的汽船）"><span class="nav-number">67.</span> <span class="nav-text">第六十八课（专题(五)移动的汽船）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#船的虚拟摇杆移动"><span class="nav-number">67.1.</span> <span class="nav-text">船的虚拟摇杆移动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#船在水中的摇摆"><span class="nav-number">67.2.</span> <span class="nav-text">船在水中的摇摆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#摄像机跟随"><span class="nav-number">67.3.</span> <span class="nav-text">摄像机跟随</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六十九课（unity-专题-六-Unity道具金币拾取）"><span class="nav-number">68.</span> <span class="nav-text">第六十九课（unity_专题(六)Unity道具金币拾取）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七十课（unity-专题-七-音乐音效管理）"><span class="nav-number">69.</span> <span class="nav-text">第七十课（unity_专题(七)音乐音效管理）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sound-manager"><span class="nav-number">69.1.</span> <span class="nav-text">sound_manager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七十一课（unity-专题-八-Unity漩涡特效切换）"><span class="nav-number">70.</span> <span class="nav-text">第七十一课（unity_专题(八)Unity漩涡特效切换）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mesh-材质-Shader"><span class="nav-number">70.1.</span> <span class="nav-text">Mesh 材质 Shader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#旋涡特效"><span class="nav-number">70.2.</span> <span class="nav-text">旋涡特效</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七十二课（unity-专题-九-Unity场景导出与导入）"><span class="nav-number">71.</span> <span class="nav-text">第七十二课（unity_专题(九)Unity场景导出与导入）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#天空盒的位置"><span class="nav-number">71.1.</span> <span class="nav-text">天空盒的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#场景导出案例"><span class="nav-number">71.2.</span> <span class="nav-text">场景导出案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七十四课（unity-专题-十-Unity-FPS第一人称射击类游戏）"><span class="nav-number">72.</span> <span class="nav-text">第七十四课（unity_专题(十)Unity_FPS第一人称射击类游戏）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AudioSource-的两个方法-Play-和-PlayOneShot-有什么区别"><span class="nav-number">72.1.</span> <span class="nav-text">AudioSource 的两个方法 Play 和 PlayOneShot 有什么区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七十九课（unity-专题-十一-ARPG游戏摇杆控制角色行走）"><span class="nav-number">73.</span> <span class="nav-text">第七十九课（unity_专题(十一)ARPG游戏摇杆控制角色行走）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#人物操作方式"><span class="nav-number">73.1.</span> <span class="nav-text">人物操作方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CharacterController组件-角色控制器"><span class="nav-number">73.2.</span> <span class="nav-text">CharacterController组件(角色控制器)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弧度-顺时针角度是负的，逆时针角度是正的"><span class="nav-number">73.3.</span> <span class="nav-text">弧度(顺时针角度是负的，逆时针角度是正的)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unity-安卓打包"><span class="nav-number">74.</span> <span class="nav-text">unity_安卓打包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java安装好sdk之后新建两个环境变量"><span class="nav-number">74.1.</span> <span class="nav-text">java安装好sdk之后新建两个环境变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lua"><span class="nav-number">75.</span> <span class="nav-text">Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lua表中的"><span class="nav-number">75.1.</span> <span class="nav-text">lua表中的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#table的sort比较函数"><span class="nav-number">75.2.</span> <span class="nav-text">table的sort比较函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解开数组（unpack）"><span class="nav-number">75.3.</span> <span class="nav-text">解开数组（unpack）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块化"><span class="nav-number">75.4.</span> <span class="nav-text">模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#require装载lua脚本（不用加后缀）"><span class="nav-number">75.4.1.</span> <span class="nav-text">require装载lua脚本（不用加后缀）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局模块module（全局包）"><span class="nav-number">75.4.2.</span> <span class="nav-text">全局模块module（全局包）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dofile装载脚本（需要加后缀）"><span class="nav-number">75.4.3.</span> <span class="nav-text">dofile装载脚本（需要加后缀）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self"><span class="nav-number">75.4.4.</span> <span class="nav-text">self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self机制需要正常运行，需要两个点"><span class="nav-number">75.4.5.</span> <span class="nav-text">self机制需要正常运行，需要两个点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元表"><span class="nav-number">75.5.</span> <span class="nav-text">元表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模拟面向对象的语法"><span class="nav-number">75.6.</span> <span class="nav-text">模拟面向对象的语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承、重载"><span class="nav-number">75.7.</span> <span class="nav-text">继承、重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lua热更新"><span class="nav-number">76.</span> <span class="nav-text">Lua热更新</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#资源管理与lua框架开发基本原则"><span class="nav-number">76.1.</span> <span class="nav-text">资源管理与lua框架开发基本原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全新资源管理模式"><span class="nav-number">76.1.1.</span> <span class="nav-text">全新资源管理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本设计的原理原则"><span class="nav-number">76.1.2.</span> <span class="nav-text">基本设计的原理原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#热更与资源管理模块的设计演示"><span class="nav-number">76.1.3.</span> <span class="nav-text">热更与资源管理模块的设计演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯lua开发的注意事项与性能瓶颈"><span class="nav-number">76.1.4.</span> <span class="nav-text">纯lua开发的注意事项与性能瓶颈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目创建与Lua启动流程"><span class="nav-number">76.2.</span> <span class="nav-text">项目创建与Lua启动流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lua的组件开发模式"><span class="nav-number">76.3.</span> <span class="nav-text">lua的组件开发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lua启动脚本开发入口"><span class="nav-number">76.3.1.</span> <span class="nav-text">lua启动脚本开发入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lua组件化开发模式设计理念"><span class="nav-number">76.3.2.</span> <span class="nav-text">lua组件化开发模式设计理念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lua组件类基类的设计"><span class="nav-number">76.3.3.</span> <span class="nav-text">lua组件类基类的设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lua调用unity"><span class="nav-number">76.4.</span> <span class="nav-text">lua调用unity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lua调用unity-1"><span class="nav-number">76.4.1.</span> <span class="nav-text">lua调用unity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddComponent-unity组件"><span class="nav-number">76.4.2.</span> <span class="nav-text">AddComponent(unity组件)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unity导出接口给lua使用"><span class="nav-number">76.4.3.</span> <span class="nav-text">unity导出接口给lua使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetsBundles打包管理的使用"><span class="nav-number">76.5.</span> <span class="nav-text">AssetsBundles打包管理的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC与AssetsBundles步骤详解"><span class="nav-number">76.6.</span> <span class="nav-text">GC与AssetsBundles步骤详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Editor-–-gt-XLuaMenu-文件下做的事情"><span class="nav-number">76.6.1.</span> <span class="nav-text">Editor –&gt; XLuaMenu 文件下做的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同开关模式的详解（Switch-Model）"><span class="nav-number">76.6.2.</span> <span class="nav-text">不同开关模式的详解（Switch Model）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渠道和版本管理"><span class="nav-number">76.6.3.</span> <span class="nav-text">渠道和版本管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Assetbundle打包配置与源码详解"><span class="nav-number">76.7.</span> <span class="nav-text">Assetbundle打包配置与源码详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle打包流程分析"><span class="nav-number">76.8.</span> <span class="nav-text">AssetBundle打包流程分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AssetBundle资源加载"><span class="nav-number">76.9.</span> <span class="nav-text">AssetBundle资源加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lua热更dome"><span class="nav-number">76.10.</span> <span class="nav-text">lua热更dome</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#热更流程"><span class="nav-number">76.10.1.</span> <span class="nav-text">热更流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#搭建一个简单的webserver"><span class="nav-number">76.10.1.1.</span> <span class="nav-text">搭建一个简单的webserver</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NGUI"><span class="nav-number">76.11.</span> <span class="nav-text">NGUI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NGUI-字体"><span class="nav-number">76.12.</span> <span class="nav-text">NGUI - 字体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NGUI-精灵-图集"><span class="nav-number">76.13.</span> <span class="nav-text">NGUI - 精灵/图集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NGUI-锚点-帧动画-Tween动画-Checkbox复选框-Button事件回调-Slider滑动条"><span class="nav-number">76.14.</span> <span class="nav-text">NGUI_锚点_帧动画_Tween动画_Checkbox复选框_Button事件回调_Slider滑动条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NGUI-打字机效果Tab商城背包之Scrollview1（基于panel）"><span class="nav-number">76.15.</span> <span class="nav-text">NGUI_打字机效果Tab商城背包之Scrollview1（基于panel）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018/10/13 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">游戏人生</span>

  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> 底部hexo 驱动字



  <span class="post-meta-divider">|</span> 底部hexo 驱动字 |

-->

  <div>Welcome to TJL's blog</div>
  <!--<div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div> 底部hexo 驱动字-->

<!--<span class="post-count">Total Words:115.3k</span> 站内字总数-->

<!-- 新增访客统计代码 -->

<div class="busuanzi-count">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count">115.3k</span> 字
    </span>
</div>
<!-- 新增访客统计代码 END-->

<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/21/2018 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  


</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

<!--崩溃欺骗-->
<script type="text/javascript" src="/js/src/crash_cheat.js"></script>

<!--自动浏览-->
<script type="text/javascript" src="/js/src/my_auto.js"></script>

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
